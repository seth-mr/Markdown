/*
This code is Copyright © 2023 screengarden, LLC, all rights reserved. Unauthorized copying of any files herein, via any medium and for any purpose, is prohibited, with the exception of any copying that occurs during the installation of these files as an Obsidian plugin.

"Obsidian" and the Obsidian logo are © 2023 Obsidian.
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all4) => {
  for (var name in all4)
    __defProp(target, name, { get: all4[name], enumerable: true });
};
var __copyProps = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// node_modules/process/browser.js
var require_browser = __commonJS({
  "node_modules/process/browser.js"(exports2, module2) {
    init_process_shim();
    var process3 = module2.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    __name(defaultSetTimout, "defaultSetTimout");
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    __name(defaultClearTimeout, "defaultClearTimeout");
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e2) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    __name(runTimeout, "runTimeout");
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e2) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    __name(runClearTimeout, "runClearTimeout");
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    __name(cleanUpNextTick, "cleanUpNextTick");
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    __name(drainQueue, "drainQueue");
    process3.nextTick = function(fun) {
      var args2 = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args2[i - 1] = arguments[i];
        }
      }
      queue.push(new Item2(fun, args2));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item2(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    __name(Item2, "Item");
    Item2.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process3.title = "browser";
    process3.browser = true;
    process3.env = {};
    process3.argv = [];
    process3.version = "";
    process3.versions = {};
    function noop4() {
    }
    __name(noop4, "noop");
    process3.on = noop4;
    process3.addListener = noop4;
    process3.once = noop4;
    process3.off = noop4;
    process3.removeListener = noop4;
    process3.removeAllListeners = noop4;
    process3.emit = noop4;
    process3.prependListener = noop4;
    process3.prependOnceListener = noop4;
    process3.listeners = function(name) {
      return [];
    };
    process3.binding = function(name) {
      throw new Error("process.binding is not supported");
    };
    process3.cwd = function() {
      return "/";
    };
    process3.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process3.umask = function() {
      return 0;
    };
  }
});

// process-shim.js
var import_browser;
var init_process_shim = __esm({
  "process-shim.js"() {
    import_browser = __toESM(require_browser());
    if (typeof window !== "undefined") {
      window.global = window.global || window;
    }
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    init_process_shim();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d2 = h * 24;
    var w = d2 * 7;
    var y = d2 * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    __name(parse, "parse");
    function fmtShort(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d2) {
        return Math.round(ms2 / d2) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms2 / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms2 / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms2 / s) + "s";
      }
      return ms2 + "ms";
    }
    __name(fmtShort, "fmtShort");
    function fmtLong(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d2) {
        return plural2(ms2, msAbs, d2, "day");
      }
      if (msAbs >= h) {
        return plural2(ms2, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural2(ms2, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural2(ms2, msAbs, s, "second");
      }
      return ms2 + " ms";
    }
    __name(fmtLong, "fmtLong");
    function plural2(ms2, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
    }
    __name(plural2, "plural");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    init_process_shim();
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      __name(selectColor, "selectColor");
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug23(...args2) {
          if (!debug23.enabled) {
            return;
          }
          const self2 = debug23;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args2[0] = createDebug.coerce(args2[0]);
          if (typeof args2[0] !== "string") {
            args2.unshift("%O");
          }
          let index = 0;
          args2[0] = args2[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args2[index];
              match = formatter.call(self2, val);
              args2.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args2);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args2);
        }
        __name(debug23, "debug");
        debug23.namespace = namespace;
        debug23.useColors = createDebug.useColors();
        debug23.color = createDebug.selectColor(namespace);
        debug23.extend = extend2;
        debug23.destroy = createDebug.destroy;
        Object.defineProperty(debug23, "enabled", {
          enumerable: true,
          configurable: false,
          get: /* @__PURE__ */ __name(() => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          }, "get"),
          set: /* @__PURE__ */ __name((v) => {
            enableOverride = v;
          }, "set")
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug23);
        }
        return debug23;
      }
      __name(createDebug, "createDebug");
      function extend2(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      __name(extend2, "extend");
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      __name(enable, "enable");
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      __name(matchesTemplate, "matchesTemplate");
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      __name(disable, "disable");
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      __name(enabled, "enabled");
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      __name(coerce, "coerce");
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      __name(destroy, "destroy");
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    __name(setup, "setup");
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    init_process_shim();
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    __name(useColors, "useColors");
    function formatArgs(args2) {
      args2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args2[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args2.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args2[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args2.splice(lastC, 0, c);
    }
    __name(formatArgs, "formatArgs");
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    __name(save, "save");
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof import_browser.default !== "undefined" && "env" in import_browser.default) {
        r = import_browser.default.env.DEBUG;
      }
      return r;
    }
    __name(load, "load");
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    __name(localstorage, "localstorage");
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/react/cjs/react.production.min.js
var require_react_production_min = __commonJS({
  "node_modules/react/cjs/react.production.min.js"(exports2) {
    "use strict";
    init_process_shim();
    var l = Symbol.for("react.element");
    var n = Symbol.for("react.portal");
    var p = Symbol.for("react.fragment");
    var q = Symbol.for("react.strict_mode");
    var r = Symbol.for("react.profiler");
    var t = Symbol.for("react.provider");
    var u = Symbol.for("react.context");
    var v = Symbol.for("react.forward_ref");
    var w = Symbol.for("react.suspense");
    var x = Symbol.for("react.memo");
    var y = Symbol.for("react.lazy");
    var z = Symbol.iterator;
    function A(a) {
      if (null === a || "object" !== typeof a) return null;
      a = z && a[z] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    __name(A, "A");
    var B = { isMounted: /* @__PURE__ */ __name(function() {
      return false;
    }, "isMounted"), enqueueForceUpdate: /* @__PURE__ */ __name(function() {
    }, "enqueueForceUpdate"), enqueueReplaceState: /* @__PURE__ */ __name(function() {
    }, "enqueueReplaceState"), enqueueSetState: /* @__PURE__ */ __name(function() {
    }, "enqueueSetState") };
    var C = Object.assign;
    var D = {};
    function E(a, b, e) {
      this.props = a;
      this.context = b;
      this.refs = D;
      this.updater = e || B;
    }
    __name(E, "E");
    E.prototype.isReactComponent = {};
    E.prototype.setState = function(a, b) {
      if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a, b, "setState");
    };
    E.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function F() {
    }
    __name(F, "F");
    F.prototype = E.prototype;
    function G(a, b, e) {
      this.props = a;
      this.context = b;
      this.refs = D;
      this.updater = e || B;
    }
    __name(G, "G");
    var H = G.prototype = new F();
    H.constructor = G;
    C(H, E.prototype);
    H.isPureReactComponent = true;
    var I = Array.isArray;
    var J = Object.prototype.hasOwnProperty;
    var K = { current: null };
    var L = { key: true, ref: true, __self: true, __source: true };
    function M(a, b, e) {
      var d2, c = {}, k = null, h = null;
      if (null != b) for (d2 in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d2) && !L.hasOwnProperty(d2) && (c[d2] = b[d2]);
      var g = arguments.length - 2;
      if (1 === g) c.children = e;
      else if (1 < g) {
        for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
        c.children = f;
      }
      if (a && a.defaultProps) for (d2 in g = a.defaultProps, g) void 0 === c[d2] && (c[d2] = g[d2]);
      return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K.current };
    }
    __name(M, "M");
    function N(a, b) {
      return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
    }
    __name(N, "N");
    function O(a) {
      return "object" === typeof a && null !== a && a.$$typeof === l;
    }
    __name(O, "O");
    function escape2(a) {
      var b = { "=": "=0", ":": "=2" };
      return "$" + a.replace(/[=:]/g, function(a2) {
        return b[a2];
      });
    }
    __name(escape2, "escape");
    var P = /\/+/g;
    function Q(a, b) {
      return "object" === typeof a && null !== a && null != a.key ? escape2("" + a.key) : b.toString(36);
    }
    __name(Q, "Q");
    function R(a, b, e, d2, c) {
      var k = typeof a;
      if ("undefined" === k || "boolean" === k) a = null;
      var h = false;
      if (null === a) h = true;
      else switch (k) {
        case "string":
        case "number":
          h = true;
          break;
        case "object":
          switch (a.$$typeof) {
            case l:
            case n:
              h = true;
          }
      }
      if (h) return h = a, c = c(h), a = "" === d2 ? "." + Q(h, 0) : d2, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
        return a2;
      })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
      h = 0;
      d2 = "" === d2 ? "." : d2 + ":";
      if (I(a)) for (var g = 0; g < a.length; g++) {
        k = a[g];
        var f = d2 + Q(k, g);
        h += R(k, b, e, f, c);
      }
      else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done; ) k = k.value, f = d2 + Q(k, g++), h += R(k, b, e, f, c);
      else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
      return h;
    }
    __name(R, "R");
    function S(a, b, e) {
      if (null == a) return a;
      var d2 = [], c = 0;
      R(a, d2, "", "", function(a2) {
        return b.call(e, a2, c++);
      });
      return d2;
    }
    __name(S, "S");
    function T(a) {
      if (-1 === a._status) {
        var b = a._result;
        b = b();
        b.then(function(b2) {
          if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
        }, function(b2) {
          if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
        });
        -1 === a._status && (a._status = 0, a._result = b);
      }
      if (1 === a._status) return a._result.default;
      throw a._result;
    }
    __name(T, "T");
    var U = { current: null };
    var V = { transition: null };
    var W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
    exports2.Children = { map: S, forEach: /* @__PURE__ */ __name(function(a, b, e) {
      S(a, function() {
        b.apply(this, arguments);
      }, e);
    }, "forEach"), count: /* @__PURE__ */ __name(function(a) {
      var b = 0;
      S(a, function() {
        b++;
      });
      return b;
    }, "count"), toArray: /* @__PURE__ */ __name(function(a) {
      return S(a, function(a2) {
        return a2;
      }) || [];
    }, "toArray"), only: /* @__PURE__ */ __name(function(a) {
      if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
      return a;
    }, "only") };
    exports2.Component = E;
    exports2.Fragment = p;
    exports2.Profiler = r;
    exports2.PureComponent = G;
    exports2.StrictMode = q;
    exports2.Suspense = w;
    exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
    exports2.cloneElement = function(a, b, e) {
      if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
      var d2 = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
      if (null != b) {
        void 0 !== b.ref && (k = b.ref, h = K.current);
        void 0 !== b.key && (c = "" + b.key);
        if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
        for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d2[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
      }
      var f = arguments.length - 2;
      if (1 === f) d2.children = e;
      else if (1 < f) {
        g = Array(f);
        for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
        d2.children = g;
      }
      return { $$typeof: l, type: a.type, key: c, ref: k, props: d2, _owner: h };
    };
    exports2.createContext = function(a) {
      a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      a.Provider = { $$typeof: t, _context: a };
      return a.Consumer = a;
    };
    exports2.createElement = M;
    exports2.createFactory = function(a) {
      var b = M.bind(null, a);
      b.type = a;
      return b;
    };
    exports2.createRef = function() {
      return { current: null };
    };
    exports2.forwardRef = function(a) {
      return { $$typeof: v, render: a };
    };
    exports2.isValidElement = O;
    exports2.lazy = function(a) {
      return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
    };
    exports2.memo = function(a, b) {
      return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
    };
    exports2.startTransition = function(a) {
      var b = V.transition;
      V.transition = {};
      try {
        a();
      } finally {
        V.transition = b;
      }
    };
    exports2.unstable_act = function() {
      throw Error("act(...) is not supported in production builds of React.");
    };
    exports2.useCallback = function(a, b) {
      return U.current.useCallback(a, b);
    };
    exports2.useContext = function(a) {
      return U.current.useContext(a);
    };
    exports2.useDebugValue = function() {
    };
    exports2.useDeferredValue = function(a) {
      return U.current.useDeferredValue(a);
    };
    exports2.useEffect = function(a, b) {
      return U.current.useEffect(a, b);
    };
    exports2.useId = function() {
      return U.current.useId();
    };
    exports2.useImperativeHandle = function(a, b, e) {
      return U.current.useImperativeHandle(a, b, e);
    };
    exports2.useInsertionEffect = function(a, b) {
      return U.current.useInsertionEffect(a, b);
    };
    exports2.useLayoutEffect = function(a, b) {
      return U.current.useLayoutEffect(a, b);
    };
    exports2.useMemo = function(a, b) {
      return U.current.useMemo(a, b);
    };
    exports2.useReducer = function(a, b, e) {
      return U.current.useReducer(a, b, e);
    };
    exports2.useRef = function(a) {
      return U.current.useRef(a);
    };
    exports2.useState = function(a) {
      return U.current.useState(a);
    };
    exports2.useSyncExternalStore = function(a, b, e) {
      return U.current.useSyncExternalStore(a, b, e);
    };
    exports2.useTransition = function() {
      return U.current.useTransition();
    };
    exports2.version = "18.2.0";
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports2, module2) {
    "use strict";
    init_process_shim();
    if (true) {
      module2.exports = require_react_production_min();
    } else {
      module2.exports = null;
    }
  }
});

// node_modules/react/cjs/react-jsx-runtime.production.min.js
var require_react_jsx_runtime_production_min = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.production.min.js"(exports2) {
    "use strict";
    init_process_shim();
    var f = require_react();
    var k = Symbol.for("react.element");
    var l = Symbol.for("react.fragment");
    var m = Object.prototype.hasOwnProperty;
    var n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;
    var p = { key: true, ref: true, __self: true, __source: true };
    function q(c, a, g) {
      var b, d2 = {}, e = null, h = null;
      void 0 !== g && (e = "" + g);
      void 0 !== a.key && (e = "" + a.key);
      void 0 !== a.ref && (h = a.ref);
      for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d2[b] = a[b]);
      if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d2[b] && (d2[b] = a[b]);
      return { $$typeof: k, type: c, key: e, ref: h, props: d2, _owner: n.current };
    }
    __name(q, "q");
    exports2.Fragment = l;
    exports2.jsx = q;
    exports2.jsxs = q;
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports2, module2) {
    "use strict";
    init_process_shim();
    if (true) {
      module2.exports = require_react_jsx_runtime_production_min();
    } else {
      module2.exports = null;
    }
  }
});

// node_modules/scheduler/cjs/scheduler.production.min.js
var require_scheduler_production_min = __commonJS({
  "node_modules/scheduler/cjs/scheduler.production.min.js"(exports2) {
    "use strict";
    init_process_shim();
    function f(a, b) {
      var c = a.length;
      a.push(b);
      a: for (; 0 < c; ) {
        var d2 = c - 1 >>> 1, e = a[d2];
        if (0 < g(e, b)) a[d2] = b, a[c] = e, c = d2;
        else break a;
      }
    }
    __name(f, "f");
    function h(a) {
      return 0 === a.length ? null : a[0];
    }
    __name(h, "h");
    function k(a) {
      if (0 === a.length) return null;
      var b = a[0], c = a.pop();
      if (c !== b) {
        a[0] = c;
        a: for (var d2 = 0, e = a.length, w = e >>> 1; d2 < w; ) {
          var m = 2 * (d2 + 1) - 1, C = a[m], n = m + 1, x = a[n];
          if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d2] = x, a[n] = c, d2 = n) : (a[d2] = C, a[m] = c, d2 = m);
          else if (n < e && 0 > g(x, c)) a[d2] = x, a[n] = c, d2 = n;
          else break a;
        }
      }
      return b;
    }
    __name(k, "k");
    function g(a, b) {
      var c = a.sortIndex - b.sortIndex;
      return 0 !== c ? c : a.id - b.id;
    }
    __name(g, "g");
    if ("object" === typeof performance && "function" === typeof performance.now) {
      l = performance;
      exports2.unstable_now = function() {
        return l.now();
      };
    } else {
      p = Date, q = p.now();
      exports2.unstable_now = function() {
        return p.now() - q;
      };
    }
    var l;
    var p;
    var q;
    var r = [];
    var t = [];
    var u = 1;
    var v = null;
    var y = 3;
    var z = false;
    var A = false;
    var B = false;
    var D = "function" === typeof setTimeout ? setTimeout : null;
    var E = "function" === typeof clearTimeout ? clearTimeout : null;
    var F = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G(a) {
      for (var b = h(t); null !== b; ) {
        if (null === b.callback) k(t);
        else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);
        else break;
        b = h(t);
      }
    }
    __name(G, "G");
    function H(a) {
      B = false;
      G(a);
      if (!A) if (null !== h(r)) A = true, I(J);
      else {
        var b = h(t);
        null !== b && K(H, b.startTime - a);
      }
    }
    __name(H, "H");
    function J(a, b) {
      A = false;
      B && (B = false, E(L), L = -1);
      z = true;
      var c = y;
      try {
        G(b);
        for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
          var d2 = v.callback;
          if ("function" === typeof d2) {
            v.callback = null;
            y = v.priorityLevel;
            var e = d2(v.expirationTime <= b);
            b = exports2.unstable_now();
            "function" === typeof e ? v.callback = e : v === h(r) && k(r);
            G(b);
          } else k(r);
          v = h(r);
        }
        if (null !== v) var w = true;
        else {
          var m = h(t);
          null !== m && K(H, m.startTime - b);
          w = false;
        }
        return w;
      } finally {
        v = null, y = c, z = false;
      }
    }
    __name(J, "J");
    var N = false;
    var O = null;
    var L = -1;
    var P = 5;
    var Q = -1;
    function M() {
      return exports2.unstable_now() - Q < P ? false : true;
    }
    __name(M, "M");
    function R() {
      if (null !== O) {
        var a = exports2.unstable_now();
        Q = a;
        var b = true;
        try {
          b = O(true, a);
        } finally {
          b ? S() : (N = false, O = null);
        }
      } else N = false;
    }
    __name(R, "R");
    var S;
    if ("function" === typeof F) S = /* @__PURE__ */ __name(function() {
      F(R);
    }, "S");
    else if ("undefined" !== typeof MessageChannel) {
      T = new MessageChannel(), U = T.port2;
      T.port1.onmessage = R;
      S = /* @__PURE__ */ __name(function() {
        U.postMessage(null);
      }, "S");
    } else S = /* @__PURE__ */ __name(function() {
      D(R, 0);
    }, "S");
    var T;
    var U;
    function I(a) {
      O = a;
      N || (N = true, S());
    }
    __name(I, "I");
    function K(a, b) {
      L = D(function() {
        a(exports2.unstable_now());
      }, b);
    }
    __name(K, "K");
    exports2.unstable_IdlePriority = 5;
    exports2.unstable_ImmediatePriority = 1;
    exports2.unstable_LowPriority = 4;
    exports2.unstable_NormalPriority = 3;
    exports2.unstable_Profiling = null;
    exports2.unstable_UserBlockingPriority = 2;
    exports2.unstable_cancelCallback = function(a) {
      a.callback = null;
    };
    exports2.unstable_continueExecution = function() {
      A || z || (A = true, I(J));
    };
    exports2.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
    };
    exports2.unstable_getCurrentPriorityLevel = function() {
      return y;
    };
    exports2.unstable_getFirstCallbackNode = function() {
      return h(r);
    };
    exports2.unstable_next = function(a) {
      switch (y) {
        case 1:
        case 2:
        case 3:
          var b = 3;
          break;
        default:
          b = y;
      }
      var c = y;
      y = b;
      try {
        return a();
      } finally {
        y = c;
      }
    };
    exports2.unstable_pauseExecution = function() {
    };
    exports2.unstable_requestPaint = function() {
    };
    exports2.unstable_runWithPriority = function(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a = 3;
      }
      var c = y;
      y = a;
      try {
        return b();
      } finally {
        y = c;
      }
    };
    exports2.unstable_scheduleCallback = function(a, b, c) {
      var d2 = exports2.unstable_now();
      "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d2 + c : d2) : c = d2;
      switch (a) {
        case 1:
          var e = -1;
          break;
        case 2:
          e = 250;
          break;
        case 5:
          e = 1073741823;
          break;
        case 4:
          e = 1e4;
          break;
        default:
          e = 5e3;
      }
      e = c + e;
      a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
      c > d2 ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = true, K(H, c - d2))) : (a.sortIndex = e, f(r, a), A || z || (A = true, I(J)));
      return a;
    };
    exports2.unstable_shouldYield = M;
    exports2.unstable_wrapCallback = function(a) {
      var b = y;
      return function() {
        var c = y;
        y = b;
        try {
          return a.apply(this, arguments);
        } finally {
          y = c;
        }
      };
    };
  }
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/scheduler/index.js"(exports2, module2) {
    "use strict";
    init_process_shim();
    if (true) {
      module2.exports = require_scheduler_production_min();
    } else {
      module2.exports = null;
    }
  }
});

// node_modules/react-dom/cjs/react-dom.production.min.js
var require_react_dom_production_min = __commonJS({
  "node_modules/react-dom/cjs/react-dom.production.min.js"(exports2) {
    "use strict";
    init_process_shim();
    var aa = require_react();
    var ca = require_scheduler();
    function p(a) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
      return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    __name(p, "p");
    var da = /* @__PURE__ */ new Set();
    var ea = {};
    function fa(a, b) {
      ha(a, b);
      ha(a + "Capture", b);
    }
    __name(fa, "fa");
    function ha(a, b) {
      ea[a] = b;
      for (a = 0; a < b.length; a++) da.add(b[a]);
    }
    __name(ha, "ha");
    var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
    var ja = Object.prototype.hasOwnProperty;
    var ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
    var la = {};
    var ma = {};
    function oa(a) {
      if (ja.call(ma, a)) return true;
      if (ja.call(la, a)) return false;
      if (ka.test(a)) return ma[a] = true;
      la[a] = true;
      return false;
    }
    __name(oa, "oa");
    function pa(a, b, c, d2) {
      if (null !== c && 0 === c.type) return false;
      switch (typeof b) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d2) return false;
          if (null !== c) return !c.acceptsBooleans;
          a = a.toLowerCase().slice(0, 5);
          return "data-" !== a && "aria-" !== a;
        default:
          return false;
      }
    }
    __name(pa, "pa");
    function qa(a, b, c, d2) {
      if (null === b || "undefined" === typeof b || pa(a, b, c, d2)) return true;
      if (d2) return false;
      if (null !== c) switch (c.type) {
        case 3:
          return !b;
        case 4:
          return false === b;
        case 5:
          return isNaN(b);
        case 6:
          return isNaN(b) || 1 > b;
      }
      return false;
    }
    __name(qa, "qa");
    function v(a, b, c, d2, e, f, g) {
      this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
      this.attributeName = d2;
      this.attributeNamespace = e;
      this.mustUseProperty = c;
      this.propertyName = a;
      this.type = b;
      this.sanitizeURL = f;
      this.removeEmptyString = g;
    }
    __name(v, "v");
    var z = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
      z[a] = new v(a, 0, false, a, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var b = a[0];
      z[b] = new v(b, 1, false, a[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      z[a] = new v(a, 2, false, a, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
      z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a) {
      z[a] = new v(a, 3, true, a, null, false, false);
    });
    ["capture", "download"].forEach(function(a) {
      z[a] = new v(a, 4, false, a, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a) {
      z[a] = new v(a, 6, false, a, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a) {
      z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
    });
    var ra = /[\-:]([a-z])/g;
    function sa(a) {
      return a[1].toUpperCase();
    }
    __name(sa, "sa");
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
      var b = a.replace(
        ra,
        sa
      );
      z[b] = new v(b, 1, false, a, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
      var b = a.replace(ra, sa);
      z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
      var b = a.replace(ra, sa);
      z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a) {
      z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
    });
    z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a) {
      z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
    });
    function ta(a, b, c, d2) {
      var e = z.hasOwnProperty(b) ? z[b] : null;
      if (null !== e ? 0 !== e.type : d2 || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d2) && (c = null), d2 || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d2 = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d2 ? a.setAttributeNS(d2, b, c) : a.setAttribute(b, c)));
    }
    __name(ta, "ta");
    var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    var va = Symbol.for("react.element");
    var wa = Symbol.for("react.portal");
    var ya = Symbol.for("react.fragment");
    var za = Symbol.for("react.strict_mode");
    var Aa = Symbol.for("react.profiler");
    var Ba = Symbol.for("react.provider");
    var Ca = Symbol.for("react.context");
    var Da = Symbol.for("react.forward_ref");
    var Ea = Symbol.for("react.suspense");
    var Fa = Symbol.for("react.suspense_list");
    var Ga = Symbol.for("react.memo");
    var Ha = Symbol.for("react.lazy");
    Symbol.for("react.scope");
    Symbol.for("react.debug_trace_mode");
    var Ia = Symbol.for("react.offscreen");
    Symbol.for("react.legacy_hidden");
    Symbol.for("react.cache");
    Symbol.for("react.tracing_marker");
    var Ja = Symbol.iterator;
    function Ka(a) {
      if (null === a || "object" !== typeof a) return null;
      a = Ja && a[Ja] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    __name(Ka, "Ka");
    var A = Object.assign;
    var La;
    function Ma(a) {
      if (void 0 === La) try {
        throw Error();
      } catch (c) {
        var b = c.stack.trim().match(/\n( *(at )?)/);
        La = b && b[1] || "";
      }
      return "\n" + La + a;
    }
    __name(Ma, "Ma");
    var Na = false;
    function Oa(a, b) {
      if (!a || Na) return "";
      Na = true;
      var c = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b) if (b = /* @__PURE__ */ __name(function() {
          throw Error();
        }, "b"), Object.defineProperty(b.prototype, "props", { set: /* @__PURE__ */ __name(function() {
          throw Error();
        }, "set") }), "object" === typeof Reflect && Reflect.construct) {
          try {
            Reflect.construct(b, []);
          } catch (l) {
            var d2 = l;
          }
          Reflect.construct(a, [], b);
        } else {
          try {
            b.call();
          } catch (l) {
            d2 = l;
          }
          a.call(b.prototype);
        }
        else {
          try {
            throw Error();
          } catch (l) {
            d2 = l;
          }
          a();
        }
      } catch (l) {
        if (l && d2 && "string" === typeof l.stack) {
          for (var e = l.stack.split("\n"), f = d2.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; ) h--;
          for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
            if (1 !== g || 1 !== h) {
              do
                if (g--, h--, 0 > h || e[g] !== f[h]) {
                  var k = "\n" + e[g].replace(" at new ", " at ");
                  a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                  return k;
                }
              while (1 <= g && 0 <= h);
            }
            break;
          }
        }
      } finally {
        Na = false, Error.prepareStackTrace = c;
      }
      return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
    }
    __name(Oa, "Oa");
    function Pa(a) {
      switch (a.tag) {
        case 5:
          return Ma(a.type);
        case 16:
          return Ma("Lazy");
        case 13:
          return Ma("Suspense");
        case 19:
          return Ma("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a = Oa(a.type, false), a;
        case 11:
          return a = Oa(a.type.render, false), a;
        case 1:
          return a = Oa(a.type, true), a;
        default:
          return "";
      }
    }
    __name(Pa, "Pa");
    function Qa(a) {
      if (null == a) return null;
      if ("function" === typeof a) return a.displayName || a.name || null;
      if ("string" === typeof a) return a;
      switch (a) {
        case ya:
          return "Fragment";
        case wa:
          return "Portal";
        case Aa:
          return "Profiler";
        case za:
          return "StrictMode";
        case Ea:
          return "Suspense";
        case Fa:
          return "SuspenseList";
      }
      if ("object" === typeof a) switch (a.$$typeof) {
        case Ca:
          return (a.displayName || "Context") + ".Consumer";
        case Ba:
          return (a._context.displayName || "Context") + ".Provider";
        case Da:
          var b = a.render;
          a = a.displayName;
          a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
          return a;
        case Ga:
          return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
        case Ha:
          b = a._payload;
          a = a._init;
          try {
            return Qa(a(b));
          } catch (c) {
          }
      }
      return null;
    }
    __name(Qa, "Qa");
    function Ra(a) {
      var b = a.type;
      switch (a.tag) {
        case 24:
          return "Cache";
        case 9:
          return (b.displayName || "Context") + ".Consumer";
        case 10:
          return (b._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return b;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Qa(b);
        case 8:
          return b === za ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if ("function" === typeof b) return b.displayName || b.name || null;
          if ("string" === typeof b) return b;
      }
      return null;
    }
    __name(Ra, "Ra");
    function Sa(a) {
      switch (typeof a) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a;
        case "object":
          return a;
        default:
          return "";
      }
    }
    __name(Sa, "Sa");
    function Ta(a) {
      var b = a.type;
      return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
    }
    __name(Ta, "Ta");
    function Ua(a) {
      var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d2 = "" + a[b];
      if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
        var e = c.get, f = c.set;
        Object.defineProperty(a, b, { configurable: true, get: /* @__PURE__ */ __name(function() {
          return e.call(this);
        }, "get"), set: /* @__PURE__ */ __name(function(a2) {
          d2 = "" + a2;
          f.call(this, a2);
        }, "set") });
        Object.defineProperty(a, b, { enumerable: c.enumerable });
        return { getValue: /* @__PURE__ */ __name(function() {
          return d2;
        }, "getValue"), setValue: /* @__PURE__ */ __name(function(a2) {
          d2 = "" + a2;
        }, "setValue"), stopTracking: /* @__PURE__ */ __name(function() {
          a._valueTracker = null;
          delete a[b];
        }, "stopTracking") };
      }
    }
    __name(Ua, "Ua");
    function Va(a) {
      a._valueTracker || (a._valueTracker = Ua(a));
    }
    __name(Va, "Va");
    function Wa(a) {
      if (!a) return false;
      var b = a._valueTracker;
      if (!b) return true;
      var c = b.getValue();
      var d2 = "";
      a && (d2 = Ta(a) ? a.checked ? "true" : "false" : a.value);
      a = d2;
      return a !== c ? (b.setValue(a), true) : false;
    }
    __name(Wa, "Wa");
    function Xa(a) {
      a = a || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof a) return null;
      try {
        return a.activeElement || a.body;
      } catch (b) {
        return a.body;
      }
    }
    __name(Xa, "Xa");
    function Ya(a, b) {
      var c = b.checked;
      return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
    }
    __name(Ya, "Ya");
    function Za(a, b) {
      var c = null == b.defaultValue ? "" : b.defaultValue, d2 = null != b.checked ? b.checked : b.defaultChecked;
      c = Sa(null != b.value ? b.value : c);
      a._wrapperState = { initialChecked: d2, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
    }
    __name(Za, "Za");
    function ab(a, b) {
      b = b.checked;
      null != b && ta(a, "checked", b, false);
    }
    __name(ab, "ab");
    function bb(a, b) {
      ab(a, b);
      var c = Sa(b.value), d2 = b.type;
      if (null != c) if ("number" === d2) {
        if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
      } else a.value !== "" + c && (a.value = "" + c);
      else if ("submit" === d2 || "reset" === d2) {
        a.removeAttribute("value");
        return;
      }
      b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
      null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
    }
    __name(bb, "bb");
    function db(a, b, c) {
      if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
        var d2 = b.type;
        if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b.value && null !== b.value)) return;
        b = "" + a._wrapperState.initialValue;
        c || b === a.value || (a.value = b);
        a.defaultValue = b;
      }
      c = a.name;
      "" !== c && (a.name = "");
      a.defaultChecked = !!a._wrapperState.initialChecked;
      "" !== c && (a.name = c);
    }
    __name(db, "db");
    function cb(a, b, c) {
      if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
    }
    __name(cb, "cb");
    var eb = Array.isArray;
    function fb(a, b, c, d2) {
      a = a.options;
      if (b) {
        b = {};
        for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
        for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d2 && (a[c].defaultSelected = true);
      } else {
        c = "" + Sa(c);
        b = null;
        for (e = 0; e < a.length; e++) {
          if (a[e].value === c) {
            a[e].selected = true;
            d2 && (a[e].defaultSelected = true);
            return;
          }
          null !== b || a[e].disabled || (b = a[e]);
        }
        null !== b && (b.selected = true);
      }
    }
    __name(fb, "fb");
    function gb(a, b) {
      if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
      return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
    }
    __name(gb, "gb");
    function hb(a, b) {
      var c = b.value;
      if (null == c) {
        c = b.children;
        b = b.defaultValue;
        if (null != c) {
          if (null != b) throw Error(p(92));
          if (eb(c)) {
            if (1 < c.length) throw Error(p(93));
            c = c[0];
          }
          b = c;
        }
        null == b && (b = "");
        c = b;
      }
      a._wrapperState = { initialValue: Sa(c) };
    }
    __name(hb, "hb");
    function ib(a, b) {
      var c = Sa(b.value), d2 = Sa(b.defaultValue);
      null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
      null != d2 && (a.defaultValue = "" + d2);
    }
    __name(ib, "ib");
    function jb(a) {
      var b = a.textContent;
      b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
    }
    __name(jb, "jb");
    function kb(a) {
      switch (a) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    __name(kb, "kb");
    function lb(a, b) {
      return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
    }
    __name(lb, "lb");
    var mb;
    var nb = function(a) {
      return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d2, e) {
        MSApp.execUnsafeLocalFunction(function() {
          return a(b, c, d2, e);
        });
      } : a;
    }(function(a, b) {
      if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;
      else {
        mb = mb || document.createElement("div");
        mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
        for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
        for (; b.firstChild; ) a.appendChild(b.firstChild);
      }
    });
    function ob(a, b) {
      if (b) {
        var c = a.firstChild;
        if (c && c === a.lastChild && 3 === c.nodeType) {
          c.nodeValue = b;
          return;
        }
      }
      a.textContent = b;
    }
    __name(ob, "ob");
    var pb = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    };
    var qb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(pb).forEach(function(a) {
      qb.forEach(function(b) {
        b = b + a.charAt(0).toUpperCase() + a.substring(1);
        pb[b] = pb[a];
      });
    });
    function rb(a, b, c) {
      return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
    }
    __name(rb, "rb");
    function sb(a, b) {
      a = a.style;
      for (var c in b) if (b.hasOwnProperty(c)) {
        var d2 = 0 === c.indexOf("--"), e = rb(c, b[c], d2);
        "float" === c && (c = "cssFloat");
        d2 ? a.setProperty(c, e) : a[c] = e;
      }
    }
    __name(sb, "sb");
    var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    function ub(a, b) {
      if (b) {
        if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
        if (null != b.dangerouslySetInnerHTML) {
          if (null != b.children) throw Error(p(60));
          if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
        }
        if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
      }
    }
    __name(ub, "ub");
    function vb(a, b) {
      if (-1 === a.indexOf("-")) return "string" === typeof b.is;
      switch (a) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    __name(vb, "vb");
    var wb = null;
    function xb(a) {
      a = a.target || a.srcElement || window;
      a.correspondingUseElement && (a = a.correspondingUseElement);
      return 3 === a.nodeType ? a.parentNode : a;
    }
    __name(xb, "xb");
    var yb = null;
    var zb = null;
    var Ab = null;
    function Bb(a) {
      if (a = Cb(a)) {
        if ("function" !== typeof yb) throw Error(p(280));
        var b = a.stateNode;
        b && (b = Db(b), yb(a.stateNode, a.type, b));
      }
    }
    __name(Bb, "Bb");
    function Eb(a) {
      zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
    }
    __name(Eb, "Eb");
    function Fb() {
      if (zb) {
        var a = zb, b = Ab;
        Ab = zb = null;
        Bb(a);
        if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
      }
    }
    __name(Fb, "Fb");
    function Gb(a, b) {
      return a(b);
    }
    __name(Gb, "Gb");
    function Hb() {
    }
    __name(Hb, "Hb");
    var Ib = false;
    function Jb(a, b, c) {
      if (Ib) return a(b, c);
      Ib = true;
      try {
        return Gb(a, b, c);
      } finally {
        if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
      }
    }
    __name(Jb, "Jb");
    function Kb(a, b) {
      var c = a.stateNode;
      if (null === c) return null;
      var d2 = Db(c);
      if (null === d2) return null;
      c = d2[b];
      a: switch (b) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (d2 = !d2.disabled) || (a = a.type, d2 = !("button" === a || "input" === a || "select" === a || "textarea" === a));
          a = !d2;
          break a;
        default:
          a = false;
      }
      if (a) return null;
      if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
      return c;
    }
    __name(Kb, "Kb");
    var Lb = false;
    if (ia) try {
      Mb = {};
      Object.defineProperty(Mb, "passive", { get: /* @__PURE__ */ __name(function() {
        Lb = true;
      }, "get") });
      window.addEventListener("test", Mb, Mb);
      window.removeEventListener("test", Mb, Mb);
    } catch (a) {
      Lb = false;
    }
    var Mb;
    function Nb(a, b, c, d2, e, f, g, h, k) {
      var l = Array.prototype.slice.call(arguments, 3);
      try {
        b.apply(c, l);
      } catch (m) {
        this.onError(m);
      }
    }
    __name(Nb, "Nb");
    var Ob = false;
    var Pb = null;
    var Qb = false;
    var Rb = null;
    var Sb = { onError: /* @__PURE__ */ __name(function(a) {
      Ob = true;
      Pb = a;
    }, "onError") };
    function Tb(a, b, c, d2, e, f, g, h, k) {
      Ob = false;
      Pb = null;
      Nb.apply(Sb, arguments);
    }
    __name(Tb, "Tb");
    function Ub(a, b, c, d2, e, f, g, h, k) {
      Tb.apply(this, arguments);
      if (Ob) {
        if (Ob) {
          var l = Pb;
          Ob = false;
          Pb = null;
        } else throw Error(p(198));
        Qb || (Qb = true, Rb = l);
      }
    }
    __name(Ub, "Ub");
    function Vb(a) {
      var b = a, c = a;
      if (a.alternate) for (; b.return; ) b = b.return;
      else {
        a = b;
        do
          b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
        while (a);
      }
      return 3 === b.tag ? c : null;
    }
    __name(Vb, "Vb");
    function Wb(a) {
      if (13 === a.tag) {
        var b = a.memoizedState;
        null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
        if (null !== b) return b.dehydrated;
      }
      return null;
    }
    __name(Wb, "Wb");
    function Xb(a) {
      if (Vb(a) !== a) throw Error(p(188));
    }
    __name(Xb, "Xb");
    function Yb(a) {
      var b = a.alternate;
      if (!b) {
        b = Vb(a);
        if (null === b) throw Error(p(188));
        return b !== a ? null : a;
      }
      for (var c = a, d2 = b; ; ) {
        var e = c.return;
        if (null === e) break;
        var f = e.alternate;
        if (null === f) {
          d2 = e.return;
          if (null !== d2) {
            c = d2;
            continue;
          }
          break;
        }
        if (e.child === f.child) {
          for (f = e.child; f; ) {
            if (f === c) return Xb(e), a;
            if (f === d2) return Xb(e), b;
            f = f.sibling;
          }
          throw Error(p(188));
        }
        if (c.return !== d2.return) c = e, d2 = f;
        else {
          for (var g = false, h = e.child; h; ) {
            if (h === c) {
              g = true;
              c = e;
              d2 = f;
              break;
            }
            if (h === d2) {
              g = true;
              d2 = e;
              c = f;
              break;
            }
            h = h.sibling;
          }
          if (!g) {
            for (h = f.child; h; ) {
              if (h === c) {
                g = true;
                c = f;
                d2 = e;
                break;
              }
              if (h === d2) {
                g = true;
                d2 = f;
                c = e;
                break;
              }
              h = h.sibling;
            }
            if (!g) throw Error(p(189));
          }
        }
        if (c.alternate !== d2) throw Error(p(190));
      }
      if (3 !== c.tag) throw Error(p(188));
      return c.stateNode.current === c ? a : b;
    }
    __name(Yb, "Yb");
    function Zb(a) {
      a = Yb(a);
      return null !== a ? $b(a) : null;
    }
    __name(Zb, "Zb");
    function $b(a) {
      if (5 === a.tag || 6 === a.tag) return a;
      for (a = a.child; null !== a; ) {
        var b = $b(a);
        if (null !== b) return b;
        a = a.sibling;
      }
      return null;
    }
    __name($b, "$b");
    var ac = ca.unstable_scheduleCallback;
    var bc = ca.unstable_cancelCallback;
    var cc = ca.unstable_shouldYield;
    var dc = ca.unstable_requestPaint;
    var B = ca.unstable_now;
    var ec2 = ca.unstable_getCurrentPriorityLevel;
    var fc = ca.unstable_ImmediatePriority;
    var gc = ca.unstable_UserBlockingPriority;
    var hc = ca.unstable_NormalPriority;
    var ic = ca.unstable_LowPriority;
    var jc = ca.unstable_IdlePriority;
    var kc = null;
    var lc = null;
    function mc(a) {
      if (lc && "function" === typeof lc.onCommitFiberRoot) try {
        lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
      } catch (b) {
      }
    }
    __name(mc, "mc");
    var oc = Math.clz32 ? Math.clz32 : nc;
    var pc = Math.log;
    var qc = Math.LN2;
    function nc(a) {
      a >>>= 0;
      return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
    }
    __name(nc, "nc");
    var rc = 64;
    var sc = 4194304;
    function tc(a) {
      switch (a & -a) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return a & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return a & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return a;
      }
    }
    __name(tc, "tc");
    function uc(a, b) {
      var c = a.pendingLanes;
      if (0 === c) return 0;
      var d2 = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
      if (0 !== g) {
        var h = g & ~e;
        0 !== h ? d2 = tc(h) : (f &= g, 0 !== f && (d2 = tc(f)));
      } else g = c & ~e, 0 !== g ? d2 = tc(g) : 0 !== f && (d2 = tc(f));
      if (0 === d2) return 0;
      if (0 !== b && b !== d2 && 0 === (b & e) && (e = d2 & -d2, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
      0 !== (d2 & 4) && (d2 |= c & 16);
      b = a.entangledLanes;
      if (0 !== b) for (a = a.entanglements, b &= d2; 0 < b; ) c = 31 - oc(b), e = 1 << c, d2 |= a[c], b &= ~e;
      return d2;
    }
    __name(uc, "uc");
    function vc(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 4:
          return b + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return b + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    __name(vc, "vc");
    function wc(a, b) {
      for (var c = a.suspendedLanes, d2 = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
        var g = 31 - oc(f), h = 1 << g, k = e[g];
        if (-1 === k) {
          if (0 === (h & c) || 0 !== (h & d2)) e[g] = vc(h, b);
        } else k <= b && (a.expiredLanes |= h);
        f &= ~h;
      }
    }
    __name(wc, "wc");
    function xc(a) {
      a = a.pendingLanes & -1073741825;
      return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
    }
    __name(xc, "xc");
    function yc() {
      var a = rc;
      rc <<= 1;
      0 === (rc & 4194240) && (rc = 64);
      return a;
    }
    __name(yc, "yc");
    function zc(a) {
      for (var b = [], c = 0; 31 > c; c++) b.push(a);
      return b;
    }
    __name(zc, "zc");
    function Ac(a, b, c) {
      a.pendingLanes |= b;
      536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
      a = a.eventTimes;
      b = 31 - oc(b);
      a[b] = c;
    }
    __name(Ac, "Ac");
    function Bc(a, b) {
      var c = a.pendingLanes & ~b;
      a.pendingLanes = b;
      a.suspendedLanes = 0;
      a.pingedLanes = 0;
      a.expiredLanes &= b;
      a.mutableReadLanes &= b;
      a.entangledLanes &= b;
      b = a.entanglements;
      var d2 = a.eventTimes;
      for (a = a.expirationTimes; 0 < c; ) {
        var e = 31 - oc(c), f = 1 << e;
        b[e] = 0;
        d2[e] = -1;
        a[e] = -1;
        c &= ~f;
      }
    }
    __name(Bc, "Bc");
    function Cc(a, b) {
      var c = a.entangledLanes |= b;
      for (a = a.entanglements; c; ) {
        var d2 = 31 - oc(c), e = 1 << d2;
        e & b | a[d2] & b && (a[d2] |= b);
        c &= ~e;
      }
    }
    __name(Cc, "Cc");
    var C = 0;
    function Dc(a) {
      a &= -a;
      return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
    }
    __name(Dc, "Dc");
    var Ec;
    var Fc;
    var Gc;
    var Hc;
    var Ic;
    var Jc = false;
    var Kc = [];
    var Lc = null;
    var Mc = null;
    var Nc = null;
    var Oc = /* @__PURE__ */ new Map();
    var Pc = /* @__PURE__ */ new Map();
    var Qc = [];
    var Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function Sc(a, b) {
      switch (a) {
        case "focusin":
        case "focusout":
          Lc = null;
          break;
        case "dragenter":
        case "dragleave":
          Mc = null;
          break;
        case "mouseover":
        case "mouseout":
          Nc = null;
          break;
        case "pointerover":
        case "pointerout":
          Oc.delete(b.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Pc.delete(b.pointerId);
      }
    }
    __name(Sc, "Sc");
    function Tc(a, b, c, d2, e, f) {
      if (null === a || a.nativeEvent !== f) return a = { blockedOn: b, domEventName: c, eventSystemFlags: d2, nativeEvent: f, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
      a.eventSystemFlags |= d2;
      b = a.targetContainers;
      null !== e && -1 === b.indexOf(e) && b.push(e);
      return a;
    }
    __name(Tc, "Tc");
    function Uc(a, b, c, d2, e) {
      switch (b) {
        case "focusin":
          return Lc = Tc(Lc, a, b, c, d2, e), true;
        case "dragenter":
          return Mc = Tc(Mc, a, b, c, d2, e), true;
        case "mouseover":
          return Nc = Tc(Nc, a, b, c, d2, e), true;
        case "pointerover":
          var f = e.pointerId;
          Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d2, e));
          return true;
        case "gotpointercapture":
          return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d2, e)), true;
      }
      return false;
    }
    __name(Uc, "Uc");
    function Vc(a) {
      var b = Wc(a.target);
      if (null !== b) {
        var c = Vb(b);
        if (null !== c) {
          if (b = c.tag, 13 === b) {
            if (b = Wb(c), null !== b) {
              a.blockedOn = b;
              Ic(a.priority, function() {
                Gc(c);
              });
              return;
            }
          } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
            a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a.blockedOn = null;
    }
    __name(Vc, "Vc");
    function Xc(a) {
      if (null !== a.blockedOn) return false;
      for (var b = a.targetContainers; 0 < b.length; ) {
        var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
        if (null === c) {
          c = a.nativeEvent;
          var d2 = new c.constructor(c.type, c);
          wb = d2;
          c.target.dispatchEvent(d2);
          wb = null;
        } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
        b.shift();
      }
      return true;
    }
    __name(Xc, "Xc");
    function Zc(a, b, c) {
      Xc(a) && c.delete(b);
    }
    __name(Zc, "Zc");
    function $c() {
      Jc = false;
      null !== Lc && Xc(Lc) && (Lc = null);
      null !== Mc && Xc(Mc) && (Mc = null);
      null !== Nc && Xc(Nc) && (Nc = null);
      Oc.forEach(Zc);
      Pc.forEach(Zc);
    }
    __name($c, "$c");
    function ad(a, b) {
      a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
    }
    __name(ad, "ad");
    function bd(a) {
      function b(b2) {
        return ad(b2, a);
      }
      __name(b, "b");
      if (0 < Kc.length) {
        ad(Kc[0], a);
        for (var c = 1; c < Kc.length; c++) {
          var d2 = Kc[c];
          d2.blockedOn === a && (d2.blockedOn = null);
        }
      }
      null !== Lc && ad(Lc, a);
      null !== Mc && ad(Mc, a);
      null !== Nc && ad(Nc, a);
      Oc.forEach(b);
      Pc.forEach(b);
      for (c = 0; c < Qc.length; c++) d2 = Qc[c], d2.blockedOn === a && (d2.blockedOn = null);
      for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); ) Vc(c), null === c.blockedOn && Qc.shift();
    }
    __name(bd, "bd");
    var cd = ua.ReactCurrentBatchConfig;
    var dd = true;
    function ed(a, b, c, d2) {
      var e = C, f = cd.transition;
      cd.transition = null;
      try {
        C = 1, fd2(a, b, c, d2);
      } finally {
        C = e, cd.transition = f;
      }
    }
    __name(ed, "ed");
    function gd(a, b, c, d2) {
      var e = C, f = cd.transition;
      cd.transition = null;
      try {
        C = 4, fd2(a, b, c, d2);
      } finally {
        C = e, cd.transition = f;
      }
    }
    __name(gd, "gd");
    function fd2(a, b, c, d2) {
      if (dd) {
        var e = Yc(a, b, c, d2);
        if (null === e) hd(a, b, d2, id2, c), Sc(a, d2);
        else if (Uc(e, a, b, c, d2)) d2.stopPropagation();
        else if (Sc(a, d2), b & 4 && -1 < Rc.indexOf(a)) {
          for (; null !== e; ) {
            var f = Cb(e);
            null !== f && Ec(f);
            f = Yc(a, b, c, d2);
            null === f && hd(a, b, d2, id2, c);
            if (f === e) break;
            e = f;
          }
          null !== e && d2.stopPropagation();
        } else hd(a, b, d2, null, c);
      }
    }
    __name(fd2, "fd");
    var id2 = null;
    function Yc(a, b, c, d2) {
      id2 = null;
      a = xb(d2);
      a = Wc(a);
      if (null !== a) if (b = Vb(a), null === b) a = null;
      else if (c = b.tag, 13 === c) {
        a = Wb(b);
        if (null !== a) return a;
        a = null;
      } else if (3 === c) {
        if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
        a = null;
      } else b !== a && (a = null);
      id2 = a;
      return null;
    }
    __name(Yc, "Yc");
    function jd(a) {
      switch (a) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 4;
        case "message":
          switch (ec2()) {
            case fc:
              return 1;
            case gc:
              return 4;
            case hc:
            case ic:
              return 16;
            case jc:
              return 536870912;
            default:
              return 16;
          }
        default:
          return 16;
      }
    }
    __name(jd, "jd");
    var kd = null;
    var ld = null;
    var md = null;
    function nd() {
      if (md) return md;
      var a, b = ld, c = b.length, d2, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
      for (a = 0; a < c && b[a] === e[a]; a++) ;
      var g = c - a;
      for (d2 = 1; d2 <= g && b[c - d2] === e[f - d2]; d2++) ;
      return md = e.slice(a, 1 < d2 ? 1 - d2 : void 0);
    }
    __name(nd, "nd");
    function od(a) {
      var b = a.keyCode;
      "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
      10 === a && (a = 13);
      return 32 <= a || 13 === a ? a : 0;
    }
    __name(od, "od");
    function pd() {
      return true;
    }
    __name(pd, "pd");
    function qd() {
      return false;
    }
    __name(qd, "qd");
    function rd(a) {
      function b(b2, d2, e, f, g) {
        this._reactName = b2;
        this._targetInst = e;
        this.type = d2;
        this.nativeEvent = f;
        this.target = g;
        this.currentTarget = null;
        for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
        this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
        this.isPropagationStopped = qd;
        return this;
      }
      __name(b, "b");
      A(b.prototype, { preventDefault: /* @__PURE__ */ __name(function() {
        this.defaultPrevented = true;
        var a2 = this.nativeEvent;
        a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
      }, "preventDefault"), stopPropagation: /* @__PURE__ */ __name(function() {
        var a2 = this.nativeEvent;
        a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
      }, "stopPropagation"), persist: /* @__PURE__ */ __name(function() {
      }, "persist"), isPersistent: pd });
      return b;
    }
    __name(rd, "rd");
    var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: /* @__PURE__ */ __name(function(a) {
      return a.timeStamp || Date.now();
    }, "timeStamp"), defaultPrevented: 0, isTrusted: 0 };
    var td2 = rd(sd);
    var ud = A({}, sd, { view: 0, detail: 0 });
    var vd = rd(ud);
    var wd;
    var xd;
    var yd;
    var Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: /* @__PURE__ */ __name(function(a) {
      return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
    }, "relatedTarget"), movementX: /* @__PURE__ */ __name(function(a) {
      if ("movementX" in a) return a.movementX;
      a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
      return wd;
    }, "movementX"), movementY: /* @__PURE__ */ __name(function(a) {
      return "movementY" in a ? a.movementY : xd;
    }, "movementY") });
    var Bd = rd(Ad);
    var Cd = A({}, Ad, { dataTransfer: 0 });
    var Dd = rd(Cd);
    var Ed = A({}, ud, { relatedTarget: 0 });
    var Fd = rd(Ed);
    var Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 });
    var Hd = rd(Gd);
    var Id = A({}, sd, { clipboardData: /* @__PURE__ */ __name(function(a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    }, "clipboardData") });
    var Jd = rd(Id);
    var Kd = A({}, sd, { data: 0 });
    var Ld = rd(Kd);
    var Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    };
    var Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    var Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pd(a) {
      var b = this.nativeEvent;
      return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
    }
    __name(Pd, "Pd");
    function zd() {
      return Pd;
    }
    __name(zd, "zd");
    var Qd = A({}, ud, { key: /* @__PURE__ */ __name(function(a) {
      if (a.key) {
        var b = Md[a.key] || a.key;
        if ("Unidentified" !== b) return b;
      }
      return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
    }, "key"), code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: /* @__PURE__ */ __name(function(a) {
      return "keypress" === a.type ? od(a) : 0;
    }, "charCode"), keyCode: /* @__PURE__ */ __name(function(a) {
      return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    }, "keyCode"), which: /* @__PURE__ */ __name(function(a) {
      return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    }, "which") });
    var Rd = rd(Qd);
    var Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 });
    var Td = rd(Sd);
    var Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd });
    var Vd = rd(Ud);
    var Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 });
    var Xd = rd(Wd);
    var Yd = A({}, Ad, {
      deltaX: /* @__PURE__ */ __name(function(a) {
        return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
      }, "deltaX"),
      deltaY: /* @__PURE__ */ __name(function(a) {
        return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
      }, "deltaY"),
      deltaZ: 0,
      deltaMode: 0
    });
    var Zd = rd(Yd);
    var $d = [9, 13, 27, 32];
    var ae = ia && "CompositionEvent" in window;
    var be = null;
    ia && "documentMode" in document && (be = document.documentMode);
    var ce = ia && "TextEvent" in window && !be;
    var de = ia && (!ae || be && 8 < be && 11 >= be);
    var ee = String.fromCharCode(32);
    var fe = false;
    function ge(a, b) {
      switch (a) {
        case "keyup":
          return -1 !== $d.indexOf(b.keyCode);
        case "keydown":
          return 229 !== b.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    __name(ge, "ge");
    function he(a) {
      a = a.detail;
      return "object" === typeof a && "data" in a ? a.data : null;
    }
    __name(he, "he");
    var ie = false;
    function je(a, b) {
      switch (a) {
        case "compositionend":
          return he(b);
        case "keypress":
          if (32 !== b.which) return null;
          fe = true;
          return ee;
        case "textInput":
          return a = b.data, a === ee && fe ? null : a;
        default:
          return null;
      }
    }
    __name(je, "je");
    function ke(a, b) {
      if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
      switch (a) {
        case "paste":
          return null;
        case "keypress":
          if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
            if (b.char && 1 < b.char.length) return b.char;
            if (b.which) return String.fromCharCode(b.which);
          }
          return null;
        case "compositionend":
          return de && "ko" !== b.locale ? null : b.data;
        default:
          return null;
      }
    }
    __name(ke, "ke");
    var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    function me(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
    }
    __name(me, "me");
    function ne(a, b, c, d2) {
      Eb(d2);
      b = oe(b, "onChange");
      0 < b.length && (c = new td2("onChange", "change", null, c, d2), a.push({ event: c, listeners: b }));
    }
    __name(ne, "ne");
    var pe = null;
    var qe = null;
    function re(a) {
      se(a, 0);
    }
    __name(re, "re");
    function te(a) {
      var b = ue(a);
      if (Wa(b)) return a;
    }
    __name(te, "te");
    function ve(a, b) {
      if ("change" === a) return b;
    }
    __name(ve, "ve");
    var we = false;
    if (ia) {
      if (ia) {
        ye = "oninput" in document;
        if (!ye) {
          ze = document.createElement("div");
          ze.setAttribute("oninput", "return;");
          ye = "function" === typeof ze.oninput;
        }
        xe = ye;
      } else xe = false;
      we = xe && (!document.documentMode || 9 < document.documentMode);
    }
    var xe;
    var ye;
    var ze;
    function Ae() {
      pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
    }
    __name(Ae, "Ae");
    function Be(a) {
      if ("value" === a.propertyName && te(qe)) {
        var b = [];
        ne(b, qe, a, xb(a));
        Jb(re, b);
      }
    }
    __name(Be, "Be");
    function Ce(a, b, c) {
      "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
    }
    __name(Ce, "Ce");
    function De(a) {
      if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
    }
    __name(De, "De");
    function Ee(a, b) {
      if ("click" === a) return te(b);
    }
    __name(Ee, "Ee");
    function Fe(a, b) {
      if ("input" === a || "change" === a) return te(b);
    }
    __name(Fe, "Fe");
    function Ge(a, b) {
      return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
    }
    __name(Ge, "Ge");
    var He = "function" === typeof Object.is ? Object.is : Ge;
    function Ie(a, b) {
      if (He(a, b)) return true;
      if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
      var c = Object.keys(a), d2 = Object.keys(b);
      if (c.length !== d2.length) return false;
      for (d2 = 0; d2 < c.length; d2++) {
        var e = c[d2];
        if (!ja.call(b, e) || !He(a[e], b[e])) return false;
      }
      return true;
    }
    __name(Ie, "Ie");
    function Je(a) {
      for (; a && a.firstChild; ) a = a.firstChild;
      return a;
    }
    __name(Je, "Je");
    function Ke(a, b) {
      var c = Je(a);
      a = 0;
      for (var d2; c; ) {
        if (3 === c.nodeType) {
          d2 = a + c.textContent.length;
          if (a <= b && d2 >= b) return { node: c, offset: b - a };
          a = d2;
        }
        a: {
          for (; c; ) {
            if (c.nextSibling) {
              c = c.nextSibling;
              break a;
            }
            c = c.parentNode;
          }
          c = void 0;
        }
        c = Je(c);
      }
    }
    __name(Ke, "Ke");
    function Le(a, b) {
      return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
    }
    __name(Le, "Le");
    function Me() {
      for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
        try {
          var c = "string" === typeof b.contentWindow.location.href;
        } catch (d2) {
          c = false;
        }
        if (c) a = b.contentWindow;
        else break;
        b = Xa(a.document);
      }
      return b;
    }
    __name(Me, "Me");
    function Ne(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
    }
    __name(Ne, "Ne");
    function Oe(a) {
      var b = Me(), c = a.focusedElem, d2 = a.selectionRange;
      if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
        if (null !== d2 && Ne(c)) {
          if (b = d2.start, a = d2.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
          else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
            a = a.getSelection();
            var e = c.textContent.length, f = Math.min(d2.start, e);
            d2 = void 0 === d2.end ? f : Math.min(d2.end, e);
            !a.extend && f > d2 && (e = d2, d2 = f, f = e);
            e = Ke(c, f);
            var g = Ke(
              c,
              d2
            );
            e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d2 ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
          }
        }
        b = [];
        for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
        "function" === typeof c.focus && c.focus();
        for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
      }
    }
    __name(Oe, "Oe");
    var Pe = ia && "documentMode" in document && 11 >= document.documentMode;
    var Qe = null;
    var Re = null;
    var Se = null;
    var Te = false;
    function Ue(a, b, c) {
      var d2 = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
      Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b = new td2("onSelect", "select", null, b, c), a.push({ event: b, listeners: d2 }), b.target = Qe)));
    }
    __name(Ue, "Ue");
    function Ve(a, b) {
      var c = {};
      c[a.toLowerCase()] = b.toLowerCase();
      c["Webkit" + a] = "webkit" + b;
      c["Moz" + a] = "moz" + b;
      return c;
    }
    __name(Ve, "Ve");
    var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") };
    var Xe = {};
    var Ye = {};
    ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
    function Ze(a) {
      if (Xe[a]) return Xe[a];
      if (!We[a]) return a;
      var b = We[a], c;
      for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
      return a;
    }
    __name(Ze, "Ze");
    var $e = Ze("animationend");
    var af = Ze("animationiteration");
    var bf = Ze("animationstart");
    var cf = Ze("transitionend");
    var df = /* @__PURE__ */ new Map();
    var ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function ff(a, b) {
      df.set(a, b);
      fa(b, [a]);
    }
    __name(ff, "ff");
    for (gf = 0; gf < ef.length; gf++) {
      hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
      ff(jf, "on" + kf);
    }
    var hf;
    var jf;
    var kf;
    var gf;
    ff($e, "onAnimationEnd");
    ff(af, "onAnimationIteration");
    ff(bf, "onAnimationStart");
    ff("dblclick", "onDoubleClick");
    ff("focusin", "onFocus");
    ff("focusout", "onBlur");
    ff(cf, "onTransitionEnd");
    ha("onMouseEnter", ["mouseout", "mouseover"]);
    ha("onMouseLeave", ["mouseout", "mouseover"]);
    ha("onPointerEnter", ["pointerout", "pointerover"]);
    ha("onPointerLeave", ["pointerout", "pointerover"]);
    fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ");
    var mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
    function nf(a, b, c) {
      var d2 = a.type || "unknown-event";
      a.currentTarget = c;
      Ub(d2, b, void 0, a);
      a.currentTarget = null;
    }
    __name(nf, "nf");
    function se(a, b) {
      b = 0 !== (b & 4);
      for (var c = 0; c < a.length; c++) {
        var d2 = a[c], e = d2.event;
        d2 = d2.listeners;
        a: {
          var f = void 0;
          if (b) for (var g = d2.length - 1; 0 <= g; g--) {
            var h = d2[g], k = h.instance, l = h.currentTarget;
            h = h.listener;
            if (k !== f && e.isPropagationStopped()) break a;
            nf(e, h, l);
            f = k;
          }
          else for (g = 0; g < d2.length; g++) {
            h = d2[g];
            k = h.instance;
            l = h.currentTarget;
            h = h.listener;
            if (k !== f && e.isPropagationStopped()) break a;
            nf(e, h, l);
            f = k;
          }
        }
      }
      if (Qb) throw a = Rb, Qb = false, Rb = null, a;
    }
    __name(se, "se");
    function D(a, b) {
      var c = b[of2];
      void 0 === c && (c = b[of2] = /* @__PURE__ */ new Set());
      var d2 = a + "__bubble";
      c.has(d2) || (pf(b, a, 2, false), c.add(d2));
    }
    __name(D, "D");
    function qf(a, b, c) {
      var d2 = 0;
      b && (d2 |= 4);
      pf(c, a, d2, b);
    }
    __name(qf, "qf");
    var rf = "_reactListening" + Math.random().toString(36).slice(2);
    function sf(a) {
      if (!a[rf]) {
        a[rf] = true;
        da.forEach(function(b2) {
          "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
        });
        var b = 9 === a.nodeType ? a : a.ownerDocument;
        null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
      }
    }
    __name(sf, "sf");
    function pf(a, b, c, d2) {
      switch (jd(b)) {
        case 1:
          var e = ed;
          break;
        case 4:
          e = gd;
          break;
        default:
          e = fd2;
      }
      c = e.bind(null, b, c, a);
      e = void 0;
      !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
      d2 ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
    }
    __name(pf, "pf");
    function hd(a, b, c, d2, e) {
      var f = d2;
      if (0 === (b & 1) && 0 === (b & 2) && null !== d2) a: for (; ; ) {
        if (null === d2) return;
        var g = d2.tag;
        if (3 === g || 4 === g) {
          var h = d2.stateNode.containerInfo;
          if (h === e || 8 === h.nodeType && h.parentNode === e) break;
          if (4 === g) for (g = d2.return; null !== g; ) {
            var k = g.tag;
            if (3 === k || 4 === k) {
              if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
            }
            g = g.return;
          }
          for (; null !== h; ) {
            g = Wc(h);
            if (null === g) return;
            k = g.tag;
            if (5 === k || 6 === k) {
              d2 = f = g;
              continue a;
            }
            h = h.parentNode;
          }
        }
        d2 = d2.return;
      }
      Jb(function() {
        var d3 = f, e2 = xb(c), g2 = [];
        a: {
          var h2 = df.get(a);
          if (void 0 !== h2) {
            var k2 = td2, n = a;
            switch (a) {
              case "keypress":
                if (0 === od(c)) break a;
              case "keydown":
              case "keyup":
                k2 = Rd;
                break;
              case "focusin":
                n = "focus";
                k2 = Fd;
                break;
              case "focusout":
                n = "blur";
                k2 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k2 = Fd;
                break;
              case "click":
                if (2 === c.button) break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k2 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k2 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k2 = Vd;
                break;
              case $e:
              case af:
              case bf:
                k2 = Hd;
                break;
              case cf:
                k2 = Xd;
                break;
              case "scroll":
                k2 = vd;
                break;
              case "wheel":
                k2 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k2 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k2 = Td;
            }
            var t = 0 !== (b & 4), J = !t && "scroll" === a, x = t ? null !== h2 ? h2 + "Capture" : null : h2;
            t = [];
            for (var w = d3, u; null !== w; ) {
              u = w;
              var F = u.stateNode;
              5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t.push(tf(w, F, u))));
              if (J) break;
              w = w.return;
            }
            0 < t.length && (h2 = new k2(h2, n, null, c, e2), g2.push({ event: h2, listeners: t }));
          }
        }
        if (0 === (b & 7)) {
          a: {
            h2 = "mouseover" === a || "pointerover" === a;
            k2 = "mouseout" === a || "pointerout" === a;
            if (h2 && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
            if (k2 || h2) {
              h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
              if (k2) {
                if (n = c.relatedTarget || c.toElement, k2 = d3, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
              } else k2 = null, n = d3;
              if (k2 !== n) {
                t = Bd;
                F = "onMouseLeave";
                x = "onMouseEnter";
                w = "mouse";
                if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
                J = null == k2 ? h2 : ue(k2);
                u = null == n ? h2 : ue(n);
                h2 = new t(F, w + "leave", k2, c, e2);
                h2.target = J;
                h2.relatedTarget = u;
                F = null;
                Wc(e2) === d3 && (t = new t(x, w + "enter", n, c, e2), t.target = u, t.relatedTarget = J, F = t);
                J = F;
                if (k2 && n) b: {
                  t = k2;
                  x = n;
                  w = 0;
                  for (u = t; u; u = vf(u)) w++;
                  u = 0;
                  for (F = x; F; F = vf(F)) u++;
                  for (; 0 < w - u; ) t = vf(t), w--;
                  for (; 0 < u - w; ) x = vf(x), u--;
                  for (; w--; ) {
                    if (t === x || null !== x && t === x.alternate) break b;
                    t = vf(t);
                    x = vf(x);
                  }
                  t = null;
                }
                else t = null;
                null !== k2 && wf(g2, h2, k2, t, false);
                null !== n && null !== J && wf(g2, J, n, t, true);
              }
            }
          }
          a: {
            h2 = d3 ? ue(d3) : window;
            k2 = h2.nodeName && h2.nodeName.toLowerCase();
            if ("select" === k2 || "input" === k2 && "file" === h2.type) var na = ve;
            else if (me(h2)) if (we) na = Fe;
            else {
              na = De;
              var xa = Ce;
            }
            else (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee);
            if (na && (na = na(a, d3))) {
              ne(g2, na, c, e2);
              break a;
            }
            xa && xa(a, h2, d3);
            "focusout" === a && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value);
          }
          xa = d3 ? ue(d3) : window;
          switch (a) {
            case "focusin":
              if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d3, Se = null;
              break;
            case "focusout":
              Se = Re = Qe = null;
              break;
            case "mousedown":
              Te = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te = false;
              Ue(g2, c, e2);
              break;
            case "selectionchange":
              if (Pe) break;
            case "keydown":
            case "keyup":
              Ue(g2, c, e2);
          }
          var $a;
          if (ae) b: {
            switch (a) {
              case "compositionstart":
                var ba = "onCompositionStart";
                break b;
              case "compositionend":
                ba = "onCompositionEnd";
                break b;
              case "compositionupdate":
                ba = "onCompositionUpdate";
                break b;
            }
            ba = void 0;
          }
          else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
          ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
          if ($a = ce ? je(a, c) : ke(a, c)) d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d3 }), e2.data = $a);
        }
        se(g2, b);
      });
    }
    __name(hd, "hd");
    function tf(a, b, c) {
      return { instance: a, listener: b, currentTarget: c };
    }
    __name(tf, "tf");
    function oe(a, b) {
      for (var c = b + "Capture", d2 = []; null !== a; ) {
        var e = a, f = e.stateNode;
        5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d2.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d2.push(tf(a, f, e)));
        a = a.return;
      }
      return d2;
    }
    __name(oe, "oe");
    function vf(a) {
      if (null === a) return null;
      do
        a = a.return;
      while (a && 5 !== a.tag);
      return a ? a : null;
    }
    __name(vf, "vf");
    function wf(a, b, c, d2, e) {
      for (var f = b._reactName, g = []; null !== c && c !== d2; ) {
        var h = c, k = h.alternate, l = h.stateNode;
        if (null !== k && k === d2) break;
        5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h))));
        c = c.return;
      }
      0 !== g.length && a.push({ event: b, listeners: g });
    }
    __name(wf, "wf");
    var xf = /\r\n?/g;
    var yf = /\u0000|\uFFFD/g;
    function zf(a) {
      return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
    }
    __name(zf, "zf");
    function Af(a, b, c) {
      b = zf(b);
      if (zf(a) !== b && c) throw Error(p(425));
    }
    __name(Af, "Af");
    function Bf() {
    }
    __name(Bf, "Bf");
    var Cf = null;
    var Df = null;
    function Ef(a, b) {
      return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
    }
    __name(Ef, "Ef");
    var Ff = "function" === typeof setTimeout ? setTimeout : void 0;
    var Gf = "function" === typeof clearTimeout ? clearTimeout : void 0;
    var Hf = "function" === typeof Promise ? Promise : void 0;
    var Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
      return Hf.resolve(null).then(a).catch(If);
    } : Ff;
    function If(a) {
      setTimeout(function() {
        throw a;
      });
    }
    __name(If, "If");
    function Kf(a, b) {
      var c = b, d2 = 0;
      do {
        var e = c.nextSibling;
        a.removeChild(c);
        if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
          if (0 === d2) {
            a.removeChild(e);
            bd(b);
            return;
          }
          d2--;
        } else "$" !== c && "$?" !== c && "$!" !== c || d2++;
        c = e;
      } while (c);
      bd(b);
    }
    __name(Kf, "Kf");
    function Lf(a) {
      for (; null != a; a = a.nextSibling) {
        var b = a.nodeType;
        if (1 === b || 3 === b) break;
        if (8 === b) {
          b = a.data;
          if ("$" === b || "$!" === b || "$?" === b) break;
          if ("/$" === b) return null;
        }
      }
      return a;
    }
    __name(Lf, "Lf");
    function Mf(a) {
      a = a.previousSibling;
      for (var b = 0; a; ) {
        if (8 === a.nodeType) {
          var c = a.data;
          if ("$" === c || "$!" === c || "$?" === c) {
            if (0 === b) return a;
            b--;
          } else "/$" === c && b++;
        }
        a = a.previousSibling;
      }
      return null;
    }
    __name(Mf, "Mf");
    var Nf = Math.random().toString(36).slice(2);
    var Of = "__reactFiber$" + Nf;
    var Pf = "__reactProps$" + Nf;
    var uf = "__reactContainer$" + Nf;
    var of2 = "__reactEvents$" + Nf;
    var Qf = "__reactListeners$" + Nf;
    var Rf = "__reactHandles$" + Nf;
    function Wc(a) {
      var b = a[Of];
      if (b) return b;
      for (var c = a.parentNode; c; ) {
        if (b = c[uf] || c[Of]) {
          c = b.alternate;
          if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
            if (c = a[Of]) return c;
            a = Mf(a);
          }
          return b;
        }
        a = c;
        c = a.parentNode;
      }
      return null;
    }
    __name(Wc, "Wc");
    function Cb(a) {
      a = a[Of] || a[uf];
      return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
    }
    __name(Cb, "Cb");
    function ue(a) {
      if (5 === a.tag || 6 === a.tag) return a.stateNode;
      throw Error(p(33));
    }
    __name(ue, "ue");
    function Db(a) {
      return a[Pf] || null;
    }
    __name(Db, "Db");
    var Sf = [];
    var Tf = -1;
    function Uf(a) {
      return { current: a };
    }
    __name(Uf, "Uf");
    function E(a) {
      0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
    }
    __name(E, "E");
    function G(a, b) {
      Tf++;
      Sf[Tf] = a.current;
      a.current = b;
    }
    __name(G, "G");
    var Vf = {};
    var H = Uf(Vf);
    var Wf = Uf(false);
    var Xf = Vf;
    function Yf(a, b) {
      var c = a.type.contextTypes;
      if (!c) return Vf;
      var d2 = a.stateNode;
      if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b) return d2.__reactInternalMemoizedMaskedChildContext;
      var e = {}, f;
      for (f in c) e[f] = b[f];
      d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
      return e;
    }
    __name(Yf, "Yf");
    function Zf(a) {
      a = a.childContextTypes;
      return null !== a && void 0 !== a;
    }
    __name(Zf, "Zf");
    function $f() {
      E(Wf);
      E(H);
    }
    __name($f, "$f");
    function ag(a, b, c) {
      if (H.current !== Vf) throw Error(p(168));
      G(H, b);
      G(Wf, c);
    }
    __name(ag, "ag");
    function bg(a, b, c) {
      var d2 = a.stateNode;
      b = b.childContextTypes;
      if ("function" !== typeof d2.getChildContext) return c;
      d2 = d2.getChildContext();
      for (var e in d2) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
      return A({}, c, d2);
    }
    __name(bg, "bg");
    function cg(a) {
      a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
      Xf = H.current;
      G(H, a);
      G(Wf, Wf.current);
      return true;
    }
    __name(cg, "cg");
    function dg(a, b, c) {
      var d2 = a.stateNode;
      if (!d2) throw Error(p(169));
      c ? (a = bg(a, b, Xf), d2.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
      G(Wf, c);
    }
    __name(dg, "dg");
    var eg = null;
    var fg = false;
    var gg = false;
    function hg(a) {
      null === eg ? eg = [a] : eg.push(a);
    }
    __name(hg, "hg");
    function ig(a) {
      fg = true;
      hg(a);
    }
    __name(ig, "ig");
    function jg() {
      if (!gg && null !== eg) {
        gg = true;
        var a = 0, b = C;
        try {
          var c = eg;
          for (C = 1; a < c.length; a++) {
            var d2 = c[a];
            do
              d2 = d2(true);
            while (null !== d2);
          }
          eg = null;
          fg = false;
        } catch (e) {
          throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
        } finally {
          C = b, gg = false;
        }
      }
      return null;
    }
    __name(jg, "jg");
    var kg = [];
    var lg = 0;
    var mg = null;
    var ng = 0;
    var og = [];
    var pg = 0;
    var qg = null;
    var rg = 1;
    var sg = "";
    function tg(a, b) {
      kg[lg++] = ng;
      kg[lg++] = mg;
      mg = a;
      ng = b;
    }
    __name(tg, "tg");
    function ug(a, b, c) {
      og[pg++] = rg;
      og[pg++] = sg;
      og[pg++] = qg;
      qg = a;
      var d2 = rg;
      a = sg;
      var e = 32 - oc(d2) - 1;
      d2 &= ~(1 << e);
      c += 1;
      var f = 32 - oc(b) + e;
      if (30 < f) {
        var g = e - e % 5;
        f = (d2 & (1 << g) - 1).toString(32);
        d2 >>= g;
        e -= g;
        rg = 1 << 32 - oc(b) + e | c << e | d2;
        sg = f + a;
      } else rg = 1 << f | c << e | d2, sg = a;
    }
    __name(ug, "ug");
    function vg(a) {
      null !== a.return && (tg(a, 1), ug(a, 1, 0));
    }
    __name(vg, "vg");
    function wg(a) {
      for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
      for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
    }
    __name(wg, "wg");
    var xg = null;
    var yg = null;
    var I = false;
    var zg = null;
    function Ag(a, b) {
      var c = Bg(5, null, null, 0);
      c.elementType = "DELETED";
      c.stateNode = b;
      c.return = a;
      b = a.deletions;
      null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
    }
    __name(Ag, "Ag");
    function Cg(a, b) {
      switch (a.tag) {
        case 5:
          var c = a.type;
          b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
          return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
        case 6:
          return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
        case 13:
          return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
        default:
          return false;
      }
    }
    __name(Cg, "Cg");
    function Dg(a) {
      return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
    }
    __name(Dg, "Dg");
    function Eg(a) {
      if (I) {
        var b = yg;
        if (b) {
          var c = b;
          if (!Cg(a, b)) {
            if (Dg(a)) throw Error(p(418));
            b = Lf(c.nextSibling);
            var d2 = xg;
            b && Cg(a, b) ? Ag(d2, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
          }
        } else {
          if (Dg(a)) throw Error(p(418));
          a.flags = a.flags & -4097 | 2;
          I = false;
          xg = a;
        }
      }
    }
    __name(Eg, "Eg");
    function Fg(a) {
      for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
      xg = a;
    }
    __name(Fg, "Fg");
    function Gg(a) {
      if (a !== xg) return false;
      if (!I) return Fg(a), I = true, false;
      var b;
      (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
      if (b && (b = yg)) {
        if (Dg(a)) throw Hg(), Error(p(418));
        for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
      }
      Fg(a);
      if (13 === a.tag) {
        a = a.memoizedState;
        a = null !== a ? a.dehydrated : null;
        if (!a) throw Error(p(317));
        a: {
          a = a.nextSibling;
          for (b = 0; a; ) {
            if (8 === a.nodeType) {
              var c = a.data;
              if ("/$" === c) {
                if (0 === b) {
                  yg = Lf(a.nextSibling);
                  break a;
                }
                b--;
              } else "$" !== c && "$!" !== c && "$?" !== c || b++;
            }
            a = a.nextSibling;
          }
          yg = null;
        }
      } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
      return true;
    }
    __name(Gg, "Gg");
    function Hg() {
      for (var a = yg; a; ) a = Lf(a.nextSibling);
    }
    __name(Hg, "Hg");
    function Ig() {
      yg = xg = null;
      I = false;
    }
    __name(Ig, "Ig");
    function Jg(a) {
      null === zg ? zg = [a] : zg.push(a);
    }
    __name(Jg, "Jg");
    var Kg = ua.ReactCurrentBatchConfig;
    function Lg(a, b) {
      if (a && a.defaultProps) {
        b = A({}, b);
        a = a.defaultProps;
        for (var c in a) void 0 === b[c] && (b[c] = a[c]);
        return b;
      }
      return b;
    }
    __name(Lg, "Lg");
    var Mg = Uf(null);
    var Ng = null;
    var Og = null;
    var Pg = null;
    function Qg() {
      Pg = Og = Ng = null;
    }
    __name(Qg, "Qg");
    function Rg(a) {
      var b = Mg.current;
      E(Mg);
      a._currentValue = b;
    }
    __name(Rg, "Rg");
    function Sg(a, b, c) {
      for (; null !== a; ) {
        var d2 = a.alternate;
        (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d2 && (d2.childLanes |= b)) : null !== d2 && (d2.childLanes & b) !== b && (d2.childLanes |= b);
        if (a === c) break;
        a = a.return;
      }
    }
    __name(Sg, "Sg");
    function Tg(a, b) {
      Ng = a;
      Pg = Og = null;
      a = a.dependencies;
      null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (Ug = true), a.firstContext = null);
    }
    __name(Tg, "Tg");
    function Vg(a) {
      var b = a._currentValue;
      if (Pg !== a) if (a = { context: a, memoizedValue: b, next: null }, null === Og) {
        if (null === Ng) throw Error(p(308));
        Og = a;
        Ng.dependencies = { lanes: 0, firstContext: a };
      } else Og = Og.next = a;
      return b;
    }
    __name(Vg, "Vg");
    var Wg = null;
    function Xg(a) {
      null === Wg ? Wg = [a] : Wg.push(a);
    }
    __name(Xg, "Xg");
    function Yg(a, b, c, d2) {
      var e = b.interleaved;
      null === e ? (c.next = c, Xg(b)) : (c.next = e.next, e.next = c);
      b.interleaved = c;
      return Zg(a, d2);
    }
    __name(Yg, "Yg");
    function Zg(a, b) {
      a.lanes |= b;
      var c = a.alternate;
      null !== c && (c.lanes |= b);
      c = a;
      for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
      return 3 === c.tag ? c.stateNode : null;
    }
    __name(Zg, "Zg");
    var $g = false;
    function ah(a) {
      a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    __name(ah, "ah");
    function bh(a, b) {
      a = a.updateQueue;
      b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
    }
    __name(bh, "bh");
    function ch(a, b) {
      return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
    }
    __name(ch, "ch");
    function dh(a, b, c) {
      var d2 = a.updateQueue;
      if (null === d2) return null;
      d2 = d2.shared;
      if (0 !== (K & 2)) {
        var e = d2.pending;
        null === e ? b.next = b : (b.next = e.next, e.next = b);
        d2.pending = b;
        return Zg(a, c);
      }
      e = d2.interleaved;
      null === e ? (b.next = b, Xg(d2)) : (b.next = e.next, e.next = b);
      d2.interleaved = b;
      return Zg(a, c);
    }
    __name(dh, "dh");
    function eh(a, b, c) {
      b = b.updateQueue;
      if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
        var d2 = b.lanes;
        d2 &= a.pendingLanes;
        c |= d2;
        b.lanes = c;
        Cc(a, c);
      }
    }
    __name(eh, "eh");
    function fh(a, b) {
      var c = a.updateQueue, d2 = a.alternate;
      if (null !== d2 && (d2 = d2.updateQueue, c === d2)) {
        var e = null, f = null;
        c = c.firstBaseUpdate;
        if (null !== c) {
          do {
            var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
            null === f ? e = f = g : f = f.next = g;
            c = c.next;
          } while (null !== c);
          null === f ? e = f = b : f = f.next = b;
        } else e = f = b;
        c = { baseState: d2.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d2.shared, effects: d2.effects };
        a.updateQueue = c;
        return;
      }
      a = c.lastBaseUpdate;
      null === a ? c.firstBaseUpdate = b : a.next = b;
      c.lastBaseUpdate = b;
    }
    __name(fh, "fh");
    function gh(a, b, c, d2) {
      var e = a.updateQueue;
      $g = false;
      var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
      if (null !== h) {
        e.shared.pending = null;
        var k = h, l = k.next;
        k.next = null;
        null === g ? f = l : g.next = l;
        g = k;
        var m = a.alternate;
        null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
      }
      if (null !== f) {
        var q = e.baseState;
        g = 0;
        m = l = k = null;
        h = f;
        do {
          var r = h.lane, y = h.eventTime;
          if ((d2 & r) === r) {
            null !== m && (m = m.next = {
              eventTime: y,
              lane: 0,
              tag: h.tag,
              payload: h.payload,
              callback: h.callback,
              next: null
            });
            a: {
              var n = a, t = h;
              r = b;
              y = c;
              switch (t.tag) {
                case 1:
                  n = t.payload;
                  if ("function" === typeof n) {
                    q = n.call(y, q, r);
                    break a;
                  }
                  q = n;
                  break a;
                case 3:
                  n.flags = n.flags & -65537 | 128;
                case 0:
                  n = t.payload;
                  r = "function" === typeof n ? n.call(y, q, r) : n;
                  if (null === r || void 0 === r) break a;
                  q = A({}, q, r);
                  break a;
                case 2:
                  $g = true;
              }
            }
            null !== h.callback && 0 !== h.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [h] : r.push(h));
          } else y = { eventTime: y, lane: r, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;
          h = h.next;
          if (null === h) if (h = e.shared.pending, null === h) break;
          else r = h, h = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
        } while (1);
        null === m && (k = q);
        e.baseState = k;
        e.firstBaseUpdate = l;
        e.lastBaseUpdate = m;
        b = e.shared.interleaved;
        if (null !== b) {
          e = b;
          do
            g |= e.lane, e = e.next;
          while (e !== b);
        } else null === f && (e.shared.lanes = 0);
        hh |= g;
        a.lanes = g;
        a.memoizedState = q;
      }
    }
    __name(gh, "gh");
    function ih(a, b, c) {
      a = b.effects;
      b.effects = null;
      if (null !== a) for (b = 0; b < a.length; b++) {
        var d2 = a[b], e = d2.callback;
        if (null !== e) {
          d2.callback = null;
          d2 = c;
          if ("function" !== typeof e) throw Error(p(191, e));
          e.call(d2);
        }
      }
    }
    __name(ih, "ih");
    var jh = new aa.Component().refs;
    function kh(a, b, c, d2) {
      b = a.memoizedState;
      c = c(d2, b);
      c = null === c || void 0 === c ? b : A({}, b, c);
      a.memoizedState = c;
      0 === a.lanes && (a.updateQueue.baseState = c);
    }
    __name(kh, "kh");
    var nh = { isMounted: /* @__PURE__ */ __name(function(a) {
      return (a = a._reactInternals) ? Vb(a) === a : false;
    }, "isMounted"), enqueueSetState: /* @__PURE__ */ __name(function(a, b, c) {
      a = a._reactInternals;
      var d2 = L(), e = lh(a), f = ch(d2, e);
      f.payload = b;
      void 0 !== c && null !== c && (f.callback = c);
      b = dh(a, f, e);
      null !== b && (mh(b, a, e, d2), eh(b, a, e));
    }, "enqueueSetState"), enqueueReplaceState: /* @__PURE__ */ __name(function(a, b, c) {
      a = a._reactInternals;
      var d2 = L(), e = lh(a), f = ch(d2, e);
      f.tag = 1;
      f.payload = b;
      void 0 !== c && null !== c && (f.callback = c);
      b = dh(a, f, e);
      null !== b && (mh(b, a, e, d2), eh(b, a, e));
    }, "enqueueReplaceState"), enqueueForceUpdate: /* @__PURE__ */ __name(function(a, b) {
      a = a._reactInternals;
      var c = L(), d2 = lh(a), e = ch(c, d2);
      e.tag = 2;
      void 0 !== b && null !== b && (e.callback = b);
      b = dh(a, e, d2);
      null !== b && (mh(b, a, d2, c), eh(b, a, d2));
    }, "enqueueForceUpdate") };
    function oh(a, b, c, d2, e, f, g) {
      a = a.stateNode;
      return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d2, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d2) || !Ie(e, f) : true;
    }
    __name(oh, "oh");
    function ph(a, b, c) {
      var d2 = false, e = Vf;
      var f = b.contextType;
      "object" === typeof f && null !== f ? f = Vg(f) : (e = Zf(b) ? Xf : H.current, d2 = b.contextTypes, f = (d2 = null !== d2 && void 0 !== d2) ? Yf(a, e) : Vf);
      b = new b(c, f);
      a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
      b.updater = nh;
      a.stateNode = b;
      b._reactInternals = a;
      d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
      return b;
    }
    __name(ph, "ph");
    function qh(a, b, c, d2) {
      a = b.state;
      "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d2);
      "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d2);
      b.state !== a && nh.enqueueReplaceState(b, b.state, null);
    }
    __name(qh, "qh");
    function rh(a, b, c, d2) {
      var e = a.stateNode;
      e.props = c;
      e.state = a.memoizedState;
      e.refs = jh;
      ah(a);
      var f = b.contextType;
      "object" === typeof f && null !== f ? e.context = Vg(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
      e.state = a.memoizedState;
      f = b.getDerivedStateFromProps;
      "function" === typeof f && (kh(a, b, f, c), e.state = a.memoizedState);
      "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && nh.enqueueReplaceState(e, e.state, null), gh(a, c, e, d2), e.state = a.memoizedState);
      "function" === typeof e.componentDidMount && (a.flags |= 4194308);
    }
    __name(rh, "rh");
    function sh(a, b, c) {
      a = c.ref;
      if (null !== a && "function" !== typeof a && "object" !== typeof a) {
        if (c._owner) {
          c = c._owner;
          if (c) {
            if (1 !== c.tag) throw Error(p(309));
            var d2 = c.stateNode;
          }
          if (!d2) throw Error(p(147, a));
          var e = d2, f = "" + a;
          if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
          b = /* @__PURE__ */ __name(function(a2) {
            var b2 = e.refs;
            b2 === jh && (b2 = e.refs = {});
            null === a2 ? delete b2[f] : b2[f] = a2;
          }, "b");
          b._stringRef = f;
          return b;
        }
        if ("string" !== typeof a) throw Error(p(284));
        if (!c._owner) throw Error(p(290, a));
      }
      return a;
    }
    __name(sh, "sh");
    function th(a, b) {
      a = Object.prototype.toString.call(b);
      throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
    }
    __name(th, "th");
    function uh(a) {
      var b = a._init;
      return b(a._payload);
    }
    __name(uh, "uh");
    function vh(a) {
      function b(b2, c2) {
        if (a) {
          var d3 = b2.deletions;
          null === d3 ? (b2.deletions = [c2], b2.flags |= 16) : d3.push(c2);
        }
      }
      __name(b, "b");
      function c(c2, d3) {
        if (!a) return null;
        for (; null !== d3; ) b(c2, d3), d3 = d3.sibling;
        return null;
      }
      __name(c, "c");
      function d2(a2, b2) {
        for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
        return a2;
      }
      __name(d2, "d");
      function e(a2, b2) {
        a2 = wh(a2, b2);
        a2.index = 0;
        a2.sibling = null;
        return a2;
      }
      __name(e, "e");
      function f(b2, c2, d3) {
        b2.index = d3;
        if (!a) return b2.flags |= 1048576, c2;
        d3 = b2.alternate;
        if (null !== d3) return d3 = d3.index, d3 < c2 ? (b2.flags |= 2, c2) : d3;
        b2.flags |= 2;
        return c2;
      }
      __name(f, "f");
      function g(b2) {
        a && null === b2.alternate && (b2.flags |= 2);
        return b2;
      }
      __name(g, "g");
      function h(a2, b2, c2, d3) {
        if (null === b2 || 6 !== b2.tag) return b2 = xh(c2, a2.mode, d3), b2.return = a2, b2;
        b2 = e(b2, c2);
        b2.return = a2;
        return b2;
      }
      __name(h, "h");
      function k(a2, b2, c2, d3) {
        var f2 = c2.type;
        if (f2 === ya) return m(a2, b2, c2.props.children, d3, c2.key);
        if (null !== b2 && (b2.elementType === f2 || "object" === typeof f2 && null !== f2 && f2.$$typeof === Ha && uh(f2) === b2.type)) return d3 = e(b2, c2.props), d3.ref = sh(a2, b2, c2), d3.return = a2, d3;
        d3 = yh(c2.type, c2.key, c2.props, null, a2.mode, d3);
        d3.ref = sh(a2, b2, c2);
        d3.return = a2;
        return d3;
      }
      __name(k, "k");
      function l(a2, b2, c2, d3) {
        if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = zh(c2, a2.mode, d3), b2.return = a2, b2;
        b2 = e(b2, c2.children || []);
        b2.return = a2;
        return b2;
      }
      __name(l, "l");
      function m(a2, b2, c2, d3, f2) {
        if (null === b2 || 7 !== b2.tag) return b2 = Ah(c2, a2.mode, d3, f2), b2.return = a2, b2;
        b2 = e(b2, c2);
        b2.return = a2;
        return b2;
      }
      __name(m, "m");
      function q(a2, b2, c2) {
        if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = xh("" + b2, a2.mode, c2), b2.return = a2, b2;
        if ("object" === typeof b2 && null !== b2) {
          switch (b2.$$typeof) {
            case va:
              return c2 = yh(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = sh(a2, null, b2), c2.return = a2, c2;
            case wa:
              return b2 = zh(b2, a2.mode, c2), b2.return = a2, b2;
            case Ha:
              var d3 = b2._init;
              return q(a2, d3(b2._payload), c2);
          }
          if (eb(b2) || Ka(b2)) return b2 = Ah(b2, a2.mode, c2, null), b2.return = a2, b2;
          th(a2, b2);
        }
        return null;
      }
      __name(q, "q");
      function r(a2, b2, c2, d3) {
        var e2 = null !== b2 ? b2.key : null;
        if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2) return null !== e2 ? null : h(a2, b2, "" + c2, d3);
        if ("object" === typeof c2 && null !== c2) {
          switch (c2.$$typeof) {
            case va:
              return c2.key === e2 ? k(a2, b2, c2, d3) : null;
            case wa:
              return c2.key === e2 ? l(a2, b2, c2, d3) : null;
            case Ha:
              return e2 = c2._init, r(
                a2,
                b2,
                e2(c2._payload),
                d3
              );
          }
          if (eb(c2) || Ka(c2)) return null !== e2 ? null : m(a2, b2, c2, d3, null);
          th(a2, c2);
        }
        return null;
      }
      __name(r, "r");
      function y(a2, b2, c2, d3, e2) {
        if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3) return a2 = a2.get(c2) || null, h(b2, a2, "" + d3, e2);
        if ("object" === typeof d3 && null !== d3) {
          switch (d3.$$typeof) {
            case va:
              return a2 = a2.get(null === d3.key ? c2 : d3.key) || null, k(b2, a2, d3, e2);
            case wa:
              return a2 = a2.get(null === d3.key ? c2 : d3.key) || null, l(b2, a2, d3, e2);
            case Ha:
              var f2 = d3._init;
              return y(a2, b2, c2, f2(d3._payload), e2);
          }
          if (eb(d3) || Ka(d3)) return a2 = a2.get(c2) || null, m(b2, a2, d3, e2, null);
          th(b2, d3);
        }
        return null;
      }
      __name(y, "y");
      function n(e2, g2, h2, k2) {
        for (var l2 = null, m2 = null, u = g2, w = g2 = 0, x = null; null !== u && w < h2.length; w++) {
          u.index > w ? (x = u, u = null) : x = u.sibling;
          var n2 = r(e2, u, h2[w], k2);
          if (null === n2) {
            null === u && (u = x);
            break;
          }
          a && u && null === n2.alternate && b(e2, u);
          g2 = f(n2, g2, w);
          null === m2 ? l2 = n2 : m2.sibling = n2;
          m2 = n2;
          u = x;
        }
        if (w === h2.length) return c(e2, u), I && tg(e2, w), l2;
        if (null === u) {
          for (; w < h2.length; w++) u = q(e2, h2[w], k2), null !== u && (g2 = f(u, g2, w), null === m2 ? l2 = u : m2.sibling = u, m2 = u);
          I && tg(e2, w);
          return l2;
        }
        for (u = d2(e2, u); w < h2.length; w++) x = y(u, e2, w, h2[w], k2), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g2 = f(x, g2, w), null === m2 ? l2 = x : m2.sibling = x, m2 = x);
        a && u.forEach(function(a2) {
          return b(e2, a2);
        });
        I && tg(e2, w);
        return l2;
      }
      __name(n, "n");
      function t(e2, g2, h2, k2) {
        var l2 = Ka(h2);
        if ("function" !== typeof l2) throw Error(p(150));
        h2 = l2.call(h2);
        if (null == h2) throw Error(p(151));
        for (var u = l2 = null, m2 = g2, w = g2 = 0, x = null, n2 = h2.next(); null !== m2 && !n2.done; w++, n2 = h2.next()) {
          m2.index > w ? (x = m2, m2 = null) : x = m2.sibling;
          var t2 = r(e2, m2, n2.value, k2);
          if (null === t2) {
            null === m2 && (m2 = x);
            break;
          }
          a && m2 && null === t2.alternate && b(e2, m2);
          g2 = f(t2, g2, w);
          null === u ? l2 = t2 : u.sibling = t2;
          u = t2;
          m2 = x;
        }
        if (n2.done) return c(
          e2,
          m2
        ), I && tg(e2, w), l2;
        if (null === m2) {
          for (; !n2.done; w++, n2 = h2.next()) n2 = q(e2, n2.value, k2), null !== n2 && (g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
          I && tg(e2, w);
          return l2;
        }
        for (m2 = d2(e2, m2); !n2.done; w++, n2 = h2.next()) n2 = y(m2, e2, w, n2.value, k2), null !== n2 && (a && null !== n2.alternate && m2.delete(null === n2.key ? w : n2.key), g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
        a && m2.forEach(function(a2) {
          return b(e2, a2);
        });
        I && tg(e2, w);
        return l2;
      }
      __name(t, "t");
      function J(a2, d3, f2, h2) {
        "object" === typeof f2 && null !== f2 && f2.type === ya && null === f2.key && (f2 = f2.props.children);
        if ("object" === typeof f2 && null !== f2) {
          switch (f2.$$typeof) {
            case va:
              a: {
                for (var k2 = f2.key, l2 = d3; null !== l2; ) {
                  if (l2.key === k2) {
                    k2 = f2.type;
                    if (k2 === ya) {
                      if (7 === l2.tag) {
                        c(a2, l2.sibling);
                        d3 = e(l2, f2.props.children);
                        d3.return = a2;
                        a2 = d3;
                        break a;
                      }
                    } else if (l2.elementType === k2 || "object" === typeof k2 && null !== k2 && k2.$$typeof === Ha && uh(k2) === l2.type) {
                      c(a2, l2.sibling);
                      d3 = e(l2, f2.props);
                      d3.ref = sh(a2, l2, f2);
                      d3.return = a2;
                      a2 = d3;
                      break a;
                    }
                    c(a2, l2);
                    break;
                  } else b(a2, l2);
                  l2 = l2.sibling;
                }
                f2.type === ya ? (d3 = Ah(f2.props.children, a2.mode, h2, f2.key), d3.return = a2, a2 = d3) : (h2 = yh(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = sh(a2, d3, f2), h2.return = a2, a2 = h2);
              }
              return g(a2);
            case wa:
              a: {
                for (l2 = f2.key; null !== d3; ) {
                  if (d3.key === l2) if (4 === d3.tag && d3.stateNode.containerInfo === f2.containerInfo && d3.stateNode.implementation === f2.implementation) {
                    c(a2, d3.sibling);
                    d3 = e(d3, f2.children || []);
                    d3.return = a2;
                    a2 = d3;
                    break a;
                  } else {
                    c(a2, d3);
                    break;
                  }
                  else b(a2, d3);
                  d3 = d3.sibling;
                }
                d3 = zh(f2, a2.mode, h2);
                d3.return = a2;
                a2 = d3;
              }
              return g(a2);
            case Ha:
              return l2 = f2._init, J(a2, d3, l2(f2._payload), h2);
          }
          if (eb(f2)) return n(a2, d3, f2, h2);
          if (Ka(f2)) return t(a2, d3, f2, h2);
          th(a2, f2);
        }
        return "string" === typeof f2 && "" !== f2 || "number" === typeof f2 ? (f2 = "" + f2, null !== d3 && 6 === d3.tag ? (c(a2, d3.sibling), d3 = e(d3, f2), d3.return = a2, a2 = d3) : (c(a2, d3), d3 = xh(f2, a2.mode, h2), d3.return = a2, a2 = d3), g(a2)) : c(a2, d3);
      }
      __name(J, "J");
      return J;
    }
    __name(vh, "vh");
    var Bh = vh(true);
    var Ch = vh(false);
    var Dh = {};
    var Eh = Uf(Dh);
    var Fh = Uf(Dh);
    var Gh = Uf(Dh);
    function Hh(a) {
      if (a === Dh) throw Error(p(174));
      return a;
    }
    __name(Hh, "Hh");
    function Ih(a, b) {
      G(Gh, b);
      G(Fh, a);
      G(Eh, Dh);
      a = b.nodeType;
      switch (a) {
        case 9:
        case 11:
          b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
          break;
        default:
          a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
      }
      E(Eh);
      G(Eh, b);
    }
    __name(Ih, "Ih");
    function Jh() {
      E(Eh);
      E(Fh);
      E(Gh);
    }
    __name(Jh, "Jh");
    function Kh(a) {
      Hh(Gh.current);
      var b = Hh(Eh.current);
      var c = lb(b, a.type);
      b !== c && (G(Fh, a), G(Eh, c));
    }
    __name(Kh, "Kh");
    function Lh(a) {
      Fh.current === a && (E(Eh), E(Fh));
    }
    __name(Lh, "Lh");
    var M = Uf(0);
    function Mh(a) {
      for (var b = a; null !== b; ) {
        if (13 === b.tag) {
          var c = b.memoizedState;
          if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
        } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
          if (0 !== (b.flags & 128)) return b;
        } else if (null !== b.child) {
          b.child.return = b;
          b = b.child;
          continue;
        }
        if (b === a) break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a) return null;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
      return null;
    }
    __name(Mh, "Mh");
    var Nh = [];
    function Oh() {
      for (var a = 0; a < Nh.length; a++) Nh[a]._workInProgressVersionPrimary = null;
      Nh.length = 0;
    }
    __name(Oh, "Oh");
    var Ph = ua.ReactCurrentDispatcher;
    var Qh = ua.ReactCurrentBatchConfig;
    var Rh = 0;
    var N = null;
    var O = null;
    var P = null;
    var Sh = false;
    var Th = false;
    var Uh = 0;
    var Vh = 0;
    function Q() {
      throw Error(p(321));
    }
    __name(Q, "Q");
    function Wh(a, b) {
      if (null === b) return false;
      for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
      return true;
    }
    __name(Wh, "Wh");
    function Xh(a, b, c, d2, e, f) {
      Rh = f;
      N = b;
      b.memoizedState = null;
      b.updateQueue = null;
      b.lanes = 0;
      Ph.current = null === a || null === a.memoizedState ? Yh : Zh;
      a = c(d2, e);
      if (Th) {
        f = 0;
        do {
          Th = false;
          Uh = 0;
          if (25 <= f) throw Error(p(301));
          f += 1;
          P = O = null;
          b.updateQueue = null;
          Ph.current = $h;
          a = c(d2, e);
        } while (Th);
      }
      Ph.current = ai;
      b = null !== O && null !== O.next;
      Rh = 0;
      P = O = N = null;
      Sh = false;
      if (b) throw Error(p(300));
      return a;
    }
    __name(Xh, "Xh");
    function bi() {
      var a = 0 !== Uh;
      Uh = 0;
      return a;
    }
    __name(bi, "bi");
    function ci() {
      var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      null === P ? N.memoizedState = P = a : P = P.next = a;
      return P;
    }
    __name(ci, "ci");
    function di() {
      if (null === O) {
        var a = N.alternate;
        a = null !== a ? a.memoizedState : null;
      } else a = O.next;
      var b = null === P ? N.memoizedState : P.next;
      if (null !== b) P = b, O = a;
      else {
        if (null === a) throw Error(p(310));
        O = a;
        a = { memoizedState: O.memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null };
        null === P ? N.memoizedState = P = a : P = P.next = a;
      }
      return P;
    }
    __name(di, "di");
    function ei(a, b) {
      return "function" === typeof b ? b(a) : b;
    }
    __name(ei, "ei");
    function fi(a) {
      var b = di(), c = b.queue;
      if (null === c) throw Error(p(311));
      c.lastRenderedReducer = a;
      var d2 = O, e = d2.baseQueue, f = c.pending;
      if (null !== f) {
        if (null !== e) {
          var g = e.next;
          e.next = f.next;
          f.next = g;
        }
        d2.baseQueue = e = f;
        c.pending = null;
      }
      if (null !== e) {
        f = e.next;
        d2 = d2.baseState;
        var h = g = null, k = null, l = f;
        do {
          var m = l.lane;
          if ((Rh & m) === m) null !== k && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d2 = l.hasEagerState ? l.eagerState : a(d2, l.action);
          else {
            var q = {
              lane: m,
              action: l.action,
              hasEagerState: l.hasEagerState,
              eagerState: l.eagerState,
              next: null
            };
            null === k ? (h = k = q, g = d2) : k = k.next = q;
            N.lanes |= m;
            hh |= m;
          }
          l = l.next;
        } while (null !== l && l !== f);
        null === k ? g = d2 : k.next = h;
        He(d2, b.memoizedState) || (Ug = true);
        b.memoizedState = d2;
        b.baseState = g;
        b.baseQueue = k;
        c.lastRenderedState = d2;
      }
      a = c.interleaved;
      if (null !== a) {
        e = a;
        do
          f = e.lane, N.lanes |= f, hh |= f, e = e.next;
        while (e !== a);
      } else null === e && (c.lanes = 0);
      return [b.memoizedState, c.dispatch];
    }
    __name(fi, "fi");
    function gi(a) {
      var b = di(), c = b.queue;
      if (null === c) throw Error(p(311));
      c.lastRenderedReducer = a;
      var d2 = c.dispatch, e = c.pending, f = b.memoizedState;
      if (null !== e) {
        c.pending = null;
        var g = e = e.next;
        do
          f = a(f, g.action), g = g.next;
        while (g !== e);
        He(f, b.memoizedState) || (Ug = true);
        b.memoizedState = f;
        null === b.baseQueue && (b.baseState = f);
        c.lastRenderedState = f;
      }
      return [f, d2];
    }
    __name(gi, "gi");
    function hi() {
    }
    __name(hi, "hi");
    function ii(a, b) {
      var c = N, d2 = di(), e = b(), f = !He(d2.memoizedState, e);
      f && (d2.memoizedState = e, Ug = true);
      d2 = d2.queue;
      ji(ki.bind(null, c, d2, a), [a]);
      if (d2.getSnapshot !== b || f || null !== P && P.memoizedState.tag & 1) {
        c.flags |= 2048;
        li(9, mi.bind(null, c, d2, e, b), void 0, null);
        if (null === R) throw Error(p(349));
        0 !== (Rh & 30) || ni(c, b, e);
      }
      return e;
    }
    __name(ii, "ii");
    function ni(a, b, c) {
      a.flags |= 16384;
      a = { getSnapshot: b, value: c };
      b = N.updateQueue;
      null === b ? (b = { lastEffect: null, stores: null }, N.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
    }
    __name(ni, "ni");
    function mi(a, b, c, d2) {
      b.value = c;
      b.getSnapshot = d2;
      oi(b) && pi(a);
    }
    __name(mi, "mi");
    function ki(a, b, c) {
      return c(function() {
        oi(b) && pi(a);
      });
    }
    __name(ki, "ki");
    function oi(a) {
      var b = a.getSnapshot;
      a = a.value;
      try {
        var c = b();
        return !He(a, c);
      } catch (d2) {
        return true;
      }
    }
    __name(oi, "oi");
    function pi(a) {
      var b = Zg(a, 1);
      null !== b && mh(b, a, 1, -1);
    }
    __name(pi, "pi");
    function qi(a) {
      var b = ci();
      "function" === typeof a && (a = a());
      b.memoizedState = b.baseState = a;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a };
      b.queue = a;
      a = a.dispatch = ri.bind(null, N, a);
      return [b.memoizedState, a];
    }
    __name(qi, "qi");
    function li(a, b, c, d2) {
      a = { tag: a, create: b, destroy: c, deps: d2, next: null };
      b = N.updateQueue;
      null === b ? (b = { lastEffect: null, stores: null }, N.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d2 = c.next, c.next = a, a.next = d2, b.lastEffect = a));
      return a;
    }
    __name(li, "li");
    function si() {
      return di().memoizedState;
    }
    __name(si, "si");
    function ti(a, b, c, d2) {
      var e = ci();
      N.flags |= a;
      e.memoizedState = li(1 | b, c, void 0, void 0 === d2 ? null : d2);
    }
    __name(ti, "ti");
    function ui(a, b, c, d2) {
      var e = di();
      d2 = void 0 === d2 ? null : d2;
      var f = void 0;
      if (null !== O) {
        var g = O.memoizedState;
        f = g.destroy;
        if (null !== d2 && Wh(d2, g.deps)) {
          e.memoizedState = li(b, c, f, d2);
          return;
        }
      }
      N.flags |= a;
      e.memoizedState = li(1 | b, c, f, d2);
    }
    __name(ui, "ui");
    function vi(a, b) {
      return ti(8390656, 8, a, b);
    }
    __name(vi, "vi");
    function ji(a, b) {
      return ui(2048, 8, a, b);
    }
    __name(ji, "ji");
    function wi(a, b) {
      return ui(4, 2, a, b);
    }
    __name(wi, "wi");
    function xi(a, b) {
      return ui(4, 4, a, b);
    }
    __name(xi, "xi");
    function yi(a, b) {
      if ("function" === typeof b) return a = a(), b(a), function() {
        b(null);
      };
      if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
        b.current = null;
      };
    }
    __name(yi, "yi");
    function zi(a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return ui(4, 4, yi.bind(null, b, a), c);
    }
    __name(zi, "zi");
    function Ai() {
    }
    __name(Ai, "Ai");
    function Bi(a, b) {
      var c = di();
      b = void 0 === b ? null : b;
      var d2 = c.memoizedState;
      if (null !== d2 && null !== b && Wh(b, d2[1])) return d2[0];
      c.memoizedState = [a, b];
      return a;
    }
    __name(Bi, "Bi");
    function Ci(a, b) {
      var c = di();
      b = void 0 === b ? null : b;
      var d2 = c.memoizedState;
      if (null !== d2 && null !== b && Wh(b, d2[1])) return d2[0];
      a = a();
      c.memoizedState = [a, b];
      return a;
    }
    __name(Ci, "Ci");
    function Di(a, b, c) {
      if (0 === (Rh & 21)) return a.baseState && (a.baseState = false, Ug = true), a.memoizedState = c;
      He(c, b) || (c = yc(), N.lanes |= c, hh |= c, a.baseState = true);
      return b;
    }
    __name(Di, "Di");
    function Ei(a, b) {
      var c = C;
      C = 0 !== c && 4 > c ? c : 4;
      a(true);
      var d2 = Qh.transition;
      Qh.transition = {};
      try {
        a(false), b();
      } finally {
        C = c, Qh.transition = d2;
      }
    }
    __name(Ei, "Ei");
    function Fi() {
      return di().memoizedState;
    }
    __name(Fi, "Fi");
    function Gi(a, b, c) {
      var d2 = lh(a);
      c = { lane: d2, action: c, hasEagerState: false, eagerState: null, next: null };
      if (Hi(a)) Ii(b, c);
      else if (c = Yg(a, b, c, d2), null !== c) {
        var e = L();
        mh(c, a, d2, e);
        Ji(c, b, d2);
      }
    }
    __name(Gi, "Gi");
    function ri(a, b, c) {
      var d2 = lh(a), e = { lane: d2, action: c, hasEagerState: false, eagerState: null, next: null };
      if (Hi(a)) Ii(b, e);
      else {
        var f = a.alternate;
        if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
          var g = b.lastRenderedState, h = f(g, c);
          e.hasEagerState = true;
          e.eagerState = h;
          if (He(h, g)) {
            var k = b.interleaved;
            null === k ? (e.next = e, Xg(b)) : (e.next = k.next, k.next = e);
            b.interleaved = e;
            return;
          }
        } catch (l) {
        } finally {
        }
        c = Yg(a, b, e, d2);
        null !== c && (e = L(), mh(c, a, d2, e), Ji(c, b, d2));
      }
    }
    __name(ri, "ri");
    function Hi(a) {
      var b = a.alternate;
      return a === N || null !== b && b === N;
    }
    __name(Hi, "Hi");
    function Ii(a, b) {
      Th = Sh = true;
      var c = a.pending;
      null === c ? b.next = b : (b.next = c.next, c.next = b);
      a.pending = b;
    }
    __name(Ii, "Ii");
    function Ji(a, b, c) {
      if (0 !== (c & 4194240)) {
        var d2 = b.lanes;
        d2 &= a.pendingLanes;
        c |= d2;
        b.lanes = c;
        Cc(a, c);
      }
    }
    __name(Ji, "Ji");
    var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false };
    var Yh = { readContext: Vg, useCallback: /* @__PURE__ */ __name(function(a, b) {
      ci().memoizedState = [a, void 0 === b ? null : b];
      return a;
    }, "useCallback"), useContext: Vg, useEffect: vi, useImperativeHandle: /* @__PURE__ */ __name(function(a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return ti(
        4194308,
        4,
        yi.bind(null, b, a),
        c
      );
    }, "useImperativeHandle"), useLayoutEffect: /* @__PURE__ */ __name(function(a, b) {
      return ti(4194308, 4, a, b);
    }, "useLayoutEffect"), useInsertionEffect: /* @__PURE__ */ __name(function(a, b) {
      return ti(4, 2, a, b);
    }, "useInsertionEffect"), useMemo: /* @__PURE__ */ __name(function(a, b) {
      var c = ci();
      b = void 0 === b ? null : b;
      a = a();
      c.memoizedState = [a, b];
      return a;
    }, "useMemo"), useReducer: /* @__PURE__ */ __name(function(a, b, c) {
      var d2 = ci();
      b = void 0 !== c ? c(b) : b;
      d2.memoizedState = d2.baseState = b;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
      d2.queue = a;
      a = a.dispatch = Gi.bind(null, N, a);
      return [d2.memoizedState, a];
    }, "useReducer"), useRef: /* @__PURE__ */ __name(function(a) {
      var b = ci();
      a = { current: a };
      return b.memoizedState = a;
    }, "useRef"), useState: qi, useDebugValue: Ai, useDeferredValue: /* @__PURE__ */ __name(function(a) {
      return ci().memoizedState = a;
    }, "useDeferredValue"), useTransition: /* @__PURE__ */ __name(function() {
      var a = qi(false), b = a[0];
      a = Ei.bind(null, a[1]);
      ci().memoizedState = a;
      return [b, a];
    }, "useTransition"), useMutableSource: /* @__PURE__ */ __name(function() {
    }, "useMutableSource"), useSyncExternalStore: /* @__PURE__ */ __name(function(a, b, c) {
      var d2 = N, e = ci();
      if (I) {
        if (void 0 === c) throw Error(p(407));
        c = c();
      } else {
        c = b();
        if (null === R) throw Error(p(349));
        0 !== (Rh & 30) || ni(d2, b, c);
      }
      e.memoizedState = c;
      var f = { value: c, getSnapshot: b };
      e.queue = f;
      vi(ki.bind(
        null,
        d2,
        f,
        a
      ), [a]);
      d2.flags |= 2048;
      li(9, mi.bind(null, d2, f, c, b), void 0, null);
      return c;
    }, "useSyncExternalStore"), useId: /* @__PURE__ */ __name(function() {
      var a = ci(), b = R.identifierPrefix;
      if (I) {
        var c = sg;
        var d2 = rg;
        c = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c;
        b = ":" + b + "R" + c;
        c = Uh++;
        0 < c && (b += "H" + c.toString(32));
        b += ":";
      } else c = Vh++, b = ":" + b + "r" + c.toString(32) + ":";
      return a.memoizedState = b;
    }, "useId"), unstable_isNewReconciler: false };
    var Zh = {
      readContext: Vg,
      useCallback: Bi,
      useContext: Vg,
      useEffect: ji,
      useImperativeHandle: zi,
      useInsertionEffect: wi,
      useLayoutEffect: xi,
      useMemo: Ci,
      useReducer: fi,
      useRef: si,
      useState: /* @__PURE__ */ __name(function() {
        return fi(ei);
      }, "useState"),
      useDebugValue: Ai,
      useDeferredValue: /* @__PURE__ */ __name(function(a) {
        var b = di();
        return Di(b, O.memoizedState, a);
      }, "useDeferredValue"),
      useTransition: /* @__PURE__ */ __name(function() {
        var a = fi(ei)[0], b = di().memoizedState;
        return [a, b];
      }, "useTransition"),
      useMutableSource: hi,
      useSyncExternalStore: ii,
      useId: Fi,
      unstable_isNewReconciler: false
    };
    var $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: /* @__PURE__ */ __name(function() {
      return gi(ei);
    }, "useState"), useDebugValue: Ai, useDeferredValue: /* @__PURE__ */ __name(function(a) {
      var b = di();
      return null === O ? b.memoizedState = a : Di(b, O.memoizedState, a);
    }, "useDeferredValue"), useTransition: /* @__PURE__ */ __name(function() {
      var a = gi(ei)[0], b = di().memoizedState;
      return [a, b];
    }, "useTransition"), useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
    function Ki(a, b) {
      try {
        var c = "", d2 = b;
        do
          c += Pa(d2), d2 = d2.return;
        while (d2);
        var e = c;
      } catch (f) {
        e = "\nError generating stack: " + f.message + "\n" + f.stack;
      }
      return { value: a, source: b, stack: e, digest: null };
    }
    __name(Ki, "Ki");
    function Li(a, b, c) {
      return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
    }
    __name(Li, "Li");
    function Mi(a, b) {
      try {
        console.error(b.value);
      } catch (c) {
        setTimeout(function() {
          throw c;
        });
      }
    }
    __name(Mi, "Mi");
    var Ni = "function" === typeof WeakMap ? WeakMap : Map;
    function Oi(a, b, c) {
      c = ch(-1, c);
      c.tag = 3;
      c.payload = { element: null };
      var d2 = b.value;
      c.callback = function() {
        Pi || (Pi = true, Qi = d2);
        Mi(a, b);
      };
      return c;
    }
    __name(Oi, "Oi");
    function Ri(a, b, c) {
      c = ch(-1, c);
      c.tag = 3;
      var d2 = a.type.getDerivedStateFromError;
      if ("function" === typeof d2) {
        var e = b.value;
        c.payload = function() {
          return d2(e);
        };
        c.callback = function() {
          Mi(a, b);
        };
      }
      var f = a.stateNode;
      null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
        Mi(a, b);
        "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
        var c2 = b.stack;
        this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
      });
      return c;
    }
    __name(Ri, "Ri");
    function Ti(a, b, c) {
      var d2 = a.pingCache;
      if (null === d2) {
        d2 = a.pingCache = new Ni();
        var e = /* @__PURE__ */ new Set();
        d2.set(b, e);
      } else e = d2.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d2.set(b, e));
      e.has(c) || (e.add(c), a = Ui.bind(null, a, b, c), b.then(a, a));
    }
    __name(Ti, "Ti");
    function Vi(a) {
      do {
        var b;
        if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
        if (b) return a;
        a = a.return;
      } while (null !== a);
      return null;
    }
    __name(Vi, "Vi");
    function Wi(a, b, c, d2, e) {
      if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = ch(-1, 1), b.tag = 2, dh(c, b, 1))), c.lanes |= 1), a;
      a.flags |= 65536;
      a.lanes = e;
      return a;
    }
    __name(Wi, "Wi");
    var Xi = ua.ReactCurrentOwner;
    var Ug = false;
    function Yi(a, b, c, d2) {
      b.child = null === a ? Ch(b, null, c, d2) : Bh(b, a.child, c, d2);
    }
    __name(Yi, "Yi");
    function Zi(a, b, c, d2, e) {
      c = c.render;
      var f = b.ref;
      Tg(b, e);
      d2 = Xh(a, b, c, d2, f, e);
      c = bi();
      if (null !== a && !Ug) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, $i(a, b, e);
      I && c && vg(b);
      b.flags |= 1;
      Yi(a, b, d2, e);
      return b.child;
    }
    __name(Zi, "Zi");
    function aj(a, b, c, d2, e) {
      if (null === a) {
        var f = c.type;
        if ("function" === typeof f && !bj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, cj(a, b, f, d2, e);
        a = yh(c.type, null, d2, b, b.mode, e);
        a.ref = b.ref;
        a.return = b;
        return b.child = a;
      }
      f = a.child;
      if (0 === (a.lanes & e)) {
        var g = f.memoizedProps;
        c = c.compare;
        c = null !== c ? c : Ie;
        if (c(g, d2) && a.ref === b.ref) return $i(a, b, e);
      }
      b.flags |= 1;
      a = wh(f, d2);
      a.ref = b.ref;
      a.return = b;
      return b.child = a;
    }
    __name(aj, "aj");
    function cj(a, b, c, d2, e) {
      if (null !== a) {
        var f = a.memoizedProps;
        if (Ie(f, d2) && a.ref === b.ref) if (Ug = false, b.pendingProps = d2 = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (Ug = true);
        else return b.lanes = a.lanes, $i(a, b, e);
      }
      return dj(a, b, c, d2, e);
    }
    __name(cj, "cj");
    function ej(a, b, c) {
      var d2 = b.pendingProps, e = d2.children, f = null !== a ? a.memoizedState : null;
      if ("hidden" === d2.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(fj, gj), gj |= c;
      else {
        if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(fj, gj), gj |= a, null;
        b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
        d2 = null !== f ? f.baseLanes : c;
        G(fj, gj);
        gj |= d2;
      }
      else null !== f ? (d2 = f.baseLanes | c, b.memoizedState = null) : d2 = c, G(fj, gj), gj |= d2;
      Yi(a, b, e, c);
      return b.child;
    }
    __name(ej, "ej");
    function hj(a, b) {
      var c = b.ref;
      if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
    }
    __name(hj, "hj");
    function dj(a, b, c, d2, e) {
      var f = Zf(c) ? Xf : H.current;
      f = Yf(b, f);
      Tg(b, e);
      c = Xh(a, b, c, d2, f, e);
      d2 = bi();
      if (null !== a && !Ug) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, $i(a, b, e);
      I && d2 && vg(b);
      b.flags |= 1;
      Yi(a, b, c, e);
      return b.child;
    }
    __name(dj, "dj");
    function ij(a, b, c, d2, e) {
      if (Zf(c)) {
        var f = true;
        cg(b);
      } else f = false;
      Tg(b, e);
      if (null === b.stateNode) jj(a, b), ph(b, c, d2), rh(b, c, d2, e), d2 = true;
      else if (null === a) {
        var g = b.stateNode, h = b.memoizedProps;
        g.props = h;
        var k = g.context, l = c.contextType;
        "object" === typeof l && null !== l ? l = Vg(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
        var m = c.getDerivedStateFromProps, q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
        q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d2 || k !== l) && qh(b, g, d2, l);
        $g = false;
        var r = b.memoizedState;
        g.state = r;
        gh(b, d2, g, e);
        k = b.memoizedState;
        h !== d2 || r !== k || Wf.current || $g ? ("function" === typeof m && (kh(b, c, m, d2), k = b.memoizedState), (h = $g || oh(b, c, h, d2, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d2, b.memoizedState = k), g.props = d2, g.state = k, g.context = l, d2 = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d2 = false);
      } else {
        g = b.stateNode;
        bh(a, b);
        h = b.memoizedProps;
        l = b.type === b.elementType ? h : Lg(b.type, h);
        g.props = l;
        q = b.pendingProps;
        r = g.context;
        k = c.contextType;
        "object" === typeof k && null !== k ? k = Vg(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
        var y = c.getDerivedStateFromProps;
        (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r !== k) && qh(b, g, d2, k);
        $g = false;
        r = b.memoizedState;
        g.state = r;
        gh(b, d2, g, e);
        var n = b.memoizedState;
        h !== q || r !== n || Wf.current || $g ? ("function" === typeof y && (kh(b, c, y, d2), n = b.memoizedState), (l = $g || oh(b, c, l, d2, r, n, k) || false) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d2, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d2, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d2, b.memoizedState = n), g.props = d2, g.state = n, g.context = k, d2 = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d2 = false);
      }
      return kj(a, b, c, d2, f, e);
    }
    __name(ij, "ij");
    function kj(a, b, c, d2, e, f) {
      hj(a, b);
      var g = 0 !== (b.flags & 128);
      if (!d2 && !g) return e && dg(b, c, false), $i(a, b, f);
      d2 = b.stateNode;
      Xi.current = b;
      var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d2.render();
      b.flags |= 1;
      null !== a && g ? (b.child = Bh(b, a.child, null, f), b.child = Bh(b, null, h, f)) : Yi(a, b, h, f);
      b.memoizedState = d2.state;
      e && dg(b, c, true);
      return b.child;
    }
    __name(kj, "kj");
    function lj(a) {
      var b = a.stateNode;
      b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
      Ih(a, b.containerInfo);
    }
    __name(lj, "lj");
    function mj(a, b, c, d2, e) {
      Ig();
      Jg(e);
      b.flags |= 256;
      Yi(a, b, c, d2);
      return b.child;
    }
    __name(mj, "mj");
    var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
    function oj(a) {
      return { baseLanes: a, cachePool: null, transitions: null };
    }
    __name(oj, "oj");
    function pj(a, b, c) {
      var d2 = b.pendingProps, e = M.current, f = false, g = 0 !== (b.flags & 128), h;
      (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
      if (h) f = true, b.flags &= -129;
      else if (null === a || null !== a.memoizedState) e |= 1;
      G(M, e & 1);
      if (null === a) {
        Eg(b);
        a = b.memoizedState;
        if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
        g = d2.children;
        a = d2.fallback;
        return f ? (d2 = b.mode, f = b.child, g = { mode: "hidden", children: g }, 0 === (d2 & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = qj(g, d2, 0, null), a = Ah(a, d2, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = oj(c), b.memoizedState = nj, a) : rj(b, g);
      }
      e = a.memoizedState;
      if (null !== e && (h = e.dehydrated, null !== h)) return sj(a, b, g, d2, h, e, c);
      if (f) {
        f = d2.fallback;
        g = b.mode;
        e = a.child;
        h = e.sibling;
        var k = { mode: "hidden", children: d2.children };
        0 === (g & 1) && b.child !== e ? (d2 = b.child, d2.childLanes = 0, d2.pendingProps = k, b.deletions = null) : (d2 = wh(e, k), d2.subtreeFlags = e.subtreeFlags & 14680064);
        null !== h ? f = wh(h, f) : (f = Ah(f, g, c, null), f.flags |= 2);
        f.return = b;
        d2.return = b;
        d2.sibling = f;
        b.child = d2;
        d2 = f;
        f = b.child;
        g = a.child.memoizedState;
        g = null === g ? oj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
        f.memoizedState = g;
        f.childLanes = a.childLanes & ~c;
        b.memoizedState = nj;
        return d2;
      }
      f = a.child;
      a = f.sibling;
      d2 = wh(f, { mode: "visible", children: d2.children });
      0 === (b.mode & 1) && (d2.lanes = c);
      d2.return = b;
      d2.sibling = null;
      null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
      b.child = d2;
      b.memoizedState = null;
      return d2;
    }
    __name(pj, "pj");
    function rj(a, b) {
      b = qj({ mode: "visible", children: b }, a.mode, 0, null);
      b.return = a;
      return a.child = b;
    }
    __name(rj, "rj");
    function tj(a, b, c, d2) {
      null !== d2 && Jg(d2);
      Bh(b, a.child, null, c);
      a = rj(b, b.pendingProps.children);
      a.flags |= 2;
      b.memoizedState = null;
      return a;
    }
    __name(tj, "tj");
    function sj(a, b, c, d2, e, f, g) {
      if (c) {
        if (b.flags & 256) return b.flags &= -257, d2 = Li(Error(p(422))), tj(a, b, g, d2);
        if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
        f = d2.fallback;
        e = b.mode;
        d2 = qj({ mode: "visible", children: d2.children }, e, 0, null);
        f = Ah(f, e, g, null);
        f.flags |= 2;
        d2.return = b;
        f.return = b;
        d2.sibling = f;
        b.child = d2;
        0 !== (b.mode & 1) && Bh(b, a.child, null, g);
        b.child.memoizedState = oj(g);
        b.memoizedState = nj;
        return f;
      }
      if (0 === (b.mode & 1)) return tj(a, b, g, null);
      if ("$!" === e.data) {
        d2 = e.nextSibling && e.nextSibling.dataset;
        if (d2) var h = d2.dgst;
        d2 = h;
        f = Error(p(419));
        d2 = Li(f, d2, void 0);
        return tj(a, b, g, d2);
      }
      h = 0 !== (g & a.childLanes);
      if (Ug || h) {
        d2 = R;
        if (null !== d2) {
          switch (g & -g) {
            case 4:
              e = 2;
              break;
            case 16:
              e = 8;
              break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              e = 32;
              break;
            case 536870912:
              e = 268435456;
              break;
            default:
              e = 0;
          }
          e = 0 !== (e & (d2.suspendedLanes | g)) ? 0 : e;
          0 !== e && e !== f.retryLane && (f.retryLane = e, Zg(a, e), mh(d2, a, e, -1));
        }
        uj();
        d2 = Li(Error(p(421)));
        return tj(a, b, g, d2);
      }
      if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = vj.bind(null, a), e._reactRetry = b, null;
      a = f.treeContext;
      yg = Lf(e.nextSibling);
      xg = b;
      I = true;
      zg = null;
      null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
      b = rj(b, d2.children);
      b.flags |= 4096;
      return b;
    }
    __name(sj, "sj");
    function wj(a, b, c) {
      a.lanes |= b;
      var d2 = a.alternate;
      null !== d2 && (d2.lanes |= b);
      Sg(a.return, b, c);
    }
    __name(wj, "wj");
    function xj(a, b, c, d2, e) {
      var f = a.memoizedState;
      null === f ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d2, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d2, f.tail = c, f.tailMode = e);
    }
    __name(xj, "xj");
    function yj(a, b, c) {
      var d2 = b.pendingProps, e = d2.revealOrder, f = d2.tail;
      Yi(a, b, d2.children, c);
      d2 = M.current;
      if (0 !== (d2 & 2)) d2 = d2 & 1 | 2, b.flags |= 128;
      else {
        if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
          if (13 === a.tag) null !== a.memoizedState && wj(a, c, b);
          else if (19 === a.tag) wj(a, c, b);
          else if (null !== a.child) {
            a.child.return = a;
            a = a.child;
            continue;
          }
          if (a === b) break a;
          for (; null === a.sibling; ) {
            if (null === a.return || a.return === b) break a;
            a = a.return;
          }
          a.sibling.return = a.return;
          a = a.sibling;
        }
        d2 &= 1;
      }
      G(M, d2);
      if (0 === (b.mode & 1)) b.memoizedState = null;
      else switch (e) {
        case "forwards":
          c = b.child;
          for (e = null; null !== c; ) a = c.alternate, null !== a && null === Mh(a) && (e = c), c = c.sibling;
          c = e;
          null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
          xj(b, false, e, c, f);
          break;
        case "backwards":
          c = null;
          e = b.child;
          for (b.child = null; null !== e; ) {
            a = e.alternate;
            if (null !== a && null === Mh(a)) {
              b.child = e;
              break;
            }
            a = e.sibling;
            e.sibling = c;
            c = e;
            e = a;
          }
          xj(b, true, c, null, f);
          break;
        case "together":
          xj(b, false, null, null, void 0);
          break;
        default:
          b.memoizedState = null;
      }
      return b.child;
    }
    __name(yj, "yj");
    function jj(a, b) {
      0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
    }
    __name(jj, "jj");
    function $i(a, b, c) {
      null !== a && (b.dependencies = a.dependencies);
      hh |= b.lanes;
      if (0 === (c & b.childLanes)) return null;
      if (null !== a && b.child !== a.child) throw Error(p(153));
      if (null !== b.child) {
        a = b.child;
        c = wh(a, a.pendingProps);
        b.child = c;
        for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = wh(a, a.pendingProps), c.return = b;
        c.sibling = null;
      }
      return b.child;
    }
    __name($i, "$i");
    function zj(a, b, c) {
      switch (b.tag) {
        case 3:
          lj(b);
          Ig();
          break;
        case 5:
          Kh(b);
          break;
        case 1:
          Zf(b.type) && cg(b);
          break;
        case 4:
          Ih(b, b.stateNode.containerInfo);
          break;
        case 10:
          var d2 = b.type._context, e = b.memoizedProps.value;
          G(Mg, d2._currentValue);
          d2._currentValue = e;
          break;
        case 13:
          d2 = b.memoizedState;
          if (null !== d2) {
            if (null !== d2.dehydrated) return G(M, M.current & 1), b.flags |= 128, null;
            if (0 !== (c & b.child.childLanes)) return pj(a, b, c);
            G(M, M.current & 1);
            a = $i(a, b, c);
            return null !== a ? a.sibling : null;
          }
          G(M, M.current & 1);
          break;
        case 19:
          d2 = 0 !== (c & b.childLanes);
          if (0 !== (a.flags & 128)) {
            if (d2) return yj(a, b, c);
            b.flags |= 128;
          }
          e = b.memoizedState;
          null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
          G(M, M.current);
          if (d2) break;
          else return null;
        case 22:
        case 23:
          return b.lanes = 0, ej(a, b, c);
      }
      return $i(a, b, c);
    }
    __name(zj, "zj");
    var Aj;
    var Bj;
    var Cj;
    var Dj;
    Aj = /* @__PURE__ */ __name(function(a, b) {
      for (var c = b.child; null !== c; ) {
        if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
        else if (4 !== c.tag && null !== c.child) {
          c.child.return = c;
          c = c.child;
          continue;
        }
        if (c === b) break;
        for (; null === c.sibling; ) {
          if (null === c.return || c.return === b) return;
          c = c.return;
        }
        c.sibling.return = c.return;
        c = c.sibling;
      }
    }, "Aj");
    Bj = /* @__PURE__ */ __name(function() {
    }, "Bj");
    Cj = /* @__PURE__ */ __name(function(a, b, c, d2) {
      var e = a.memoizedProps;
      if (e !== d2) {
        a = b.stateNode;
        Hh(Eh.current);
        var f = null;
        switch (c) {
          case "input":
            e = Ya(a, e);
            d2 = Ya(a, d2);
            f = [];
            break;
          case "select":
            e = A({}, e, { value: void 0 });
            d2 = A({}, d2, { value: void 0 });
            f = [];
            break;
          case "textarea":
            e = gb(a, e);
            d2 = gb(a, d2);
            f = [];
            break;
          default:
            "function" !== typeof e.onClick && "function" === typeof d2.onClick && (a.onclick = Bf);
        }
        ub(c, d2);
        var g;
        c = null;
        for (l in e) if (!d2.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
          var h = e[l];
          for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
        } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
        for (l in d2) {
          var k = d2[l];
          h = null != e ? e[l] : void 0;
          if (d2.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) if (h) {
            for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
            for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
          } else c || (f || (f = []), f.push(
            l,
            c
          )), c = k;
          else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
        }
        c && (f = f || []).push("style", c);
        var l = f;
        if (b.updateQueue = l) b.flags |= 4;
      }
    }, "Cj");
    Dj = /* @__PURE__ */ __name(function(a, b, c, d2) {
      c !== d2 && (b.flags |= 4);
    }, "Dj");
    function Ej(a, b) {
      if (!I) switch (a.tailMode) {
        case "hidden":
          b = a.tail;
          for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
          null === c ? a.tail = null : c.sibling = null;
          break;
        case "collapsed":
          c = a.tail;
          for (var d2 = null; null !== c; ) null !== c.alternate && (d2 = c), c = c.sibling;
          null === d2 ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d2.sibling = null;
      }
    }
    __name(Ej, "Ej");
    function S(a) {
      var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d2 = 0;
      if (b) for (var e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d2 |= e.subtreeFlags & 14680064, d2 |= e.flags & 14680064, e.return = a, e = e.sibling;
      else for (e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d2 |= e.subtreeFlags, d2 |= e.flags, e.return = a, e = e.sibling;
      a.subtreeFlags |= d2;
      a.childLanes = c;
      return b;
    }
    __name(S, "S");
    function Fj(a, b, c) {
      var d2 = b.pendingProps;
      wg(b);
      switch (b.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return S(b), null;
        case 1:
          return Zf(b.type) && $f(), S(b), null;
        case 3:
          d2 = b.stateNode;
          Jh();
          E(Wf);
          E(H);
          Oh();
          d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
          if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Gj(zg), zg = null));
          Bj(a, b);
          S(b);
          return null;
        case 5:
          Lh(b);
          var e = Hh(Gh.current);
          c = b.type;
          if (null !== a && null != b.stateNode) Cj(a, b, c, d2, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
          else {
            if (!d2) {
              if (null === b.stateNode) throw Error(p(166));
              S(b);
              return null;
            }
            a = Hh(Eh.current);
            if (Gg(b)) {
              d2 = b.stateNode;
              c = b.type;
              var f = b.memoizedProps;
              d2[Of] = b;
              d2[Pf] = f;
              a = 0 !== (b.mode & 1);
              switch (c) {
                case "dialog":
                  D("cancel", d2);
                  D("close", d2);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", d2);
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf.length; e++) D(lf[e], d2);
                  break;
                case "source":
                  D("error", d2);
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    d2
                  );
                  D("load", d2);
                  break;
                case "details":
                  D("toggle", d2);
                  break;
                case "input":
                  Za(d2, f);
                  D("invalid", d2);
                  break;
                case "select":
                  d2._wrapperState = { wasMultiple: !!f.multiple };
                  D("invalid", d2);
                  break;
                case "textarea":
                  hb(d2, f), D("invalid", d2);
              }
              ub(c, f);
              e = null;
              for (var g in f) if (f.hasOwnProperty(g)) {
                var h = f[g];
                "children" === g ? "string" === typeof h ? d2.textContent !== h && (true !== f.suppressHydrationWarning && Af(d2.textContent, h, a), e = ["children", h]) : "number" === typeof h && d2.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af(
                  d2.textContent,
                  h,
                  a
                ), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d2);
              }
              switch (c) {
                case "input":
                  Va(d2);
                  db(d2, f, true);
                  break;
                case "textarea":
                  Va(d2);
                  jb(d2);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  "function" === typeof f.onClick && (d2.onclick = Bf);
              }
              d2 = e;
              b.updateQueue = d2;
              null !== d2 && (b.flags |= 4);
            } else {
              g = 9 === e.nodeType ? e : e.ownerDocument;
              "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
              "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d2.is ? a = g.createElement(c, { is: d2.is }) : (a = g.createElement(c), "select" === c && (g = a, d2.multiple ? g.multiple = true : d2.size && (g.size = d2.size))) : a = g.createElementNS(a, c);
              a[Of] = b;
              a[Pf] = d2;
              Aj(a, b, false, false);
              b.stateNode = a;
              a: {
                g = vb(c, d2);
                switch (c) {
                  case "dialog":
                    D("cancel", a);
                    D("close", a);
                    e = d2;
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", a);
                    e = d2;
                    break;
                  case "video":
                  case "audio":
                    for (e = 0; e < lf.length; e++) D(lf[e], a);
                    e = d2;
                    break;
                  case "source":
                    D("error", a);
                    e = d2;
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      a
                    );
                    D("load", a);
                    e = d2;
                    break;
                  case "details":
                    D("toggle", a);
                    e = d2;
                    break;
                  case "input":
                    Za(a, d2);
                    e = Ya(a, d2);
                    D("invalid", a);
                    break;
                  case "option":
                    e = d2;
                    break;
                  case "select":
                    a._wrapperState = { wasMultiple: !!d2.multiple };
                    e = A({}, d2, { value: void 0 });
                    D("invalid", a);
                    break;
                  case "textarea":
                    hb(a, d2);
                    e = gb(a, d2);
                    D("invalid", a);
                    break;
                  default:
                    e = d2;
                }
                ub(c, e);
                h = e;
                for (f in h) if (h.hasOwnProperty(f)) {
                  var k = h[f];
                  "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
                }
                switch (c) {
                  case "input":
                    Va(a);
                    db(a, d2, false);
                    break;
                  case "textarea":
                    Va(a);
                    jb(a);
                    break;
                  case "option":
                    null != d2.value && a.setAttribute("value", "" + Sa(d2.value));
                    break;
                  case "select":
                    a.multiple = !!d2.multiple;
                    f = d2.value;
                    null != f ? fb(a, !!d2.multiple, f, false) : null != d2.defaultValue && fb(
                      a,
                      !!d2.multiple,
                      d2.defaultValue,
                      true
                    );
                    break;
                  default:
                    "function" === typeof e.onClick && (a.onclick = Bf);
                }
                switch (c) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    d2 = !!d2.autoFocus;
                    break a;
                  case "img":
                    d2 = true;
                    break a;
                  default:
                    d2 = false;
                }
              }
              d2 && (b.flags |= 4);
            }
            null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
          }
          S(b);
          return null;
        case 6:
          if (a && null != b.stateNode) Dj(a, b, a.memoizedProps, d2);
          else {
            if ("string" !== typeof d2 && null === b.stateNode) throw Error(p(166));
            c = Hh(Gh.current);
            Hh(Eh.current);
            if (Gg(b)) {
              d2 = b.stateNode;
              c = b.memoizedProps;
              d2[Of] = b;
              if (f = d2.nodeValue !== c) {
                if (a = xg, null !== a) switch (a.tag) {
                  case 3:
                    Af(d2.nodeValue, c, 0 !== (a.mode & 1));
                    break;
                  case 5:
                    true !== a.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c, 0 !== (a.mode & 1));
                }
              }
              f && (b.flags |= 4);
            } else d2 = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d2), d2[Of] = b, b.stateNode = d2;
          }
          S(b);
          return null;
        case 13:
          E(M);
          d2 = b.memoizedState;
          if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
            if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;
            else if (f = Gg(b), null !== d2 && null !== d2.dehydrated) {
              if (null === a) {
                if (!f) throw Error(p(318));
                f = b.memoizedState;
                f = null !== f ? f.dehydrated : null;
                if (!f) throw Error(p(317));
                f[Of] = b;
              } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
              S(b);
              f = false;
            } else null !== zg && (Gj(zg), zg = null), f = true;
            if (!f) return b.flags & 65536 ? b : null;
          }
          if (0 !== (b.flags & 128)) return b.lanes = c, b;
          d2 = null !== d2;
          d2 !== (null !== a && null !== a.memoizedState) && d2 && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (M.current & 1) ? 0 === T && (T = 3) : uj()));
          null !== b.updateQueue && (b.flags |= 4);
          S(b);
          return null;
        case 4:
          return Jh(), Bj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
        case 10:
          return Rg(b.type._context), S(b), null;
        case 17:
          return Zf(b.type) && $f(), S(b), null;
        case 19:
          E(M);
          f = b.memoizedState;
          if (null === f) return S(b), null;
          d2 = 0 !== (b.flags & 128);
          g = f.rendering;
          if (null === g) if (d2) Ej(f, false);
          else {
            if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
              g = Mh(a);
              if (null !== g) {
                b.flags |= 128;
                Ej(f, false);
                d2 = g.updateQueue;
                null !== d2 && (b.updateQueue = d2, b.flags |= 4);
                b.subtreeFlags = 0;
                d2 = c;
                for (c = b.child; null !== c; ) f = c, a = d2, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                G(M, M.current & 1 | 2);
                return b.child;
              }
              a = a.sibling;
            }
            null !== f.tail && B() > Hj && (b.flags |= 128, d2 = true, Ej(f, false), b.lanes = 4194304);
          }
          else {
            if (!d2) if (a = Mh(g), null !== a) {
              if (b.flags |= 128, d2 = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Ej(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
            } else 2 * B() - f.renderingStartTime > Hj && 1073741824 !== c && (b.flags |= 128, d2 = true, Ej(f, false), b.lanes = 4194304);
            f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
          }
          if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = M.current, G(M, d2 ? c & 1 | 2 : c & 1), b;
          S(b);
          return null;
        case 22:
        case 23:
          return Ij(), d2 = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d2 && (b.flags |= 8192), d2 && 0 !== (b.mode & 1) ? 0 !== (gj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(p(156, b.tag));
    }
    __name(Fj, "Fj");
    function Jj(a, b) {
      wg(b);
      switch (b.tag) {
        case 1:
          return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
        case 3:
          return Jh(), E(Wf), E(H), Oh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
        case 5:
          return Lh(b), null;
        case 13:
          E(M);
          a = b.memoizedState;
          if (null !== a && null !== a.dehydrated) {
            if (null === b.alternate) throw Error(p(340));
            Ig();
          }
          a = b.flags;
          return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
        case 19:
          return E(M), null;
        case 4:
          return Jh(), null;
        case 10:
          return Rg(b.type._context), null;
        case 22:
        case 23:
          return Ij(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    __name(Jj, "Jj");
    var Kj = false;
    var U = false;
    var Lj = "function" === typeof WeakSet ? WeakSet : Set;
    var V = null;
    function Mj(a, b) {
      var c = a.ref;
      if (null !== c) if ("function" === typeof c) try {
        c(null);
      } catch (d2) {
        W(a, b, d2);
      }
      else c.current = null;
    }
    __name(Mj, "Mj");
    function Nj(a, b, c) {
      try {
        c();
      } catch (d2) {
        W(a, b, d2);
      }
    }
    __name(Nj, "Nj");
    var Oj = false;
    function Pj(a, b) {
      Cf = dd;
      a = Me();
      if (Ne(a)) {
        if ("selectionStart" in a) var c = { start: a.selectionStart, end: a.selectionEnd };
        else a: {
          c = (c = a.ownerDocument) && c.defaultView || window;
          var d2 = c.getSelection && c.getSelection();
          if (d2 && 0 !== d2.rangeCount) {
            c = d2.anchorNode;
            var e = d2.anchorOffset, f = d2.focusNode;
            d2 = d2.focusOffset;
            try {
              c.nodeType, f.nodeType;
            } catch (F) {
              c = null;
              break a;
            }
            var g = 0, h = -1, k = -1, l = 0, m = 0, q = a, r = null;
            b: for (; ; ) {
              for (var y; ; ) {
                q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
                q !== f || 0 !== d2 && 3 !== q.nodeType || (k = g + d2);
                3 === q.nodeType && (g += q.nodeValue.length);
                if (null === (y = q.firstChild)) break;
                r = q;
                q = y;
              }
              for (; ; ) {
                if (q === a) break b;
                r === c && ++l === e && (h = g);
                r === f && ++m === d2 && (k = g);
                if (null !== (y = q.nextSibling)) break;
                q = r;
                r = q.parentNode;
              }
              q = y;
            }
            c = -1 === h || -1 === k ? null : { start: h, end: k };
          } else c = null;
        }
        c = c || { start: 0, end: 0 };
      } else c = null;
      Df = { focusedElem: a, selectionRange: c };
      dd = false;
      for (V = b; null !== V; ) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;
      else for (; null !== V; ) {
        b = V;
        try {
          var n = b.alternate;
          if (0 !== (b.flags & 1024)) switch (b.tag) {
            case 0:
            case 11:
            case 15:
              break;
            case 1:
              if (null !== n) {
                var t = n.memoizedProps, J = n.memoizedState, x = b.stateNode, w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Lg(b.type, t), J);
                x.__reactInternalSnapshotBeforeUpdate = w;
              }
              break;
            case 3:
              var u = b.stateNode.containerInfo;
              1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
              break;
            case 5:
            case 6:
            case 4:
            case 17:
              break;
            default:
              throw Error(p(163));
          }
        } catch (F) {
          W(b, b.return, F);
        }
        a = b.sibling;
        if (null !== a) {
          a.return = b.return;
          V = a;
          break;
        }
        V = b.return;
      }
      n = Oj;
      Oj = false;
      return n;
    }
    __name(Pj, "Pj");
    function Qj(a, b, c) {
      var d2 = b.updateQueue;
      d2 = null !== d2 ? d2.lastEffect : null;
      if (null !== d2) {
        var e = d2 = d2.next;
        do {
          if ((e.tag & a) === a) {
            var f = e.destroy;
            e.destroy = void 0;
            void 0 !== f && Nj(b, c, f);
          }
          e = e.next;
        } while (e !== d2);
      }
    }
    __name(Qj, "Qj");
    function Rj(a, b) {
      b = b.updateQueue;
      b = null !== b ? b.lastEffect : null;
      if (null !== b) {
        var c = b = b.next;
        do {
          if ((c.tag & a) === a) {
            var d2 = c.create;
            c.destroy = d2();
          }
          c = c.next;
        } while (c !== b);
      }
    }
    __name(Rj, "Rj");
    function Sj(a) {
      var b = a.ref;
      if (null !== b) {
        var c = a.stateNode;
        switch (a.tag) {
          case 5:
            a = c;
            break;
          default:
            a = c;
        }
        "function" === typeof b ? b(a) : b.current = a;
      }
    }
    __name(Sj, "Sj");
    function Tj(a) {
      var b = a.alternate;
      null !== b && (a.alternate = null, Tj(b));
      a.child = null;
      a.deletions = null;
      a.sibling = null;
      5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of2], delete b[Qf], delete b[Rf]));
      a.stateNode = null;
      a.return = null;
      a.dependencies = null;
      a.memoizedProps = null;
      a.memoizedState = null;
      a.pendingProps = null;
      a.stateNode = null;
      a.updateQueue = null;
    }
    __name(Tj, "Tj");
    function Uj(a) {
      return 5 === a.tag || 3 === a.tag || 4 === a.tag;
    }
    __name(Uj, "Uj");
    function Vj(a) {
      a: for (; ; ) {
        for (; null === a.sibling; ) {
          if (null === a.return || Uj(a.return)) return null;
          a = a.return;
        }
        a.sibling.return = a.return;
        for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
          if (a.flags & 2) continue a;
          if (null === a.child || 4 === a.tag) continue a;
          else a.child.return = a, a = a.child;
        }
        if (!(a.flags & 2)) return a.stateNode;
      }
    }
    __name(Vj, "Vj");
    function Wj(a, b, c) {
      var d2 = a.tag;
      if (5 === d2 || 6 === d2) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
      else if (4 !== d2 && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
    }
    __name(Wj, "Wj");
    function Xj(a, b, c) {
      var d2 = a.tag;
      if (5 === d2 || 6 === d2) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
      else if (4 !== d2 && (a = a.child, null !== a)) for (Xj(a, b, c), a = a.sibling; null !== a; ) Xj(a, b, c), a = a.sibling;
    }
    __name(Xj, "Xj");
    var X = null;
    var Yj = false;
    function Zj(a, b, c) {
      for (c = c.child; null !== c; ) ak(a, b, c), c = c.sibling;
    }
    __name(Zj, "Zj");
    function ak(a, b, c) {
      if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
        lc.onCommitFiberUnmount(kc, c);
      } catch (h) {
      }
      switch (c.tag) {
        case 5:
          U || Mj(c, b);
        case 6:
          var d2 = X, e = Yj;
          X = null;
          Zj(a, b, c);
          X = d2;
          Yj = e;
          null !== X && (Yj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
          break;
        case 18:
          null !== X && (Yj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
          break;
        case 4:
          d2 = X;
          e = Yj;
          X = c.stateNode.containerInfo;
          Yj = true;
          Zj(a, b, c);
          X = d2;
          Yj = e;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          if (!U && (d2 = c.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
            e = d2 = d2.next;
            do {
              var f = e, g = f.destroy;
              f = f.tag;
              void 0 !== g && (0 !== (f & 2) ? Nj(c, b, g) : 0 !== (f & 4) && Nj(c, b, g));
              e = e.next;
            } while (e !== d2);
          }
          Zj(a, b, c);
          break;
        case 1:
          if (!U && (Mj(c, b), d2 = c.stateNode, "function" === typeof d2.componentWillUnmount)) try {
            d2.props = c.memoizedProps, d2.state = c.memoizedState, d2.componentWillUnmount();
          } catch (h) {
            W(c, b, h);
          }
          Zj(a, b, c);
          break;
        case 21:
          Zj(a, b, c);
          break;
        case 22:
          c.mode & 1 ? (U = (d2 = U) || null !== c.memoizedState, Zj(a, b, c), U = d2) : Zj(a, b, c);
          break;
        default:
          Zj(a, b, c);
      }
    }
    __name(ak, "ak");
    function bk(a) {
      var b = a.updateQueue;
      if (null !== b) {
        a.updateQueue = null;
        var c = a.stateNode;
        null === c && (c = a.stateNode = new Lj());
        b.forEach(function(b2) {
          var d2 = ck.bind(null, a, b2);
          c.has(b2) || (c.add(b2), b2.then(d2, d2));
        });
      }
    }
    __name(bk, "bk");
    function dk(a, b) {
      var c = b.deletions;
      if (null !== c) for (var d2 = 0; d2 < c.length; d2++) {
        var e = c[d2];
        try {
          var f = a, g = b, h = g;
          a: for (; null !== h; ) {
            switch (h.tag) {
              case 5:
                X = h.stateNode;
                Yj = false;
                break a;
              case 3:
                X = h.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X = h.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h = h.return;
          }
          if (null === X) throw Error(p(160));
          ak(f, g, e);
          X = null;
          Yj = false;
          var k = e.alternate;
          null !== k && (k.return = null);
          e.return = null;
        } catch (l) {
          W(e, b, l);
        }
      }
      if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) ek(b, a), b = b.sibling;
    }
    __name(dk, "dk");
    function ek(a, b) {
      var c = a.alternate, d2 = a.flags;
      switch (a.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          dk(b, a);
          fk(a);
          if (d2 & 4) {
            try {
              Qj(3, a, a.return), Rj(3, a);
            } catch (t) {
              W(a, a.return, t);
            }
            try {
              Qj(5, a, a.return);
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 1:
          dk(b, a);
          fk(a);
          d2 & 512 && null !== c && Mj(c, c.return);
          break;
        case 5:
          dk(b, a);
          fk(a);
          d2 & 512 && null !== c && Mj(c, c.return);
          if (a.flags & 32) {
            var e = a.stateNode;
            try {
              ob(e, "");
            } catch (t) {
              W(a, a.return, t);
            }
          }
          if (d2 & 4 && (e = a.stateNode, null != e)) {
            var f = a.memoizedProps, g = null !== c ? c.memoizedProps : f, h = a.type, k = a.updateQueue;
            a.updateQueue = null;
            if (null !== k) try {
              "input" === h && "radio" === f.type && null != f.name && ab(e, f);
              vb(h, g);
              var l = vb(h, f);
              for (g = 0; g < k.length; g += 2) {
                var m = k[g], q = k[g + 1];
                "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
              }
              switch (h) {
                case "input":
                  bb(e, f);
                  break;
                case "textarea":
                  ib(e, f);
                  break;
                case "select":
                  var r = e._wrapperState.wasMultiple;
                  e._wrapperState.wasMultiple = !!f.multiple;
                  var y = f.value;
                  null != y ? fb(e, !!f.multiple, y, false) : r !== !!f.multiple && (null != f.defaultValue ? fb(
                    e,
                    !!f.multiple,
                    f.defaultValue,
                    true
                  ) : fb(e, !!f.multiple, f.multiple ? [] : "", false));
              }
              e[Pf] = f;
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 6:
          dk(b, a);
          fk(a);
          if (d2 & 4) {
            if (null === a.stateNode) throw Error(p(162));
            e = a.stateNode;
            f = a.memoizedProps;
            try {
              e.nodeValue = f;
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 3:
          dk(b, a);
          fk(a);
          if (d2 & 4 && null !== c && c.memoizedState.isDehydrated) try {
            bd(b.containerInfo);
          } catch (t) {
            W(a, a.return, t);
          }
          break;
        case 4:
          dk(b, a);
          fk(a);
          break;
        case 13:
          dk(b, a);
          fk(a);
          e = a.child;
          e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (gk = B()));
          d2 & 4 && bk(a);
          break;
        case 22:
          m = null !== c && null !== c.memoizedState;
          a.mode & 1 ? (U = (l = U) || m, dk(b, a), U = l) : dk(b, a);
          fk(a);
          if (d2 & 8192) {
            l = null !== a.memoizedState;
            if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V = a, m = a.child; null !== m; ) {
              for (q = V = m; null !== V; ) {
                r = V;
                y = r.child;
                switch (r.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Qj(4, r, r.return);
                    break;
                  case 1:
                    Mj(r, r.return);
                    var n = r.stateNode;
                    if ("function" === typeof n.componentWillUnmount) {
                      d2 = r;
                      c = r.return;
                      try {
                        b = d2, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                      } catch (t) {
                        W(d2, c, t);
                      }
                    }
                    break;
                  case 5:
                    Mj(r, r.return);
                    break;
                  case 22:
                    if (null !== r.memoizedState) {
                      hk(q);
                      continue;
                    }
                }
                null !== y ? (y.return = r, V = y) : hk(q);
              }
              m = m.sibling;
            }
            a: for (m = null, q = a; ; ) {
              if (5 === q.tag) {
                if (null === m) {
                  m = q;
                  try {
                    e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                  } catch (t) {
                    W(a, a.return, t);
                  }
                }
              } else if (6 === q.tag) {
                if (null === m) try {
                  q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                } catch (t) {
                  W(a, a.return, t);
                }
              } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
                q.child.return = q;
                q = q.child;
                continue;
              }
              if (q === a) break a;
              for (; null === q.sibling; ) {
                if (null === q.return || q.return === a) break a;
                m === q && (m = null);
                q = q.return;
              }
              m === q && (m = null);
              q.sibling.return = q.return;
              q = q.sibling;
            }
          }
          break;
        case 19:
          dk(b, a);
          fk(a);
          d2 & 4 && bk(a);
          break;
        case 21:
          break;
        default:
          dk(
            b,
            a
          ), fk(a);
      }
    }
    __name(ek, "ek");
    function fk(a) {
      var b = a.flags;
      if (b & 2) {
        try {
          a: {
            for (var c = a.return; null !== c; ) {
              if (Uj(c)) {
                var d2 = c;
                break a;
              }
              c = c.return;
            }
            throw Error(p(160));
          }
          switch (d2.tag) {
            case 5:
              var e = d2.stateNode;
              d2.flags & 32 && (ob(e, ""), d2.flags &= -33);
              var f = Vj(a);
              Xj(a, f, e);
              break;
            case 3:
            case 4:
              var g = d2.stateNode.containerInfo, h = Vj(a);
              Wj(a, h, g);
              break;
            default:
              throw Error(p(161));
          }
        } catch (k) {
          W(a, a.return, k);
        }
        a.flags &= -3;
      }
      b & 4096 && (a.flags &= -4097);
    }
    __name(fk, "fk");
    function ik(a, b, c) {
      V = a;
      jk(a, b, c);
    }
    __name(ik, "ik");
    function jk(a, b, c) {
      for (var d2 = 0 !== (a.mode & 1); null !== V; ) {
        var e = V, f = e.child;
        if (22 === e.tag && d2) {
          var g = null !== e.memoizedState || Kj;
          if (!g) {
            var h = e.alternate, k = null !== h && null !== h.memoizedState || U;
            h = Kj;
            var l = U;
            Kj = g;
            if ((U = k) && !l) for (V = e; null !== V; ) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? kk(e) : null !== k ? (k.return = g, V = k) : kk(e);
            for (; null !== f; ) V = f, jk(f, b, c), f = f.sibling;
            V = e;
            Kj = h;
            U = l;
          }
          lk(a, b, c);
        } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : lk(a, b, c);
      }
    }
    __name(jk, "jk");
    function lk(a) {
      for (; null !== V; ) {
        var b = V;
        if (0 !== (b.flags & 8772)) {
          var c = b.alternate;
          try {
            if (0 !== (b.flags & 8772)) switch (b.tag) {
              case 0:
              case 11:
              case 15:
                U || Rj(5, b);
                break;
              case 1:
                var d2 = b.stateNode;
                if (b.flags & 4 && !U) if (null === c) d2.componentDidMount();
                else {
                  var e = b.elementType === b.type ? c.memoizedProps : Lg(b.type, c.memoizedProps);
                  d2.componentDidUpdate(e, c.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
                var f = b.updateQueue;
                null !== f && ih(b, f, d2);
                break;
              case 3:
                var g = b.updateQueue;
                if (null !== g) {
                  c = null;
                  if (null !== b.child) switch (b.child.tag) {
                    case 5:
                      c = b.child.stateNode;
                      break;
                    case 1:
                      c = b.child.stateNode;
                  }
                  ih(b, g, c);
                }
                break;
              case 5:
                var h = b.stateNode;
                if (null === c && b.flags & 4) {
                  c = h;
                  var k = b.memoizedProps;
                  switch (b.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      k.autoFocus && c.focus();
                      break;
                    case "img":
                      k.src && (c.src = k.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (null === b.memoizedState) {
                  var l = b.alternate;
                  if (null !== l) {
                    var m = l.memoizedState;
                    if (null !== m) {
                      var q = m.dehydrated;
                      null !== q && bd(q);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(p(163));
            }
            U || b.flags & 512 && Sj(b);
          } catch (r) {
            W(b, b.return, r);
          }
        }
        if (b === a) {
          V = null;
          break;
        }
        c = b.sibling;
        if (null !== c) {
          c.return = b.return;
          V = c;
          break;
        }
        V = b.return;
      }
    }
    __name(lk, "lk");
    function hk(a) {
      for (; null !== V; ) {
        var b = V;
        if (b === a) {
          V = null;
          break;
        }
        var c = b.sibling;
        if (null !== c) {
          c.return = b.return;
          V = c;
          break;
        }
        V = b.return;
      }
    }
    __name(hk, "hk");
    function kk(a) {
      for (; null !== V; ) {
        var b = V;
        try {
          switch (b.tag) {
            case 0:
            case 11:
            case 15:
              var c = b.return;
              try {
                Rj(4, b);
              } catch (k) {
                W(b, c, k);
              }
              break;
            case 1:
              var d2 = b.stateNode;
              if ("function" === typeof d2.componentDidMount) {
                var e = b.return;
                try {
                  d2.componentDidMount();
                } catch (k) {
                  W(b, e, k);
                }
              }
              var f = b.return;
              try {
                Sj(b);
              } catch (k) {
                W(b, f, k);
              }
              break;
            case 5:
              var g = b.return;
              try {
                Sj(b);
              } catch (k) {
                W(b, g, k);
              }
          }
        } catch (k) {
          W(b, b.return, k);
        }
        if (b === a) {
          V = null;
          break;
        }
        var h = b.sibling;
        if (null !== h) {
          h.return = b.return;
          V = h;
          break;
        }
        V = b.return;
      }
    }
    __name(kk, "kk");
    var mk = Math.ceil;
    var nk = ua.ReactCurrentDispatcher;
    var ok = ua.ReactCurrentOwner;
    var pk = ua.ReactCurrentBatchConfig;
    var K = 0;
    var R = null;
    var Y = null;
    var Z = 0;
    var gj = 0;
    var fj = Uf(0);
    var T = 0;
    var qk = null;
    var hh = 0;
    var rk = 0;
    var sk = 0;
    var tk = null;
    var uk = null;
    var gk = 0;
    var Hj = Infinity;
    var vk = null;
    var Pi = false;
    var Qi = null;
    var Si = null;
    var wk = false;
    var xk = null;
    var yk = 0;
    var zk = 0;
    var Ak = null;
    var Bk = -1;
    var Ck = 0;
    function L() {
      return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
    }
    __name(L, "L");
    function lh(a) {
      if (0 === (a.mode & 1)) return 1;
      if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
      if (null !== Kg.transition) return 0 === Ck && (Ck = yc()), Ck;
      a = C;
      if (0 !== a) return a;
      a = window.event;
      a = void 0 === a ? 16 : jd(a.type);
      return a;
    }
    __name(lh, "lh");
    function mh(a, b, c, d2) {
      if (50 < zk) throw zk = 0, Ak = null, Error(p(185));
      Ac(a, c, d2);
      if (0 === (K & 2) || a !== R) a === R && (0 === (K & 2) && (rk |= c), 4 === T && Dk(a, Z)), Ek(a, d2), 1 === c && 0 === K && 0 === (b.mode & 1) && (Hj = B() + 500, fg && jg());
    }
    __name(mh, "mh");
    function Ek(a, b) {
      var c = a.callbackNode;
      wc(a, b);
      var d2 = uc(a, a === R ? Z : 0);
      if (0 === d2) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
      else if (b = d2 & -d2, a.callbackPriority !== b) {
        null != c && bc(c);
        if (1 === b) 0 === a.tag ? ig(Fk.bind(null, a)) : hg(Fk.bind(null, a)), Jf(function() {
          0 === (K & 6) && jg();
        }), c = null;
        else {
          switch (Dc(d2)) {
            case 1:
              c = fc;
              break;
            case 4:
              c = gc;
              break;
            case 16:
              c = hc;
              break;
            case 536870912:
              c = jc;
              break;
            default:
              c = hc;
          }
          c = Gk(c, Hk.bind(null, a));
        }
        a.callbackPriority = b;
        a.callbackNode = c;
      }
    }
    __name(Ek, "Ek");
    function Hk(a, b) {
      Bk = -1;
      Ck = 0;
      if (0 !== (K & 6)) throw Error(p(327));
      var c = a.callbackNode;
      if (Ik() && a.callbackNode !== c) return null;
      var d2 = uc(a, a === R ? Z : 0);
      if (0 === d2) return null;
      if (0 !== (d2 & 30) || 0 !== (d2 & a.expiredLanes) || b) b = Jk(a, d2);
      else {
        b = d2;
        var e = K;
        K |= 2;
        var f = Kk();
        if (R !== a || Z !== b) vk = null, Hj = B() + 500, Lk(a, b);
        do
          try {
            Mk();
            break;
          } catch (h) {
            Nk(a, h);
          }
        while (1);
        Qg();
        nk.current = f;
        K = e;
        null !== Y ? b = 0 : (R = null, Z = 0, b = T);
      }
      if (0 !== b) {
        2 === b && (e = xc(a), 0 !== e && (d2 = e, b = Ok(a, e)));
        if (1 === b) throw c = qk, Lk(a, 0), Dk(a, d2), Ek(a, B()), c;
        if (6 === b) Dk(a, d2);
        else {
          e = a.current.alternate;
          if (0 === (d2 & 30) && !Pk(e) && (b = Jk(a, d2), 2 === b && (f = xc(a), 0 !== f && (d2 = f, b = Ok(a, f))), 1 === b)) throw c = qk, Lk(a, 0), Dk(a, d2), Ek(a, B()), c;
          a.finishedWork = e;
          a.finishedLanes = d2;
          switch (b) {
            case 0:
            case 1:
              throw Error(p(345));
            case 2:
              Qk(a, uk, vk);
              break;
            case 3:
              Dk(a, d2);
              if ((d2 & 130023424) === d2 && (b = gk + 500 - B(), 10 < b)) {
                if (0 !== uc(a, 0)) break;
                e = a.suspendedLanes;
                if ((e & d2) !== d2) {
                  L();
                  a.pingedLanes |= a.suspendedLanes & e;
                  break;
                }
                a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), b);
                break;
              }
              Qk(a, uk, vk);
              break;
            case 4:
              Dk(a, d2);
              if ((d2 & 4194240) === d2) break;
              b = a.eventTimes;
              for (e = -1; 0 < d2; ) {
                var g = 31 - oc(d2);
                f = 1 << g;
                g = b[g];
                g > e && (e = g);
                d2 &= ~f;
              }
              d2 = e;
              d2 = B() - d2;
              d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
              if (10 < d2) {
                a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), d2);
                break;
              }
              Qk(a, uk, vk);
              break;
            case 5:
              Qk(a, uk, vk);
              break;
            default:
              throw Error(p(329));
          }
        }
      }
      Ek(a, B());
      return a.callbackNode === c ? Hk.bind(null, a) : null;
    }
    __name(Hk, "Hk");
    function Ok(a, b) {
      var c = tk;
      a.current.memoizedState.isDehydrated && (Lk(a, b).flags |= 256);
      a = Jk(a, b);
      2 !== a && (b = uk, uk = c, null !== b && Gj(b));
      return a;
    }
    __name(Ok, "Ok");
    function Gj(a) {
      null === uk ? uk = a : uk.push.apply(uk, a);
    }
    __name(Gj, "Gj");
    function Pk(a) {
      for (var b = a; ; ) {
        if (b.flags & 16384) {
          var c = b.updateQueue;
          if (null !== c && (c = c.stores, null !== c)) for (var d2 = 0; d2 < c.length; d2++) {
            var e = c[d2], f = e.getSnapshot;
            e = e.value;
            try {
              if (!He(f(), e)) return false;
            } catch (g) {
              return false;
            }
          }
        }
        c = b.child;
        if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
        else {
          if (b === a) break;
          for (; null === b.sibling; ) {
            if (null === b.return || b.return === a) return true;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
      }
      return true;
    }
    __name(Pk, "Pk");
    function Dk(a, b) {
      b &= ~sk;
      b &= ~rk;
      a.suspendedLanes |= b;
      a.pingedLanes &= ~b;
      for (a = a.expirationTimes; 0 < b; ) {
        var c = 31 - oc(b), d2 = 1 << c;
        a[c] = -1;
        b &= ~d2;
      }
    }
    __name(Dk, "Dk");
    function Fk(a) {
      if (0 !== (K & 6)) throw Error(p(327));
      Ik();
      var b = uc(a, 0);
      if (0 === (b & 1)) return Ek(a, B()), null;
      var c = Jk(a, b);
      if (0 !== a.tag && 2 === c) {
        var d2 = xc(a);
        0 !== d2 && (b = d2, c = Ok(a, d2));
      }
      if (1 === c) throw c = qk, Lk(a, 0), Dk(a, b), Ek(a, B()), c;
      if (6 === c) throw Error(p(345));
      a.finishedWork = a.current.alternate;
      a.finishedLanes = b;
      Qk(a, uk, vk);
      Ek(a, B());
      return null;
    }
    __name(Fk, "Fk");
    function Rk(a, b) {
      var c = K;
      K |= 1;
      try {
        return a(b);
      } finally {
        K = c, 0 === K && (Hj = B() + 500, fg && jg());
      }
    }
    __name(Rk, "Rk");
    function Sk(a) {
      null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
      var b = K;
      K |= 1;
      var c = pk.transition, d2 = C;
      try {
        if (pk.transition = null, C = 1, a) return a();
      } finally {
        C = d2, pk.transition = c, K = b, 0 === (K & 6) && jg();
      }
    }
    __name(Sk, "Sk");
    function Ij() {
      gj = fj.current;
      E(fj);
    }
    __name(Ij, "Ij");
    function Lk(a, b) {
      a.finishedWork = null;
      a.finishedLanes = 0;
      var c = a.timeoutHandle;
      -1 !== c && (a.timeoutHandle = -1, Gf(c));
      if (null !== Y) for (c = Y.return; null !== c; ) {
        var d2 = c;
        wg(d2);
        switch (d2.tag) {
          case 1:
            d2 = d2.type.childContextTypes;
            null !== d2 && void 0 !== d2 && $f();
            break;
          case 3:
            Jh();
            E(Wf);
            E(H);
            Oh();
            break;
          case 5:
            Lh(d2);
            break;
          case 4:
            Jh();
            break;
          case 13:
            E(M);
            break;
          case 19:
            E(M);
            break;
          case 10:
            Rg(d2.type._context);
            break;
          case 22:
          case 23:
            Ij();
        }
        c = c.return;
      }
      R = a;
      Y = a = wh(a.current, null);
      Z = gj = b;
      T = 0;
      qk = null;
      sk = rk = hh = 0;
      uk = tk = null;
      if (null !== Wg) {
        for (b = 0; b < Wg.length; b++) if (c = Wg[b], d2 = c.interleaved, null !== d2) {
          c.interleaved = null;
          var e = d2.next, f = c.pending;
          if (null !== f) {
            var g = f.next;
            f.next = e;
            d2.next = g;
          }
          c.pending = d2;
        }
        Wg = null;
      }
      return a;
    }
    __name(Lk, "Lk");
    function Nk(a, b) {
      do {
        var c = Y;
        try {
          Qg();
          Ph.current = ai;
          if (Sh) {
            for (var d2 = N.memoizedState; null !== d2; ) {
              var e = d2.queue;
              null !== e && (e.pending = null);
              d2 = d2.next;
            }
            Sh = false;
          }
          Rh = 0;
          P = O = N = null;
          Th = false;
          Uh = 0;
          ok.current = null;
          if (null === c || null === c.return) {
            T = 1;
            qk = b;
            Y = null;
            break;
          }
          a: {
            var f = a, g = c.return, h = c, k = b;
            b = Z;
            h.flags |= 32768;
            if (null !== k && "object" === typeof k && "function" === typeof k.then) {
              var l = k, m = h, q = m.tag;
              if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
                var r = m.alternate;
                r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
              }
              var y = Vi(g);
              if (null !== y) {
                y.flags &= -257;
                Wi(y, g, h, f, b);
                y.mode & 1 && Ti(f, l, b);
                b = y;
                k = l;
                var n = b.updateQueue;
                if (null === n) {
                  var t = /* @__PURE__ */ new Set();
                  t.add(k);
                  b.updateQueue = t;
                } else n.add(k);
                break a;
              } else {
                if (0 === (b & 1)) {
                  Ti(f, l, b);
                  uj();
                  break a;
                }
                k = Error(p(426));
              }
            } else if (I && h.mode & 1) {
              var J = Vi(g);
              if (null !== J) {
                0 === (J.flags & 65536) && (J.flags |= 256);
                Wi(J, g, h, f, b);
                Jg(Ki(k, h));
                break a;
              }
            }
            f = k = Ki(k, h);
            4 !== T && (T = 2);
            null === tk ? tk = [f] : tk.push(f);
            f = g;
            do {
              switch (f.tag) {
                case 3:
                  f.flags |= 65536;
                  b &= -b;
                  f.lanes |= b;
                  var x = Oi(f, k, b);
                  fh(f, x);
                  break a;
                case 1:
                  h = k;
                  var w = f.type, u = f.stateNode;
                  if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Si || !Si.has(u)))) {
                    f.flags |= 65536;
                    b &= -b;
                    f.lanes |= b;
                    var F = Ri(f, h, b);
                    fh(f, F);
                    break a;
                  }
              }
              f = f.return;
            } while (null !== f);
          }
          Tk(c);
        } catch (na) {
          b = na;
          Y === c && null !== c && (Y = c = c.return);
          continue;
        }
        break;
      } while (1);
    }
    __name(Nk, "Nk");
    function Kk() {
      var a = nk.current;
      nk.current = ai;
      return null === a ? ai : a;
    }
    __name(Kk, "Kk");
    function uj() {
      if (0 === T || 3 === T || 2 === T) T = 4;
      null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z);
    }
    __name(uj, "uj");
    function Jk(a, b) {
      var c = K;
      K |= 2;
      var d2 = Kk();
      if (R !== a || Z !== b) vk = null, Lk(a, b);
      do
        try {
          Uk();
          break;
        } catch (e) {
          Nk(a, e);
        }
      while (1);
      Qg();
      K = c;
      nk.current = d2;
      if (null !== Y) throw Error(p(261));
      R = null;
      Z = 0;
      return T;
    }
    __name(Jk, "Jk");
    function Uk() {
      for (; null !== Y; ) Vk(Y);
    }
    __name(Uk, "Uk");
    function Mk() {
      for (; null !== Y && !cc(); ) Vk(Y);
    }
    __name(Mk, "Mk");
    function Vk(a) {
      var b = Wk(a.alternate, a, gj);
      a.memoizedProps = a.pendingProps;
      null === b ? Tk(a) : Y = b;
      ok.current = null;
    }
    __name(Vk, "Vk");
    function Tk(a) {
      var b = a;
      do {
        var c = b.alternate;
        a = b.return;
        if (0 === (b.flags & 32768)) {
          if (c = Fj(c, b, gj), null !== c) {
            Y = c;
            return;
          }
        } else {
          c = Jj(c, b);
          if (null !== c) {
            c.flags &= 32767;
            Y = c;
            return;
          }
          if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
          else {
            T = 6;
            Y = null;
            return;
          }
        }
        b = b.sibling;
        if (null !== b) {
          Y = b;
          return;
        }
        Y = b = a;
      } while (null !== b);
      0 === T && (T = 5);
    }
    __name(Tk, "Tk");
    function Qk(a, b, c) {
      var d2 = C, e = pk.transition;
      try {
        pk.transition = null, C = 1, Xk(a, b, c, d2);
      } finally {
        pk.transition = e, C = d2;
      }
      return null;
    }
    __name(Qk, "Qk");
    function Xk(a, b, c, d2) {
      do
        Ik();
      while (null !== xk);
      if (0 !== (K & 6)) throw Error(p(327));
      c = a.finishedWork;
      var e = a.finishedLanes;
      if (null === c) return null;
      a.finishedWork = null;
      a.finishedLanes = 0;
      if (c === a.current) throw Error(p(177));
      a.callbackNode = null;
      a.callbackPriority = 0;
      var f = c.lanes | c.childLanes;
      Bc(a, f);
      a === R && (Y = R = null, Z = 0);
      0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || wk || (wk = true, Gk(hc, function() {
        Ik();
        return null;
      }));
      f = 0 !== (c.flags & 15990);
      if (0 !== (c.subtreeFlags & 15990) || f) {
        f = pk.transition;
        pk.transition = null;
        var g = C;
        C = 1;
        var h = K;
        K |= 4;
        ok.current = null;
        Pj(a, c);
        ek(c, a);
        Oe(Df);
        dd = !!Cf;
        Df = Cf = null;
        a.current = c;
        ik(c, a, e);
        dc();
        K = h;
        C = g;
        pk.transition = f;
      } else a.current = c;
      wk && (wk = false, xk = a, yk = e);
      f = a.pendingLanes;
      0 === f && (Si = null);
      mc(c.stateNode, d2);
      Ek(a, B());
      if (null !== b) for (d2 = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d2(e.value, { componentStack: e.stack, digest: e.digest });
      if (Pi) throw Pi = false, a = Qi, Qi = null, a;
      0 !== (yk & 1) && 0 !== a.tag && Ik();
      f = a.pendingLanes;
      0 !== (f & 1) ? a === Ak ? zk++ : (zk = 0, Ak = a) : zk = 0;
      jg();
      return null;
    }
    __name(Xk, "Xk");
    function Ik() {
      if (null !== xk) {
        var a = Dc(yk), b = pk.transition, c = C;
        try {
          pk.transition = null;
          C = 16 > a ? 16 : a;
          if (null === xk) var d2 = false;
          else {
            a = xk;
            xk = null;
            yk = 0;
            if (0 !== (K & 6)) throw Error(p(331));
            var e = K;
            K |= 4;
            for (V = a.current; null !== V; ) {
              var f = V, g = f.child;
              if (0 !== (V.flags & 16)) {
                var h = f.deletions;
                if (null !== h) {
                  for (var k = 0; k < h.length; k++) {
                    var l = h[k];
                    for (V = l; null !== V; ) {
                      var m = V;
                      switch (m.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(8, m, f);
                      }
                      var q = m.child;
                      if (null !== q) q.return = m, V = q;
                      else for (; null !== V; ) {
                        m = V;
                        var r = m.sibling, y = m.return;
                        Tj(m);
                        if (m === l) {
                          V = null;
                          break;
                        }
                        if (null !== r) {
                          r.return = y;
                          V = r;
                          break;
                        }
                        V = y;
                      }
                    }
                  }
                  var n = f.alternate;
                  if (null !== n) {
                    var t = n.child;
                    if (null !== t) {
                      n.child = null;
                      do {
                        var J = t.sibling;
                        t.sibling = null;
                        t = J;
                      } while (null !== t);
                    }
                  }
                  V = f;
                }
              }
              if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;
              else b: for (; null !== V; ) {
                f = V;
                if (0 !== (f.flags & 2048)) switch (f.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qj(9, f, f.return);
                }
                var x = f.sibling;
                if (null !== x) {
                  x.return = f.return;
                  V = x;
                  break b;
                }
                V = f.return;
              }
            }
            var w = a.current;
            for (V = w; null !== V; ) {
              g = V;
              var u = g.child;
              if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;
              else b: for (g = w; null !== V; ) {
                h = V;
                if (0 !== (h.flags & 2048)) try {
                  switch (h.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Rj(9, h);
                  }
                } catch (na) {
                  W(h, h.return, na);
                }
                if (h === g) {
                  V = null;
                  break b;
                }
                var F = h.sibling;
                if (null !== F) {
                  F.return = h.return;
                  V = F;
                  break b;
                }
                V = h.return;
              }
            }
            K = e;
            jg();
            if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
              lc.onPostCommitFiberRoot(kc, a);
            } catch (na) {
            }
            d2 = true;
          }
          return d2;
        } finally {
          C = c, pk.transition = b;
        }
      }
      return false;
    }
    __name(Ik, "Ik");
    function Yk(a, b, c) {
      b = Ki(c, b);
      b = Oi(a, b, 1);
      a = dh(a, b, 1);
      b = L();
      null !== a && (Ac(a, 1, b), Ek(a, b));
    }
    __name(Yk, "Yk");
    function W(a, b, c) {
      if (3 === a.tag) Yk(a, a, c);
      else for (; null !== b; ) {
        if (3 === b.tag) {
          Yk(b, a, c);
          break;
        } else if (1 === b.tag) {
          var d2 = b.stateNode;
          if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
            a = Ki(c, a);
            a = Ri(b, a, 1);
            b = dh(b, a, 1);
            a = L();
            null !== b && (Ac(b, 1, a), Ek(b, a));
            break;
          }
        }
        b = b.return;
      }
    }
    __name(W, "W");
    function Ui(a, b, c) {
      var d2 = a.pingCache;
      null !== d2 && d2.delete(b);
      b = L();
      a.pingedLanes |= a.suspendedLanes & c;
      R === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a, 0) : sk |= c);
      Ek(a, b);
    }
    __name(Ui, "Ui");
    function Zk(a, b) {
      0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
      var c = L();
      a = Zg(a, b);
      null !== a && (Ac(a, b, c), Ek(a, c));
    }
    __name(Zk, "Zk");
    function vj(a) {
      var b = a.memoizedState, c = 0;
      null !== b && (c = b.retryLane);
      Zk(a, c);
    }
    __name(vj, "vj");
    function ck(a, b) {
      var c = 0;
      switch (a.tag) {
        case 13:
          var d2 = a.stateNode;
          var e = a.memoizedState;
          null !== e && (c = e.retryLane);
          break;
        case 19:
          d2 = a.stateNode;
          break;
        default:
          throw Error(p(314));
      }
      null !== d2 && d2.delete(b);
      Zk(a, c);
    }
    __name(ck, "ck");
    var Wk;
    Wk = /* @__PURE__ */ __name(function(a, b, c) {
      if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) Ug = true;
      else {
        if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return Ug = false, zj(a, b, c);
        Ug = 0 !== (a.flags & 131072) ? true : false;
      }
      else Ug = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
      b.lanes = 0;
      switch (b.tag) {
        case 2:
          var d2 = b.type;
          jj(a, b);
          a = b.pendingProps;
          var e = Yf(b, H.current);
          Tg(b, c);
          e = Xh(null, b, d2, a, e, c);
          var f = bi();
          b.flags |= 1;
          "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d2) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, ah(b), e.updater = nh, b.stateNode = e, e._reactInternals = b, rh(b, d2, a, c), b = kj(null, b, d2, true, f, c)) : (b.tag = 0, I && f && vg(b), Yi(null, b, e, c), b = b.child);
          return b;
        case 16:
          d2 = b.elementType;
          a: {
            jj(a, b);
            a = b.pendingProps;
            e = d2._init;
            d2 = e(d2._payload);
            b.type = d2;
            e = b.tag = $k(d2);
            a = Lg(d2, a);
            switch (e) {
              case 0:
                b = dj(null, b, d2, a, c);
                break a;
              case 1:
                b = ij(null, b, d2, a, c);
                break a;
              case 11:
                b = Zi(null, b, d2, a, c);
                break a;
              case 14:
                b = aj(null, b, d2, Lg(d2.type, a), c);
                break a;
            }
            throw Error(p(
              306,
              d2,
              ""
            ));
          }
          return b;
        case 0:
          return d2 = b.type, e = b.pendingProps, e = b.elementType === d2 ? e : Lg(d2, e), dj(a, b, d2, e, c);
        case 1:
          return d2 = b.type, e = b.pendingProps, e = b.elementType === d2 ? e : Lg(d2, e), ij(a, b, d2, e, c);
        case 3:
          a: {
            lj(b);
            if (null === a) throw Error(p(387));
            d2 = b.pendingProps;
            f = b.memoizedState;
            e = f.element;
            bh(a, b);
            gh(b, d2, null, c);
            var g = b.memoizedState;
            d2 = g.element;
            if (f.isDehydrated) if (f = { element: d2, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
              e = Ki(Error(p(423)), b);
              b = mj(a, b, d2, c, e);
              break a;
            } else if (d2 !== e) {
              e = Ki(Error(p(424)), b);
              b = mj(a, b, d2, c, e);
              break a;
            } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Ch(b, null, d2, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
            else {
              Ig();
              if (d2 === e) {
                b = $i(a, b, c);
                break a;
              }
              Yi(a, b, d2, c);
            }
            b = b.child;
          }
          return b;
        case 5:
          return Kh(b), null === a && Eg(b), d2 = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d2, e) ? g = null : null !== f && Ef(d2, f) && (b.flags |= 32), hj(a, b), Yi(a, b, g, c), b.child;
        case 6:
          return null === a && Eg(b), null;
        case 13:
          return pj(a, b, c);
        case 4:
          return Ih(b, b.stateNode.containerInfo), d2 = b.pendingProps, null === a ? b.child = Bh(b, null, d2, c) : Yi(a, b, d2, c), b.child;
        case 11:
          return d2 = b.type, e = b.pendingProps, e = b.elementType === d2 ? e : Lg(d2, e), Zi(a, b, d2, e, c);
        case 7:
          return Yi(a, b, b.pendingProps, c), b.child;
        case 8:
          return Yi(a, b, b.pendingProps.children, c), b.child;
        case 12:
          return Yi(a, b, b.pendingProps.children, c), b.child;
        case 10:
          a: {
            d2 = b.type._context;
            e = b.pendingProps;
            f = b.memoizedProps;
            g = e.value;
            G(Mg, d2._currentValue);
            d2._currentValue = g;
            if (null !== f) if (He(f.value, g)) {
              if (f.children === e.children && !Wf.current) {
                b = $i(a, b, c);
                break a;
              }
            } else for (f = b.child, null !== f && (f.return = b); null !== f; ) {
              var h = f.dependencies;
              if (null !== h) {
                g = f.child;
                for (var k = h.firstContext; null !== k; ) {
                  if (k.context === d2) {
                    if (1 === f.tag) {
                      k = ch(-1, c & -c);
                      k.tag = 2;
                      var l = f.updateQueue;
                      if (null !== l) {
                        l = l.shared;
                        var m = l.pending;
                        null === m ? k.next = k : (k.next = m.next, m.next = k);
                        l.pending = k;
                      }
                    }
                    f.lanes |= c;
                    k = f.alternate;
                    null !== k && (k.lanes |= c);
                    Sg(
                      f.return,
                      c,
                      b
                    );
                    h.lanes |= c;
                    break;
                  }
                  k = k.next;
                }
              } else if (10 === f.tag) g = f.type === b.type ? null : f.child;
              else if (18 === f.tag) {
                g = f.return;
                if (null === g) throw Error(p(341));
                g.lanes |= c;
                h = g.alternate;
                null !== h && (h.lanes |= c);
                Sg(g, c, b);
                g = f.sibling;
              } else g = f.child;
              if (null !== g) g.return = f;
              else for (g = f; null !== g; ) {
                if (g === b) {
                  g = null;
                  break;
                }
                f = g.sibling;
                if (null !== f) {
                  f.return = g.return;
                  g = f;
                  break;
                }
                g = g.return;
              }
              f = g;
            }
            Yi(a, b, e.children, c);
            b = b.child;
          }
          return b;
        case 9:
          return e = b.type, d2 = b.pendingProps.children, Tg(b, c), e = Vg(e), d2 = d2(e), b.flags |= 1, Yi(a, b, d2, c), b.child;
        case 14:
          return d2 = b.type, e = Lg(d2, b.pendingProps), e = Lg(d2.type, e), aj(a, b, d2, e, c);
        case 15:
          return cj(a, b, b.type, b.pendingProps, c);
        case 17:
          return d2 = b.type, e = b.pendingProps, e = b.elementType === d2 ? e : Lg(d2, e), jj(a, b), b.tag = 1, Zf(d2) ? (a = true, cg(b)) : a = false, Tg(b, c), ph(b, d2, e), rh(b, d2, e, c), kj(null, b, d2, true, a, c);
        case 19:
          return yj(a, b, c);
        case 22:
          return ej(a, b, c);
      }
      throw Error(p(156, b.tag));
    }, "Wk");
    function Gk(a, b) {
      return ac(a, b);
    }
    __name(Gk, "Gk");
    function al(a, b, c, d2) {
      this.tag = a;
      this.key = c;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d2;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    __name(al, "al");
    function Bg(a, b, c, d2) {
      return new al(a, b, c, d2);
    }
    __name(Bg, "Bg");
    function bj(a) {
      a = a.prototype;
      return !(!a || !a.isReactComponent);
    }
    __name(bj, "bj");
    function $k(a) {
      if ("function" === typeof a) return bj(a) ? 1 : 0;
      if (void 0 !== a && null !== a) {
        a = a.$$typeof;
        if (a === Da) return 11;
        if (a === Ga) return 14;
      }
      return 2;
    }
    __name($k, "$k");
    function wh(a, b) {
      var c = a.alternate;
      null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
      c.flags = a.flags & 14680064;
      c.childLanes = a.childLanes;
      c.lanes = a.lanes;
      c.child = a.child;
      c.memoizedProps = a.memoizedProps;
      c.memoizedState = a.memoizedState;
      c.updateQueue = a.updateQueue;
      b = a.dependencies;
      c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
      c.sibling = a.sibling;
      c.index = a.index;
      c.ref = a.ref;
      return c;
    }
    __name(wh, "wh");
    function yh(a, b, c, d2, e, f) {
      var g = 2;
      d2 = a;
      if ("function" === typeof a) bj(a) && (g = 1);
      else if ("string" === typeof a) g = 5;
      else a: switch (a) {
        case ya:
          return Ah(c.children, e, f, b);
        case za:
          g = 8;
          e |= 8;
          break;
        case Aa:
          return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
        case Ea:
          return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
        case Fa:
          return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
        case Ia:
          return qj(c, e, f, b);
        default:
          if ("object" === typeof a && null !== a) switch (a.$$typeof) {
            case Ba:
              g = 10;
              break a;
            case Ca:
              g = 9;
              break a;
            case Da:
              g = 11;
              break a;
            case Ga:
              g = 14;
              break a;
            case Ha:
              g = 16;
              d2 = null;
              break a;
          }
          throw Error(p(130, null == a ? a : typeof a, ""));
      }
      b = Bg(g, c, b, e);
      b.elementType = a;
      b.type = d2;
      b.lanes = f;
      return b;
    }
    __name(yh, "yh");
    function Ah(a, b, c, d2) {
      a = Bg(7, a, d2, b);
      a.lanes = c;
      return a;
    }
    __name(Ah, "Ah");
    function qj(a, b, c, d2) {
      a = Bg(22, a, d2, b);
      a.elementType = Ia;
      a.lanes = c;
      a.stateNode = { isHidden: false };
      return a;
    }
    __name(qj, "qj");
    function xh(a, b, c) {
      a = Bg(6, a, null, b);
      a.lanes = c;
      return a;
    }
    __name(xh, "xh");
    function zh(a, b, c) {
      b = Bg(4, null !== a.children ? a.children : [], a.key, b);
      b.lanes = c;
      b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
      return b;
    }
    __name(zh, "zh");
    function bl(a, b, c, d2, e) {
      this.tag = b;
      this.containerInfo = a;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.pendingContext = this.context = null;
      this.callbackPriority = 0;
      this.eventTimes = zc(0);
      this.expirationTimes = zc(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = zc(0);
      this.identifierPrefix = d2;
      this.onRecoverableError = e;
      this.mutableSourceEagerHydrationData = null;
    }
    __name(bl, "bl");
    function cl(a, b, c, d2, e, f, g, h, k) {
      a = new bl(a, b, c, h, k);
      1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
      f = Bg(3, null, null, b);
      a.current = f;
      f.stateNode = a;
      f.memoizedState = { element: d2, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
      ah(f);
      return a;
    }
    __name(cl, "cl");
    function dl(a, b, c) {
      var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a, containerInfo: b, implementation: c };
    }
    __name(dl, "dl");
    function el(a) {
      if (!a) return Vf;
      a = a._reactInternals;
      a: {
        if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
        var b = a;
        do {
          switch (b.tag) {
            case 3:
              b = b.stateNode.context;
              break a;
            case 1:
              if (Zf(b.type)) {
                b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                break a;
              }
          }
          b = b.return;
        } while (null !== b);
        throw Error(p(171));
      }
      if (1 === a.tag) {
        var c = a.type;
        if (Zf(c)) return bg(a, c, b);
      }
      return b;
    }
    __name(el, "el");
    function fl2(a, b, c, d2, e, f, g, h, k) {
      a = cl(c, d2, true, a, e, f, g, h, k);
      a.context = el(null);
      c = a.current;
      d2 = L();
      e = lh(c);
      f = ch(d2, e);
      f.callback = void 0 !== b && null !== b ? b : null;
      dh(c, f, e);
      a.current.lanes = e;
      Ac(a, e, d2);
      Ek(a, d2);
      return a;
    }
    __name(fl2, "fl");
    function gl(a, b, c, d2) {
      var e = b.current, f = L(), g = lh(e);
      c = el(c);
      null === b.context ? b.context = c : b.pendingContext = c;
      b = ch(f, g);
      b.payload = { element: a };
      d2 = void 0 === d2 ? null : d2;
      null !== d2 && (b.callback = d2);
      a = dh(e, b, g);
      null !== a && (mh(a, e, g, f), eh(a, e, g));
      return g;
    }
    __name(gl, "gl");
    function hl(a) {
      a = a.current;
      if (!a.child) return null;
      switch (a.child.tag) {
        case 5:
          return a.child.stateNode;
        default:
          return a.child.stateNode;
      }
    }
    __name(hl, "hl");
    function il(a, b) {
      a = a.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        var c = a.retryLane;
        a.retryLane = 0 !== c && c < b ? c : b;
      }
    }
    __name(il, "il");
    function jl(a, b) {
      il(a, b);
      (a = a.alternate) && il(a, b);
    }
    __name(jl, "jl");
    function kl() {
      return null;
    }
    __name(kl, "kl");
    var ll = "function" === typeof reportError ? reportError : function(a) {
      console.error(a);
    };
    function ml(a) {
      this._internalRoot = a;
    }
    __name(ml, "ml");
    nl.prototype.render = ml.prototype.render = function(a) {
      var b = this._internalRoot;
      if (null === b) throw Error(p(409));
      gl(a, b, null, null);
    };
    nl.prototype.unmount = ml.prototype.unmount = function() {
      var a = this._internalRoot;
      if (null !== a) {
        this._internalRoot = null;
        var b = a.containerInfo;
        Sk(function() {
          gl(null, a, null, null);
        });
        b[uf] = null;
      }
    };
    function nl(a) {
      this._internalRoot = a;
    }
    __name(nl, "nl");
    nl.prototype.unstable_scheduleHydration = function(a) {
      if (a) {
        var b = Hc();
        a = { blockedOn: null, target: a, priority: b };
        for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) ;
        Qc.splice(c, 0, a);
        0 === c && Vc(a);
      }
    };
    function ol(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
    }
    __name(ol, "ol");
    function pl(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
    }
    __name(pl, "pl");
    function ql() {
    }
    __name(ql, "ql");
    function rl(a, b, c, d2, e) {
      if (e) {
        if ("function" === typeof d2) {
          var f = d2;
          d2 = /* @__PURE__ */ __name(function() {
            var a2 = hl(g);
            f.call(a2);
          }, "d");
        }
        var g = fl2(b, d2, a, 0, null, false, false, "", ql);
        a._reactRootContainer = g;
        a[uf] = g.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        Sk();
        return g;
      }
      for (; e = a.lastChild; ) a.removeChild(e);
      if ("function" === typeof d2) {
        var h = d2;
        d2 = /* @__PURE__ */ __name(function() {
          var a2 = hl(k);
          h.call(a2);
        }, "d");
      }
      var k = cl(a, 0, false, null, null, false, false, "", ql);
      a._reactRootContainer = k;
      a[uf] = k.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      Sk(function() {
        gl(b, k, c, d2);
      });
      return k;
    }
    __name(rl, "rl");
    function sl(a, b, c, d2, e) {
      var f = c._reactRootContainer;
      if (f) {
        var g = f;
        if ("function" === typeof e) {
          var h = e;
          e = /* @__PURE__ */ __name(function() {
            var a2 = hl(g);
            h.call(a2);
          }, "e");
        }
        gl(b, g, a, e);
      } else g = rl(c, b, a, e, d2);
      return hl(g);
    }
    __name(sl, "sl");
    Ec = /* @__PURE__ */ __name(function(a) {
      switch (a.tag) {
        case 3:
          var b = a.stateNode;
          if (b.current.memoizedState.isDehydrated) {
            var c = tc(b.pendingLanes);
            0 !== c && (Cc(b, c | 1), Ek(b, B()), 0 === (K & 6) && (Hj = B() + 500, jg()));
          }
          break;
        case 13:
          Sk(function() {
            var b2 = Zg(a, 1);
            if (null !== b2) {
              var c2 = L();
              mh(b2, a, 1, c2);
            }
          }), jl(a, 1);
      }
    }, "Ec");
    Fc = /* @__PURE__ */ __name(function(a) {
      if (13 === a.tag) {
        var b = Zg(a, 134217728);
        if (null !== b) {
          var c = L();
          mh(b, a, 134217728, c);
        }
        jl(a, 134217728);
      }
    }, "Fc");
    Gc = /* @__PURE__ */ __name(function(a) {
      if (13 === a.tag) {
        var b = lh(a), c = Zg(a, b);
        if (null !== c) {
          var d2 = L();
          mh(c, a, b, d2);
        }
        jl(a, b);
      }
    }, "Gc");
    Hc = /* @__PURE__ */ __name(function() {
      return C;
    }, "Hc");
    Ic = /* @__PURE__ */ __name(function(a, b) {
      var c = C;
      try {
        return C = a, b();
      } finally {
        C = c;
      }
    }, "Ic");
    yb = /* @__PURE__ */ __name(function(a, b, c) {
      switch (b) {
        case "input":
          bb(a, c);
          b = c.name;
          if ("radio" === c.type && null != b) {
            for (c = a; c.parentNode; ) c = c.parentNode;
            c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
            for (b = 0; b < c.length; b++) {
              var d2 = c[b];
              if (d2 !== a && d2.form === a.form) {
                var e = Db(d2);
                if (!e) throw Error(p(90));
                Wa(d2);
                bb(d2, e);
              }
            }
          }
          break;
        case "textarea":
          ib(a, c);
          break;
        case "select":
          b = c.value, null != b && fb(a, !!c.multiple, b, false);
      }
    }, "yb");
    Gb = Rk;
    Hb = Sk;
    var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] };
    var ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
    var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: /* @__PURE__ */ __name(function(a) {
      a = Zb(a);
      return null === a ? null : a.stateNode;
    }, "findHostInstanceByFiber"), findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!wl.isDisabled && wl.supportsFiber) try {
        kc = wl.inject(vl), lc = wl;
      } catch (a) {
      }
    }
    var wl;
    exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
    exports2.createPortal = function(a, b) {
      var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!ol(b)) throw Error(p(200));
      return dl(a, b, null, c);
    };
    exports2.createRoot = function(a, b) {
      if (!ol(a)) throw Error(p(299));
      var c = false, d2 = "", e = ll;
      null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d2 = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
      b = cl(a, 1, false, null, null, c, false, d2, e);
      a[uf] = b.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      return new ml(b);
    };
    exports2.findDOMNode = function(a) {
      if (null == a) return null;
      if (1 === a.nodeType) return a;
      var b = a._reactInternals;
      if (void 0 === b) {
        if ("function" === typeof a.render) throw Error(p(188));
        a = Object.keys(a).join(",");
        throw Error(p(268, a));
      }
      a = Zb(b);
      a = null === a ? null : a.stateNode;
      return a;
    };
    exports2.flushSync = function(a) {
      return Sk(a);
    };
    exports2.hydrate = function(a, b, c) {
      if (!pl(b)) throw Error(p(200));
      return sl(null, a, b, true, c);
    };
    exports2.hydrateRoot = function(a, b, c) {
      if (!ol(a)) throw Error(p(405));
      var d2 = null != c && c.hydratedSources || null, e = false, f = "", g = ll;
      null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
      b = fl2(b, null, a, 1, null != c ? c : null, e, false, f, g);
      a[uf] = b.current;
      sf(a);
      if (d2) for (a = 0; a < d2.length; a++) c = d2[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
        c,
        e
      );
      return new nl(b);
    };
    exports2.render = function(a, b, c) {
      if (!pl(b)) throw Error(p(200));
      return sl(null, a, b, false, c);
    };
    exports2.unmountComponentAtNode = function(a) {
      if (!pl(a)) throw Error(p(40));
      return a._reactRootContainer ? (Sk(function() {
        sl(null, null, a, false, function() {
          a._reactRootContainer = null;
          a[uf] = null;
        });
      }), true) : false;
    };
    exports2.unstable_batchedUpdates = Rk;
    exports2.unstable_renderSubtreeIntoContainer = function(a, b, c, d2) {
      if (!pl(c)) throw Error(p(200));
      if (null == a || void 0 === a._reactInternals) throw Error(p(38));
      return sl(a, b, c, false, d2);
    };
    exports2.version = "18.2.0-next-9e3b772b8-20220608";
  }
});

// node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "node_modules/react-dom/index.js"(exports2, module2) {
    "use strict";
    init_process_shim();
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      if (false) {
        throw new Error("^_^");
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err2) {
        console.error(err2);
      }
    }
    __name(checkDCE, "checkDCE");
    if (true) {
      checkDCE();
      module2.exports = require_react_dom_production_min();
    } else {
      module2.exports = null;
    }
  }
});

// node_modules/react-dom/client.js
var require_client = __commonJS({
  "node_modules/react-dom/client.js"(exports2) {
    "use strict";
    init_process_shim();
    var m = require_react_dom();
    if (true) {
      exports2.createRoot = m.createRoot;
      exports2.hydrateRoot = m.hydrateRoot;
    } else {
      i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      exports2.createRoot = function(c, o) {
        i.usingClientEntryPoint = true;
        try {
          return m.createRoot(c, o);
        } finally {
          i.usingClientEntryPoint = false;
        }
      };
      exports2.hydrateRoot = function(c, h, o) {
        i.usingClientEntryPoint = true;
        try {
          return m.hydrateRoot(c, h, o);
        } finally {
          i.usingClientEntryPoint = false;
        }
      };
    }
    var i;
  }
});

// node_modules/dexie/dist/dexie.js
var require_dexie = __commonJS({
  "node_modules/dexie/dist/dexie.js"(exports2, module2) {
    init_process_shim();
    (function(global3, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global3 = typeof globalThis !== "undefined" ? globalThis : global3 || self, global3.Dexie = factory());
    })(exports2, function() {
      "use strict";
      var extendStatics2 = /* @__PURE__ */ __name(function(d2, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
          d3.__proto__ = b2;
        } || function(d3, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d3[p] = b2[p];
        };
        return extendStatics2(d2, b);
      }, "extendStatics");
      function __extends2(d2, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d2, b);
        function __() {
          this.constructor = d2;
        }
        __name(__, "__");
        d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      }
      __name(__extends2, "__extends");
      var __assign = /* @__PURE__ */ __name(function() {
        __assign = Object.assign || /* @__PURE__ */ __name(function __assign2(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
        }, "__assign");
        return __assign.apply(this, arguments);
      }, "__assign");
      function __spreadArray2(to, from3, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from3.length, ar; i < l; i++) {
          if (ar || !(i in from3)) {
            if (!ar) ar = Array.prototype.slice.call(from3, 0, i);
            ar[i] = from3[i];
          }
        }
        return to.concat(ar || Array.prototype.slice.call(from3));
      }
      __name(__spreadArray2, "__spreadArray");
      var _global2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
      var keys3 = Object.keys;
      var isArray6 = Array.isArray;
      if (typeof Promise !== "undefined" && !_global2.Promise) {
        _global2.Promise = Promise;
      }
      function extend2(obj, extension) {
        if (typeof extension !== "object")
          return obj;
        keys3(extension).forEach(function(key) {
          obj[key] = extension[key];
        });
        return obj;
      }
      __name(extend2, "extend");
      var getProto = Object.getPrototypeOf;
      var _hasOwn = {}.hasOwnProperty;
      function hasOwn(obj, prop) {
        return _hasOwn.call(obj, prop);
      }
      __name(hasOwn, "hasOwn");
      function props(proto, extension) {
        if (typeof extension === "function")
          extension = extension(getProto(proto));
        (typeof Reflect === "undefined" ? keys3 : Reflect.ownKeys)(extension).forEach(function(key) {
          setProp(proto, key, extension[key]);
        });
      }
      __name(props, "props");
      var defineProperty2 = Object.defineProperty;
      function setProp(obj, prop, functionOrGetSet, options) {
        defineProperty2(obj, prop, extend2(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === "function" ? { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } : { value: functionOrGetSet, configurable: true, writable: true }, options));
      }
      __name(setProp, "setProp");
      function derive(Child) {
        return {
          from: /* @__PURE__ */ __name(function(Parent) {
            Child.prototype = Object.create(Parent.prototype);
            setProp(Child.prototype, "constructor", Child);
            return {
              extend: props.bind(null, Child.prototype)
            };
          }, "from")
        };
      }
      __name(derive, "derive");
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      function getPropertyDescriptor(obj, prop) {
        var pd = getOwnPropertyDescriptor(obj, prop);
        var proto;
        return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
      }
      __name(getPropertyDescriptor, "getPropertyDescriptor");
      var _slice = [].slice;
      function slice(args2, start, end) {
        return _slice.call(args2, start, end);
      }
      __name(slice, "slice");
      function override(origFunc, overridedFactory) {
        return overridedFactory(origFunc);
      }
      __name(override, "override");
      function assert(b) {
        if (!b)
          throw new Error("Assertion Failed");
      }
      __name(assert, "assert");
      function asap$1(fn) {
        if (_global2.setImmediate)
          setImmediate(fn);
        else
          setTimeout(fn, 0);
      }
      __name(asap$1, "asap$1");
      function arrayToObject2(array, extractor) {
        return array.reduce(function(result, item, i) {
          var nameAndValue = extractor(item, i);
          if (nameAndValue)
            result[nameAndValue[0]] = nameAndValue[1];
          return result;
        }, {});
      }
      __name(arrayToObject2, "arrayToObject");
      function getByKeyPath(obj, keyPath) {
        if (typeof keyPath === "string" && hasOwn(obj, keyPath))
          return obj[keyPath];
        if (!keyPath)
          return obj;
        if (typeof keyPath !== "string") {
          var rv = [];
          for (var i = 0, l = keyPath.length; i < l; ++i) {
            var val = getByKeyPath(obj, keyPath[i]);
            rv.push(val);
          }
          return rv;
        }
        var period = keyPath.indexOf(".");
        if (period !== -1) {
          var innerObj = obj[keyPath.substr(0, period)];
          return innerObj == null ? void 0 : getByKeyPath(innerObj, keyPath.substr(period + 1));
        }
        return void 0;
      }
      __name(getByKeyPath, "getByKeyPath");
      function setByKeyPath(obj, keyPath, value) {
        if (!obj || keyPath === void 0)
          return;
        if ("isFrozen" in Object && Object.isFrozen(obj))
          return;
        if (typeof keyPath !== "string" && "length" in keyPath) {
          assert(typeof value !== "string" && "length" in value);
          for (var i = 0, l = keyPath.length; i < l; ++i) {
            setByKeyPath(obj, keyPath[i], value[i]);
          }
        } else {
          var period = keyPath.indexOf(".");
          if (period !== -1) {
            var currentKeyPath = keyPath.substr(0, period);
            var remainingKeyPath = keyPath.substr(period + 1);
            if (remainingKeyPath === "")
              if (value === void 0) {
                if (isArray6(obj) && !isNaN(parseInt(currentKeyPath)))
                  obj.splice(currentKeyPath, 1);
                else
                  delete obj[currentKeyPath];
              } else
                obj[currentKeyPath] = value;
            else {
              var innerObj = obj[currentKeyPath];
              if (!innerObj || !hasOwn(obj, currentKeyPath))
                innerObj = obj[currentKeyPath] = {};
              setByKeyPath(innerObj, remainingKeyPath, value);
            }
          } else {
            if (value === void 0) {
              if (isArray6(obj) && !isNaN(parseInt(keyPath)))
                obj.splice(keyPath, 1);
              else
                delete obj[keyPath];
            } else
              obj[keyPath] = value;
          }
        }
      }
      __name(setByKeyPath, "setByKeyPath");
      function delByKeyPath(obj, keyPath) {
        if (typeof keyPath === "string")
          setByKeyPath(obj, keyPath, void 0);
        else if ("length" in keyPath)
          [].map.call(keyPath, function(kp) {
            setByKeyPath(obj, kp, void 0);
          });
      }
      __name(delByKeyPath, "delByKeyPath");
      function shallowClone(obj) {
        var rv = {};
        for (var m in obj) {
          if (hasOwn(obj, m))
            rv[m] = obj[m];
        }
        return rv;
      }
      __name(shallowClone, "shallowClone");
      var concat = [].concat;
      function flatten(a) {
        return concat.apply([], a);
      }
      __name(flatten, "flatten");
      var intrinsicTypeNames = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(flatten([8, 16, 32, 64].map(function(num) {
        return ["Int", "Uint", "Float"].map(function(t) {
          return t + num + "Array";
        });
      }))).filter(function(t) {
        return _global2[t];
      });
      var intrinsicTypes = new Set(intrinsicTypeNames.map(function(t) {
        return _global2[t];
      }));
      function cloneSimpleObjectTree(o) {
        var rv = {};
        for (var k in o)
          if (hasOwn(o, k)) {
            var v = o[k];
            rv[k] = !v || typeof v !== "object" || intrinsicTypes.has(v.constructor) ? v : cloneSimpleObjectTree(v);
          }
        return rv;
      }
      __name(cloneSimpleObjectTree, "cloneSimpleObjectTree");
      function objectIsEmpty(o) {
        for (var k in o)
          if (hasOwn(o, k))
            return false;
        return true;
      }
      __name(objectIsEmpty, "objectIsEmpty");
      var circularRefs = null;
      function deepClone(any2) {
        circularRefs = /* @__PURE__ */ new WeakMap();
        var rv = innerDeepClone(any2);
        circularRefs = null;
        return rv;
      }
      __name(deepClone, "deepClone");
      function innerDeepClone(x) {
        if (!x || typeof x !== "object")
          return x;
        var rv = circularRefs.get(x);
        if (rv)
          return rv;
        if (isArray6(x)) {
          rv = [];
          circularRefs.set(x, rv);
          for (var i = 0, l = x.length; i < l; ++i) {
            rv.push(innerDeepClone(x[i]));
          }
        } else if (intrinsicTypes.has(x.constructor)) {
          rv = x;
        } else {
          var proto = getProto(x);
          rv = proto === Object.prototype ? {} : Object.create(proto);
          circularRefs.set(x, rv);
          for (var prop in x) {
            if (hasOwn(x, prop)) {
              rv[prop] = innerDeepClone(x[prop]);
            }
          }
        }
        return rv;
      }
      __name(innerDeepClone, "innerDeepClone");
      var toString4 = {}.toString;
      function toStringTag2(o) {
        return toString4.call(o).slice(8, -1);
      }
      __name(toStringTag2, "toStringTag");
      var iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
      var getIteratorOf = typeof iteratorSymbol === "symbol" ? function(x) {
        var i;
        return x != null && (i = x[iteratorSymbol]) && i.apply(x);
      } : function() {
        return null;
      };
      function delArrayItem(a, x) {
        var i = a.indexOf(x);
        if (i >= 0)
          a.splice(i, 1);
        return i >= 0;
      }
      __name(delArrayItem, "delArrayItem");
      var NO_CHAR_ARRAY = {};
      function getArrayOf(arrayLike) {
        var i, a, x, it;
        if (arguments.length === 1) {
          if (isArray6(arrayLike))
            return arrayLike.slice();
          if (this === NO_CHAR_ARRAY && typeof arrayLike === "string")
            return [arrayLike];
          if (it = getIteratorOf(arrayLike)) {
            a = [];
            while (x = it.next(), !x.done)
              a.push(x.value);
            return a;
          }
          if (arrayLike == null)
            return [arrayLike];
          i = arrayLike.length;
          if (typeof i === "number") {
            a = new Array(i);
            while (i--)
              a[i] = arrayLike[i];
            return a;
          }
          return [arrayLike];
        }
        i = arguments.length;
        a = new Array(i);
        while (i--)
          a[i] = arguments[i];
        return a;
      }
      __name(getArrayOf, "getArrayOf");
      var isAsyncFunction = typeof Symbol !== "undefined" ? function(fn) {
        return fn[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return false;
      };
      var dexieErrorNames = [
        "Modify",
        "Bulk",
        "OpenFailed",
        "VersionChange",
        "Schema",
        "Upgrade",
        "InvalidTable",
        "MissingAPI",
        "NoSuchDatabase",
        "InvalidArgument",
        "SubTransaction",
        "Unsupported",
        "Internal",
        "DatabaseClosed",
        "PrematureCommit",
        "ForeignAwait"
      ];
      var idbDomErrorNames = [
        "Unknown",
        "Constraint",
        "Data",
        "TransactionInactive",
        "ReadOnly",
        "Version",
        "NotFound",
        "InvalidState",
        "InvalidAccess",
        "Abort",
        "Timeout",
        "QuotaExceeded",
        "Syntax",
        "DataClone"
      ];
      var errorList = dexieErrorNames.concat(idbDomErrorNames);
      var defaultTexts = {
        VersionChanged: "Database version changed by other database connection",
        DatabaseClosed: "Database has been closed",
        Abort: "Transaction aborted",
        TransactionInactive: "Transaction has already completed or failed",
        MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
      };
      function DexieError(name, msg) {
        this.name = name;
        this.message = msg;
      }
      __name(DexieError, "DexieError");
      derive(DexieError).from(Error).extend({
        toString: /* @__PURE__ */ __name(function() {
          return this.name + ": " + this.message;
        }, "toString")
      });
      function getMultiErrorMessage(msg, failures) {
        return msg + ". Errors: " + Object.keys(failures).map(function(key) {
          return failures[key].toString();
        }).filter(function(v, i, s) {
          return s.indexOf(v) === i;
        }).join("\n");
      }
      __name(getMultiErrorMessage, "getMultiErrorMessage");
      function ModifyError(msg, failures, successCount, failedKeys) {
        this.failures = failures;
        this.failedKeys = failedKeys;
        this.successCount = successCount;
        this.message = getMultiErrorMessage(msg, failures);
      }
      __name(ModifyError, "ModifyError");
      derive(ModifyError).from(DexieError);
      function BulkError(msg, failures) {
        this.name = "BulkError";
        this.failures = Object.keys(failures).map(function(pos) {
          return failures[pos];
        });
        this.failuresByPos = failures;
        this.message = getMultiErrorMessage(msg, this.failures);
      }
      __name(BulkError, "BulkError");
      derive(BulkError).from(DexieError);
      var errnames = errorList.reduce(function(obj, name) {
        return obj[name] = name + "Error", obj;
      }, {});
      var BaseException = DexieError;
      var exceptions = errorList.reduce(function(obj, name) {
        var fullName = name + "Error";
        function DexieError2(msgOrInner, inner) {
          this.name = fullName;
          if (!msgOrInner) {
            this.message = defaultTexts[name] || fullName;
            this.inner = null;
          } else if (typeof msgOrInner === "string") {
            this.message = "".concat(msgOrInner).concat(!inner ? "" : "\n " + inner);
            this.inner = inner || null;
          } else if (typeof msgOrInner === "object") {
            this.message = "".concat(msgOrInner.name, " ").concat(msgOrInner.message);
            this.inner = msgOrInner;
          }
        }
        __name(DexieError2, "DexieError");
        derive(DexieError2).from(BaseException);
        obj[name] = DexieError2;
        return obj;
      }, {});
      exceptions.Syntax = SyntaxError;
      exceptions.Type = TypeError;
      exceptions.Range = RangeError;
      var exceptionMap = idbDomErrorNames.reduce(function(obj, name) {
        obj[name + "Error"] = exceptions[name];
        return obj;
      }, {});
      function mapError(domError, message) {
        if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])
          return domError;
        var rv = new exceptionMap[domError.name](message || domError.message, domError);
        if ("stack" in domError) {
          setProp(rv, "stack", { get: /* @__PURE__ */ __name(function() {
            return this.inner.stack;
          }, "get") });
        }
        return rv;
      }
      __name(mapError, "mapError");
      var fullNameExceptions = errorList.reduce(function(obj, name) {
        if (["Syntax", "Type", "Range"].indexOf(name) === -1)
          obj[name + "Error"] = exceptions[name];
        return obj;
      }, {});
      fullNameExceptions.ModifyError = ModifyError;
      fullNameExceptions.DexieError = DexieError;
      fullNameExceptions.BulkError = BulkError;
      function nop() {
      }
      __name(nop, "nop");
      function mirror(val) {
        return val;
      }
      __name(mirror, "mirror");
      function pureFunctionChain(f1, f2) {
        if (f1 == null || f1 === mirror)
          return f2;
        return function(val) {
          return f2(f1(val));
        };
      }
      __name(pureFunctionChain, "pureFunctionChain");
      function callBoth(on1, on2) {
        return function() {
          on1.apply(this, arguments);
          on2.apply(this, arguments);
        };
      }
      __name(callBoth, "callBoth");
      function hookCreatingChain(f1, f2) {
        if (f1 === nop)
          return f2;
        return function() {
          var res = f1.apply(this, arguments);
          if (res !== void 0)
            arguments[0] = res;
          var onsuccess = this.onsuccess, onerror = this.onerror;
          this.onsuccess = null;
          this.onerror = null;
          var res2 = f2.apply(this, arguments);
          if (onsuccess)
            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
          if (onerror)
            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
          return res2 !== void 0 ? res2 : res;
        };
      }
      __name(hookCreatingChain, "hookCreatingChain");
      function hookDeletingChain(f1, f2) {
        if (f1 === nop)
          return f2;
        return function() {
          f1.apply(this, arguments);
          var onsuccess = this.onsuccess, onerror = this.onerror;
          this.onsuccess = this.onerror = null;
          f2.apply(this, arguments);
          if (onsuccess)
            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
          if (onerror)
            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
        };
      }
      __name(hookDeletingChain, "hookDeletingChain");
      function hookUpdatingChain(f1, f2) {
        if (f1 === nop)
          return f2;
        return function(modifications) {
          var res = f1.apply(this, arguments);
          extend2(modifications, res);
          var onsuccess = this.onsuccess, onerror = this.onerror;
          this.onsuccess = null;
          this.onerror = null;
          var res2 = f2.apply(this, arguments);
          if (onsuccess)
            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
          if (onerror)
            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
          return res === void 0 ? res2 === void 0 ? void 0 : res2 : extend2(res, res2);
        };
      }
      __name(hookUpdatingChain, "hookUpdatingChain");
      function reverseStoppableEventChain(f1, f2) {
        if (f1 === nop)
          return f2;
        return function() {
          if (f2.apply(this, arguments) === false)
            return false;
          return f1.apply(this, arguments);
        };
      }
      __name(reverseStoppableEventChain, "reverseStoppableEventChain");
      function promisableChain(f1, f2) {
        if (f1 === nop)
          return f2;
        return function() {
          var res = f1.apply(this, arguments);
          if (res && typeof res.then === "function") {
            var thiz = this, i = arguments.length, args2 = new Array(i);
            while (i--)
              args2[i] = arguments[i];
            return res.then(function() {
              return f2.apply(thiz, args2);
            });
          }
          return f2.apply(this, arguments);
        };
      }
      __name(promisableChain, "promisableChain");
      var debug23 = typeof location !== "undefined" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function setDebug(value, filter2) {
        debug23 = value;
      }
      __name(setDebug, "setDebug");
      var INTERNAL = {};
      var ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === "undefined" ? [] : function() {
        var globalP = Promise.resolve();
        if (typeof crypto === "undefined" || !crypto.subtle)
          return [globalP, getProto(globalP), globalP];
        var nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [
          nativeP,
          getProto(nativeP),
          globalP
        ];
      }(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
      var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
      var patchGlobalPromise = !!resolvedGlobalPromise;
      function schedulePhysicalTick() {
        queueMicrotask(physicalTick);
      }
      __name(schedulePhysicalTick, "schedulePhysicalTick");
      var asap2 = /* @__PURE__ */ __name(function(callback, args2) {
        microtickQueue.push([callback, args2]);
        if (needsNewPhysicalTick) {
          schedulePhysicalTick();
          needsNewPhysicalTick = false;
        }
      }, "asap");
      var isOutsideMicroTick = true, needsNewPhysicalTick = true, unhandledErrors = [], rejectingErrors = [], rejectionMapper = mirror;
      var globalPSD = {
        id: "global",
        global: true,
        ref: 0,
        unhandleds: [],
        onunhandled: nop,
        pgp: false,
        env: {},
        finalize: nop
      };
      var PSD = globalPSD;
      var microtickQueue = [];
      var numScheduledCalls = 0;
      var tickFinalizers = [];
      function DexiePromise(fn) {
        if (typeof this !== "object")
          throw new TypeError("Promises must be constructed via new");
        this._listeners = [];
        this._lib = false;
        var psd = this._PSD = PSD;
        if (typeof fn !== "function") {
          if (fn !== INTERNAL)
            throw new TypeError("Not a function");
          this._state = arguments[1];
          this._value = arguments[2];
          if (this._state === false)
            handleRejection(this, this._value);
          return;
        }
        this._state = null;
        this._value = null;
        ++psd.ref;
        executePromiseTask(this, fn);
      }
      __name(DexiePromise, "DexiePromise");
      var thenProp = {
        get: /* @__PURE__ */ __name(function() {
          var psd = PSD, microTaskId = totalEchoes;
          function then(onFulfilled, onRejected) {
            var _this = this;
            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
            var cleanup = possibleAwait && !decrementExpectedAwaits();
            var rv = new DexiePromise(function(resolve, reject) {
              propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));
            });
            if (this._consoleTask)
              rv._consoleTask = this._consoleTask;
            return rv;
          }
          __name(then, "then");
          then.prototype = INTERNAL;
          return then;
        }, "get"),
        set: /* @__PURE__ */ __name(function(value) {
          setProp(this, "then", value && value.prototype === INTERNAL ? thenProp : {
            get: /* @__PURE__ */ __name(function() {
              return value;
            }, "get"),
            set: thenProp.set
          });
        }, "set")
      };
      props(DexiePromise.prototype, {
        then: thenProp,
        _then: /* @__PURE__ */ __name(function(onFulfilled, onRejected) {
          propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
        }, "_then"),
        catch: /* @__PURE__ */ __name(function(onRejected) {
          if (arguments.length === 1)
            return this.then(null, onRejected);
          var type2 = arguments[0], handler = arguments[1];
          return typeof type2 === "function" ? this.then(null, function(err2) {
            return err2 instanceof type2 ? handler(err2) : PromiseReject(err2);
          }) : this.then(null, function(err2) {
            return err2 && err2.name === type2 ? handler(err2) : PromiseReject(err2);
          });
        }, "catch"),
        finally: /* @__PURE__ */ __name(function(onFinally) {
          return this.then(function(value) {
            return DexiePromise.resolve(onFinally()).then(function() {
              return value;
            });
          }, function(err2) {
            return DexiePromise.resolve(onFinally()).then(function() {
              return PromiseReject(err2);
            });
          });
        }, "finally"),
        timeout: /* @__PURE__ */ __name(function(ms2, msg) {
          var _this = this;
          return ms2 < Infinity ? new DexiePromise(function(resolve, reject) {
            var handle = setTimeout(function() {
              return reject(new exceptions.Timeout(msg));
            }, ms2);
            _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));
          }) : this;
        }, "timeout")
      });
      if (typeof Symbol !== "undefined" && Symbol.toStringTag)
        setProp(DexiePromise.prototype, Symbol.toStringTag, "Dexie.Promise");
      globalPSD.env = snapShot();
      function Listener(onFulfilled, onRejected, resolve, reject, zone) {
        this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
        this.onRejected = typeof onRejected === "function" ? onRejected : null;
        this.resolve = resolve;
        this.reject = reject;
        this.psd = zone;
      }
      __name(Listener, "Listener");
      props(DexiePromise, {
        all: /* @__PURE__ */ __name(function() {
          var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
          return new DexiePromise(function(resolve, reject) {
            if (values.length === 0)
              resolve([]);
            var remaining = values.length;
            values.forEach(function(a, i) {
              return DexiePromise.resolve(a).then(function(x) {
                values[i] = x;
                if (!--remaining)
                  resolve(values);
              }, reject);
            });
          });
        }, "all"),
        resolve: /* @__PURE__ */ __name(function(value) {
          if (value instanceof DexiePromise)
            return value;
          if (value && typeof value.then === "function")
            return new DexiePromise(function(resolve, reject) {
              value.then(resolve, reject);
            });
          var rv = new DexiePromise(INTERNAL, true, value);
          return rv;
        }, "resolve"),
        reject: PromiseReject,
        race: /* @__PURE__ */ __name(function() {
          var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
          return new DexiePromise(function(resolve, reject) {
            values.map(function(value) {
              return DexiePromise.resolve(value).then(resolve, reject);
            });
          });
        }, "race"),
        PSD: {
          get: /* @__PURE__ */ __name(function() {
            return PSD;
          }, "get"),
          set: /* @__PURE__ */ __name(function(value) {
            return PSD = value;
          }, "set")
        },
        totalEchoes: { get: /* @__PURE__ */ __name(function() {
          return totalEchoes;
        }, "get") },
        newPSD: newScope,
        usePSD,
        scheduler: {
          get: /* @__PURE__ */ __name(function() {
            return asap2;
          }, "get"),
          set: /* @__PURE__ */ __name(function(value) {
            asap2 = value;
          }, "set")
        },
        rejectionMapper: {
          get: /* @__PURE__ */ __name(function() {
            return rejectionMapper;
          }, "get"),
          set: /* @__PURE__ */ __name(function(value) {
            rejectionMapper = value;
          }, "set")
        },
        follow: /* @__PURE__ */ __name(function(fn, zoneProps) {
          return new DexiePromise(function(resolve, reject) {
            return newScope(function(resolve2, reject2) {
              var psd = PSD;
              psd.unhandleds = [];
              psd.onunhandled = reject2;
              psd.finalize = callBoth(function() {
                var _this = this;
                run_at_end_of_this_or_next_physical_tick(function() {
                  _this.unhandleds.length === 0 ? resolve2() : reject2(_this.unhandleds[0]);
                });
              }, psd.finalize);
              fn();
            }, zoneProps, resolve, reject);
          });
        }, "follow")
      });
      if (NativePromise) {
        if (NativePromise.allSettled)
          setProp(DexiePromise, "allSettled", function() {
            var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(function(resolve) {
              if (possiblePromises.length === 0)
                resolve([]);
              var remaining = possiblePromises.length;
              var results = new Array(remaining);
              possiblePromises.forEach(function(p, i) {
                return DexiePromise.resolve(p).then(function(value) {
                  return results[i] = { status: "fulfilled", value };
                }, function(reason) {
                  return results[i] = { status: "rejected", reason };
                }).then(function() {
                  return --remaining || resolve(results);
                });
              });
            });
          });
        if (NativePromise.any && typeof AggregateError !== "undefined")
          setProp(DexiePromise, "any", function() {
            var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(function(resolve, reject) {
              if (possiblePromises.length === 0)
                reject(new AggregateError([]));
              var remaining = possiblePromises.length;
              var failures = new Array(remaining);
              possiblePromises.forEach(function(p, i) {
                return DexiePromise.resolve(p).then(function(value) {
                  return resolve(value);
                }, function(failure) {
                  failures[i] = failure;
                  if (!--remaining)
                    reject(new AggregateError(failures));
                });
              });
            });
          });
        if (NativePromise.withResolvers)
          DexiePromise.withResolvers = NativePromise.withResolvers;
      }
      function executePromiseTask(promise, fn) {
        try {
          fn(function(value) {
            if (promise._state !== null)
              return;
            if (value === promise)
              throw new TypeError("A promise cannot be resolved with itself.");
            var shouldExecuteTick = promise._lib && beginMicroTickScope();
            if (value && typeof value.then === "function") {
              executePromiseTask(promise, function(resolve, reject) {
                value instanceof DexiePromise ? value._then(resolve, reject) : value.then(resolve, reject);
              });
            } else {
              promise._state = true;
              promise._value = value;
              propagateAllListeners(promise);
            }
            if (shouldExecuteTick)
              endMicroTickScope();
          }, handleRejection.bind(null, promise));
        } catch (ex) {
          handleRejection(promise, ex);
        }
      }
      __name(executePromiseTask, "executePromiseTask");
      function handleRejection(promise, reason) {
        rejectingErrors.push(reason);
        if (promise._state !== null)
          return;
        var shouldExecuteTick = promise._lib && beginMicroTickScope();
        reason = rejectionMapper(reason);
        promise._state = false;
        promise._value = reason;
        addPossiblyUnhandledError(promise);
        propagateAllListeners(promise);
        if (shouldExecuteTick)
          endMicroTickScope();
      }
      __name(handleRejection, "handleRejection");
      function propagateAllListeners(promise) {
        var listeners = promise._listeners;
        promise._listeners = [];
        for (var i = 0, len = listeners.length; i < len; ++i) {
          propagateToListener(promise, listeners[i]);
        }
        var psd = promise._PSD;
        --psd.ref || psd.finalize();
        if (numScheduledCalls === 0) {
          ++numScheduledCalls;
          asap2(function() {
            if (--numScheduledCalls === 0)
              finalizePhysicalTick();
          }, []);
        }
      }
      __name(propagateAllListeners, "propagateAllListeners");
      function propagateToListener(promise, listener) {
        if (promise._state === null) {
          promise._listeners.push(listener);
          return;
        }
        var cb = promise._state ? listener.onFulfilled : listener.onRejected;
        if (cb === null) {
          return (promise._state ? listener.resolve : listener.reject)(promise._value);
        }
        ++listener.psd.ref;
        ++numScheduledCalls;
        asap2(callListener, [cb, promise, listener]);
      }
      __name(propagateToListener, "propagateToListener");
      function callListener(cb, promise, listener) {
        try {
          var ret, value = promise._value;
          if (!promise._state && rejectingErrors.length)
            rejectingErrors = [];
          ret = debug23 && promise._consoleTask ? promise._consoleTask.run(function() {
            return cb(value);
          }) : cb(value);
          if (!promise._state && rejectingErrors.indexOf(value) === -1) {
            markErrorAsHandled(promise);
          }
          listener.resolve(ret);
        } catch (e) {
          listener.reject(e);
        } finally {
          if (--numScheduledCalls === 0)
            finalizePhysicalTick();
          --listener.psd.ref || listener.psd.finalize();
        }
      }
      __name(callListener, "callListener");
      function physicalTick() {
        usePSD(globalPSD, function() {
          beginMicroTickScope() && endMicroTickScope();
        });
      }
      __name(physicalTick, "physicalTick");
      function beginMicroTickScope() {
        var wasRootExec = isOutsideMicroTick;
        isOutsideMicroTick = false;
        needsNewPhysicalTick = false;
        return wasRootExec;
      }
      __name(beginMicroTickScope, "beginMicroTickScope");
      function endMicroTickScope() {
        var callbacks, i, l;
        do {
          while (microtickQueue.length > 0) {
            callbacks = microtickQueue;
            microtickQueue = [];
            l = callbacks.length;
            for (i = 0; i < l; ++i) {
              var item = callbacks[i];
              item[0].apply(null, item[1]);
            }
          }
        } while (microtickQueue.length > 0);
        isOutsideMicroTick = true;
        needsNewPhysicalTick = true;
      }
      __name(endMicroTickScope, "endMicroTickScope");
      function finalizePhysicalTick() {
        var unhandledErrs = unhandledErrors;
        unhandledErrors = [];
        unhandledErrs.forEach(function(p) {
          p._PSD.onunhandled.call(null, p._value, p);
        });
        var finalizers = tickFinalizers.slice(0);
        var i = finalizers.length;
        while (i)
          finalizers[--i]();
      }
      __name(finalizePhysicalTick, "finalizePhysicalTick");
      function run_at_end_of_this_or_next_physical_tick(fn) {
        function finalizer() {
          fn();
          tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
        }
        __name(finalizer, "finalizer");
        tickFinalizers.push(finalizer);
        ++numScheduledCalls;
        asap2(function() {
          if (--numScheduledCalls === 0)
            finalizePhysicalTick();
        }, []);
      }
      __name(run_at_end_of_this_or_next_physical_tick, "run_at_end_of_this_or_next_physical_tick");
      function addPossiblyUnhandledError(promise) {
        if (!unhandledErrors.some(function(p) {
          return p._value === promise._value;
        }))
          unhandledErrors.push(promise);
      }
      __name(addPossiblyUnhandledError, "addPossiblyUnhandledError");
      function markErrorAsHandled(promise) {
        var i = unhandledErrors.length;
        while (i)
          if (unhandledErrors[--i]._value === promise._value) {
            unhandledErrors.splice(i, 1);
            return;
          }
      }
      __name(markErrorAsHandled, "markErrorAsHandled");
      function PromiseReject(reason) {
        return new DexiePromise(INTERNAL, false, reason);
      }
      __name(PromiseReject, "PromiseReject");
      function wrap(fn, errorCatcher) {
        var psd = PSD;
        return function() {
          var wasRootExec = beginMicroTickScope(), outerScope = PSD;
          try {
            switchToZone(psd, true);
            return fn.apply(this, arguments);
          } catch (e) {
            errorCatcher && errorCatcher(e);
          } finally {
            switchToZone(outerScope, false);
            if (wasRootExec)
              endMicroTickScope();
          }
        };
      }
      __name(wrap, "wrap");
      var task = { awaits: 0, echoes: 0, id: 0 };
      var taskCounter = 0;
      var zoneStack = [];
      var zoneEchoes = 0;
      var totalEchoes = 0;
      var zone_id_counter = 0;
      function newScope(fn, props2, a1, a2) {
        var parent = PSD, psd = Object.create(parent);
        psd.parent = parent;
        psd.ref = 0;
        psd.global = false;
        psd.id = ++zone_id_counter;
        globalPSD.env;
        psd.env = patchGlobalPromise ? {
          Promise: DexiePromise,
          PromiseProp: { value: DexiePromise, configurable: true, writable: true },
          all: DexiePromise.all,
          race: DexiePromise.race,
          allSettled: DexiePromise.allSettled,
          any: DexiePromise.any,
          resolve: DexiePromise.resolve,
          reject: DexiePromise.reject
        } : {};
        if (props2)
          extend2(psd, props2);
        ++parent.ref;
        psd.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        };
        var rv = usePSD(psd, fn, a1, a2);
        if (psd.ref === 0)
          psd.finalize();
        return rv;
      }
      __name(newScope, "newScope");
      function incrementExpectedAwaits() {
        if (!task.id)
          task.id = ++taskCounter;
        ++task.awaits;
        task.echoes += ZONE_ECHO_LIMIT;
        return task.id;
      }
      __name(incrementExpectedAwaits, "incrementExpectedAwaits");
      function decrementExpectedAwaits() {
        if (!task.awaits)
          return false;
        if (--task.awaits === 0)
          task.id = 0;
        task.echoes = task.awaits * ZONE_ECHO_LIMIT;
        return true;
      }
      __name(decrementExpectedAwaits, "decrementExpectedAwaits");
      if (("" + nativePromiseThen).indexOf("[native code]") === -1) {
        incrementExpectedAwaits = decrementExpectedAwaits = nop;
      }
      function onPossibleParallellAsync(possiblePromise) {
        if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
          incrementExpectedAwaits();
          return possiblePromise.then(function(x) {
            decrementExpectedAwaits();
            return x;
          }, function(e) {
            decrementExpectedAwaits();
            return rejection(e);
          });
        }
        return possiblePromise;
      }
      __name(onPossibleParallellAsync, "onPossibleParallellAsync");
      function zoneEnterEcho(targetZone) {
        ++totalEchoes;
        if (!task.echoes || --task.echoes === 0) {
          task.echoes = task.awaits = task.id = 0;
        }
        zoneStack.push(PSD);
        switchToZone(targetZone, true);
      }
      __name(zoneEnterEcho, "zoneEnterEcho");
      function zoneLeaveEcho() {
        var zone = zoneStack[zoneStack.length - 1];
        zoneStack.pop();
        switchToZone(zone, false);
      }
      __name(zoneLeaveEcho, "zoneLeaveEcho");
      function switchToZone(targetZone, bEnteringZone) {
        var currentZone = PSD;
        if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {
          queueMicrotask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
        }
        if (targetZone === PSD)
          return;
        PSD = targetZone;
        if (currentZone === globalPSD)
          globalPSD.env = snapShot();
        if (patchGlobalPromise) {
          var GlobalPromise = globalPSD.env.Promise;
          var targetEnv = targetZone.env;
          if (currentZone.global || targetZone.global) {
            Object.defineProperty(_global2, "Promise", targetEnv.PromiseProp);
            GlobalPromise.all = targetEnv.all;
            GlobalPromise.race = targetEnv.race;
            GlobalPromise.resolve = targetEnv.resolve;
            GlobalPromise.reject = targetEnv.reject;
            if (targetEnv.allSettled)
              GlobalPromise.allSettled = targetEnv.allSettled;
            if (targetEnv.any)
              GlobalPromise.any = targetEnv.any;
          }
        }
      }
      __name(switchToZone, "switchToZone");
      function snapShot() {
        var GlobalPromise = _global2.Promise;
        return patchGlobalPromise ? {
          Promise: GlobalPromise,
          PromiseProp: Object.getOwnPropertyDescriptor(_global2, "Promise"),
          all: GlobalPromise.all,
          race: GlobalPromise.race,
          allSettled: GlobalPromise.allSettled,
          any: GlobalPromise.any,
          resolve: GlobalPromise.resolve,
          reject: GlobalPromise.reject
        } : {};
      }
      __name(snapShot, "snapShot");
      function usePSD(psd, fn, a1, a2, a3) {
        var outerScope = PSD;
        try {
          switchToZone(psd, true);
          return fn(a1, a2, a3);
        } finally {
          switchToZone(outerScope, false);
        }
      }
      __name(usePSD, "usePSD");
      function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {
        return typeof fn !== "function" ? fn : function() {
          var outerZone = PSD;
          if (possibleAwait)
            incrementExpectedAwaits();
          switchToZone(zone, true);
          try {
            return fn.apply(this, arguments);
          } finally {
            switchToZone(outerZone, false);
            if (cleanup)
              queueMicrotask(decrementExpectedAwaits);
          }
        };
      }
      __name(nativeAwaitCompatibleWrap, "nativeAwaitCompatibleWrap");
      function execInGlobalContext(cb) {
        if (Promise === NativePromise && task.echoes === 0) {
          if (zoneEchoes === 0) {
            cb();
          } else {
            enqueueNativeMicroTask(cb);
          }
        } else {
          setTimeout(cb, 0);
        }
      }
      __name(execInGlobalContext, "execInGlobalContext");
      var rejection = DexiePromise.reject;
      function tempTransaction(db, mode, storeNames, fn) {
        if (!db.idbdb || !db._state.openComplete && (!PSD.letThrough && !db._vip)) {
          if (db._state.openComplete) {
            return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));
          }
          if (!db._state.isBeingOpened) {
            if (!db._state.autoOpen)
              return rejection(new exceptions.DatabaseClosed());
            db.open().catch(nop);
          }
          return db._state.dbReadyPromise.then(function() {
            return tempTransaction(db, mode, storeNames, fn);
          });
        } else {
          var trans = db._createTransaction(mode, storeNames, db._dbSchema);
          try {
            trans.create();
            db._state.PR1398_maxLoop = 3;
          } catch (ex) {
            if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
              console.warn("Dexie: Need to reopen db");
              db.close({ disableAutoOpen: false });
              return db.open().then(function() {
                return tempTransaction(db, mode, storeNames, fn);
              });
            }
            return rejection(ex);
          }
          return trans._promise(mode, function(resolve, reject) {
            return newScope(function() {
              PSD.trans = trans;
              return fn(resolve, reject, trans);
            });
          }).then(function(result) {
            if (mode === "readwrite")
              try {
                trans.idbtrans.commit();
              } catch (_a10) {
              }
            return mode === "readonly" ? result : trans._completion.then(function() {
              return result;
            });
          });
        }
      }
      __name(tempTransaction, "tempTransaction");
      var DEXIE_VERSION = "4.0.11";
      var maxString = String.fromCharCode(65535);
      var minKey = -Infinity;
      var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
      var STRING_EXPECTED = "String expected.";
      var connections = [];
      var DBNAMES_DB = "__dbnames";
      var READONLY = "readonly";
      var READWRITE = "readwrite";
      function combine(filter1, filter2) {
        return filter1 ? filter2 ? function() {
          return filter1.apply(this, arguments) && filter2.apply(this, arguments);
        } : filter1 : filter2;
      }
      __name(combine, "combine");
      var AnyRange = {
        type: 3,
        lower: -Infinity,
        lowerOpen: false,
        upper: [[]],
        upperOpen: false
      };
      function workaroundForUndefinedPrimKey(keyPath) {
        return typeof keyPath === "string" && !/\./.test(keyPath) ? function(obj) {
          if (obj[keyPath] === void 0 && keyPath in obj) {
            obj = deepClone(obj);
            delete obj[keyPath];
          }
          return obj;
        } : function(obj) {
          return obj;
        };
      }
      __name(workaroundForUndefinedPrimKey, "workaroundForUndefinedPrimKey");
      function Entity2() {
        throw exceptions.Type();
      }
      __name(Entity2, "Entity");
      function cmp2(a, b) {
        try {
          var ta = type(a);
          var tb = type(b);
          if (ta !== tb) {
            if (ta === "Array")
              return 1;
            if (tb === "Array")
              return -1;
            if (ta === "binary")
              return 1;
            if (tb === "binary")
              return -1;
            if (ta === "string")
              return 1;
            if (tb === "string")
              return -1;
            if (ta === "Date")
              return 1;
            if (tb !== "Date")
              return NaN;
            return -1;
          }
          switch (ta) {
            case "number":
            case "Date":
            case "string":
              return a > b ? 1 : a < b ? -1 : 0;
            case "binary": {
              return compareUint8Arrays(getUint8Array(a), getUint8Array(b));
            }
            case "Array":
              return compareArrays(a, b);
          }
        } catch (_a10) {
        }
        return NaN;
      }
      __name(cmp2, "cmp");
      function compareArrays(a, b) {
        var al = a.length;
        var bl = b.length;
        var l = al < bl ? al : bl;
        for (var i = 0; i < l; ++i) {
          var res = cmp2(a[i], b[i]);
          if (res !== 0)
            return res;
        }
        return al === bl ? 0 : al < bl ? -1 : 1;
      }
      __name(compareArrays, "compareArrays");
      function compareUint8Arrays(a, b) {
        var al = a.length;
        var bl = b.length;
        var l = al < bl ? al : bl;
        for (var i = 0; i < l; ++i) {
          if (a[i] !== b[i])
            return a[i] < b[i] ? -1 : 1;
        }
        return al === bl ? 0 : al < bl ? -1 : 1;
      }
      __name(compareUint8Arrays, "compareUint8Arrays");
      function type(x) {
        var t = typeof x;
        if (t !== "object")
          return t;
        if (ArrayBuffer.isView(x))
          return "binary";
        var tsTag = toStringTag2(x);
        return tsTag === "ArrayBuffer" ? "binary" : tsTag;
      }
      __name(type, "type");
      function getUint8Array(a) {
        if (a instanceof Uint8Array)
          return a;
        if (ArrayBuffer.isView(a))
          return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
        return new Uint8Array(a);
      }
      __name(getUint8Array, "getUint8Array");
      var Table = function() {
        function Table2() {
        }
        __name(Table2, "Table");
        Table2.prototype._trans = function(mode, fn, writeLocked) {
          var trans = this._tx || PSD.trans;
          var tableName = this.name;
          var task2 = debug23 && typeof console !== "undefined" && console.createTask && console.createTask("Dexie: ".concat(mode === "readonly" ? "read" : "write", " ").concat(this.name));
          function checkTableInTransaction(resolve, reject, trans2) {
            if (!trans2.schema[tableName])
              throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
            return fn(trans2.idbtrans, trans2);
          }
          __name(checkTableInTransaction, "checkTableInTransaction");
          var wasRootExec = beginMicroTickScope();
          try {
            var p = trans && trans.db._novip === this.db._novip ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(function() {
              return trans._promise(mode, checkTableInTransaction, writeLocked);
            }, { trans, transless: PSD.transless || PSD }) : tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
            if (task2) {
              p._consoleTask = task2;
              p = p.catch(function(err2) {
                console.trace(err2);
                return rejection(err2);
              });
            }
            return p;
          } finally {
            if (wasRootExec)
              endMicroTickScope();
          }
        };
        Table2.prototype.get = function(keyOrCrit, cb) {
          var _this = this;
          if (keyOrCrit && keyOrCrit.constructor === Object)
            return this.where(keyOrCrit).first(cb);
          if (keyOrCrit == null)
            return rejection(new exceptions.Type("Invalid argument to Table.get()"));
          return this._trans("readonly", function(trans) {
            return _this.core.get({ trans, key: keyOrCrit }).then(function(res) {
              return _this.hook.reading.fire(res);
            });
          }).then(cb);
        };
        Table2.prototype.where = function(indexOrCrit) {
          if (typeof indexOrCrit === "string")
            return new this.db.WhereClause(this, indexOrCrit);
          if (isArray6(indexOrCrit))
            return new this.db.WhereClause(this, "[".concat(indexOrCrit.join("+"), "]"));
          var keyPaths = keys3(indexOrCrit);
          if (keyPaths.length === 1)
            return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);
          var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function(ix) {
            if (ix.compound && keyPaths.every(function(keyPath) {
              return ix.keyPath.indexOf(keyPath) >= 0;
            })) {
              for (var i = 0; i < keyPaths.length; ++i) {
                if (keyPaths.indexOf(ix.keyPath[i]) === -1)
                  return false;
              }
              return true;
            }
            return false;
          }).sort(function(a, b) {
            return a.keyPath.length - b.keyPath.length;
          })[0];
          if (compoundIndex && this.db._maxKey !== maxString) {
            var keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);
            return this.where(keyPathsInValidOrder).equals(keyPathsInValidOrder.map(function(kp) {
              return indexOrCrit[kp];
            }));
          }
          if (!compoundIndex && debug23)
            console.warn("The query ".concat(JSON.stringify(indexOrCrit), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(keyPaths.join("+"), "]"));
          var idxByName = this.schema.idxByName;
          function equals(a, b) {
            return cmp2(a, b) === 0;
          }
          __name(equals, "equals");
          var _a10 = keyPaths.reduce(function(_a11, keyPath) {
            var prevIndex = _a11[0], prevFilterFn = _a11[1];
            var index = idxByName[keyPath];
            var value = indexOrCrit[keyPath];
            return [
              prevIndex || index,
              prevIndex || !index ? combine(prevFilterFn, index && index.multi ? function(x) {
                var prop = getByKeyPath(x, keyPath);
                return isArray6(prop) && prop.some(function(item) {
                  return equals(value, item);
                });
              } : function(x) {
                return equals(value, getByKeyPath(x, keyPath));
              }) : prevFilterFn
            ];
          }, [null, null]), idx = _a10[0], filterFunction = _a10[1];
          return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals("");
        };
        Table2.prototype.filter = function(filterFunction) {
          return this.toCollection().and(filterFunction);
        };
        Table2.prototype.count = function(thenShortcut) {
          return this.toCollection().count(thenShortcut);
        };
        Table2.prototype.offset = function(offset) {
          return this.toCollection().offset(offset);
        };
        Table2.prototype.limit = function(numRows) {
          return this.toCollection().limit(numRows);
        };
        Table2.prototype.each = function(callback) {
          return this.toCollection().each(callback);
        };
        Table2.prototype.toArray = function(thenShortcut) {
          return this.toCollection().toArray(thenShortcut);
        };
        Table2.prototype.toCollection = function() {
          return new this.db.Collection(new this.db.WhereClause(this));
        };
        Table2.prototype.orderBy = function(index) {
          return new this.db.Collection(new this.db.WhereClause(this, isArray6(index) ? "[".concat(index.join("+"), "]") : index));
        };
        Table2.prototype.reverse = function() {
          return this.toCollection().reverse();
        };
        Table2.prototype.mapToClass = function(constructor) {
          var _a10 = this, db = _a10.db, tableName = _a10.name;
          this.schema.mappedClass = constructor;
          if (constructor.prototype instanceof Entity2) {
            constructor = function(_super) {
              __extends2(class_1, _super);
              function class_1() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              __name(class_1, "class_1");
              Object.defineProperty(class_1.prototype, "db", {
                get: /* @__PURE__ */ __name(function() {
                  return db;
                }, "get"),
                enumerable: false,
                configurable: true
              });
              class_1.prototype.table = function() {
                return tableName;
              };
              return class_1;
            }(constructor);
          }
          var inheritedProps = /* @__PURE__ */ new Set();
          for (var proto = constructor.prototype; proto; proto = getProto(proto)) {
            Object.getOwnPropertyNames(proto).forEach(function(propName) {
              return inheritedProps.add(propName);
            });
          }
          var readHook = /* @__PURE__ */ __name(function(obj) {
            if (!obj)
              return obj;
            var res = Object.create(constructor.prototype);
            for (var m in obj)
              if (!inheritedProps.has(m))
                try {
                  res[m] = obj[m];
                } catch (_) {
                }
            return res;
          }, "readHook");
          if (this.schema.readHook) {
            this.hook.reading.unsubscribe(this.schema.readHook);
          }
          this.schema.readHook = readHook;
          this.hook("reading", readHook);
          return constructor;
        };
        Table2.prototype.defineClass = function() {
          function Class(content) {
            extend2(this, content);
          }
          __name(Class, "Class");
          return this.mapToClass(Class);
        };
        Table2.prototype.add = function(obj, key) {
          var _this = this;
          var _a10 = this.schema.primKey, auto = _a10.auto, keyPath = _a10.keyPath;
          var objToAdd = obj;
          if (keyPath && auto) {
            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
          }
          return this._trans("readwrite", function(trans) {
            return _this.core.mutate({ trans, type: "add", keys: key != null ? [key] : null, values: [objToAdd] });
          }).then(function(res) {
            return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;
          }).then(function(lastResult) {
            if (keyPath) {
              try {
                setByKeyPath(obj, keyPath, lastResult);
              } catch (_) {
              }
            }
            return lastResult;
          });
        };
        Table2.prototype.update = function(keyOrObject, modifications) {
          if (typeof keyOrObject === "object" && !isArray6(keyOrObject)) {
            var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
            if (key === void 0)
              return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
            return this.where(":id").equals(key).modify(modifications);
          } else {
            return this.where(":id").equals(keyOrObject).modify(modifications);
          }
        };
        Table2.prototype.put = function(obj, key) {
          var _this = this;
          var _a10 = this.schema.primKey, auto = _a10.auto, keyPath = _a10.keyPath;
          var objToAdd = obj;
          if (keyPath && auto) {
            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
          }
          return this._trans("readwrite", function(trans) {
            return _this.core.mutate({ trans, type: "put", values: [objToAdd], keys: key != null ? [key] : null });
          }).then(function(res) {
            return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;
          }).then(function(lastResult) {
            if (keyPath) {
              try {
                setByKeyPath(obj, keyPath, lastResult);
              } catch (_) {
              }
            }
            return lastResult;
          });
        };
        Table2.prototype.delete = function(key) {
          var _this = this;
          return this._trans("readwrite", function(trans) {
            return _this.core.mutate({ trans, type: "delete", keys: [key] });
          }).then(function(res) {
            return res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0;
          });
        };
        Table2.prototype.clear = function() {
          var _this = this;
          return this._trans("readwrite", function(trans) {
            return _this.core.mutate({ trans, type: "deleteRange", range: AnyRange });
          }).then(function(res) {
            return res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0;
          });
        };
        Table2.prototype.bulkGet = function(keys4) {
          var _this = this;
          return this._trans("readonly", function(trans) {
            return _this.core.getMany({
              keys: keys4,
              trans
            }).then(function(result) {
              return result.map(function(res) {
                return _this.hook.reading.fire(res);
              });
            });
          });
        };
        Table2.prototype.bulkAdd = function(objects, keysOrOptions, options) {
          var _this = this;
          var keys4 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
          options = options || (keys4 ? void 0 : keysOrOptions);
          var wantResults = options ? options.allKeys : void 0;
          return this._trans("readwrite", function(trans) {
            var _a10 = _this.schema.primKey, auto = _a10.auto, keyPath = _a10.keyPath;
            if (keyPath && keys4)
              throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
            if (keys4 && keys4.length !== objects.length)
              throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
            var numObjects = objects.length;
            var objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
            return _this.core.mutate({ trans, type: "add", keys: keys4, values: objectsToAdd, wantResults }).then(function(_a11) {
              var numFailures = _a11.numFailures, results = _a11.results, lastResult = _a11.lastResult, failures = _a11.failures;
              var result = wantResults ? results : lastResult;
              if (numFailures === 0)
                return result;
              throw new BulkError("".concat(_this.name, ".bulkAdd(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
            });
          });
        };
        Table2.prototype.bulkPut = function(objects, keysOrOptions, options) {
          var _this = this;
          var keys4 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
          options = options || (keys4 ? void 0 : keysOrOptions);
          var wantResults = options ? options.allKeys : void 0;
          return this._trans("readwrite", function(trans) {
            var _a10 = _this.schema.primKey, auto = _a10.auto, keyPath = _a10.keyPath;
            if (keyPath && keys4)
              throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
            if (keys4 && keys4.length !== objects.length)
              throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
            var numObjects = objects.length;
            var objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
            return _this.core.mutate({ trans, type: "put", keys: keys4, values: objectsToPut, wantResults }).then(function(_a11) {
              var numFailures = _a11.numFailures, results = _a11.results, lastResult = _a11.lastResult, failures = _a11.failures;
              var result = wantResults ? results : lastResult;
              if (numFailures === 0)
                return result;
              throw new BulkError("".concat(_this.name, ".bulkPut(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
            });
          });
        };
        Table2.prototype.bulkUpdate = function(keysAndChanges) {
          var _this = this;
          var coreTable = this.core;
          var keys4 = keysAndChanges.map(function(entry) {
            return entry.key;
          });
          var changeSpecs = keysAndChanges.map(function(entry) {
            return entry.changes;
          });
          var offsetMap = [];
          return this._trans("readwrite", function(trans) {
            return coreTable.getMany({ trans, keys: keys4, cache: "clone" }).then(function(objs) {
              var resultKeys = [];
              var resultObjs = [];
              keysAndChanges.forEach(function(_a10, idx) {
                var key = _a10.key, changes = _a10.changes;
                var obj = objs[idx];
                if (obj) {
                  for (var _i = 0, _b2 = Object.keys(changes); _i < _b2.length; _i++) {
                    var keyPath = _b2[_i];
                    var value = changes[keyPath];
                    if (keyPath === _this.schema.primKey.keyPath) {
                      if (cmp2(value, key) !== 0) {
                        throw new exceptions.Constraint("Cannot update primary key in bulkUpdate()");
                      }
                    } else {
                      setByKeyPath(obj, keyPath, value);
                    }
                  }
                  offsetMap.push(idx);
                  resultKeys.push(key);
                  resultObjs.push(obj);
                }
              });
              var numEntries = resultKeys.length;
              return coreTable.mutate({
                trans,
                type: "put",
                keys: resultKeys,
                values: resultObjs,
                updates: {
                  keys: keys4,
                  changeSpecs
                }
              }).then(function(_a10) {
                var numFailures = _a10.numFailures, failures = _a10.failures;
                if (numFailures === 0)
                  return numEntries;
                for (var _i = 0, _b2 = Object.keys(failures); _i < _b2.length; _i++) {
                  var offset = _b2[_i];
                  var mappedOffset = offsetMap[Number(offset)];
                  if (mappedOffset != null) {
                    var failure = failures[offset];
                    delete failures[offset];
                    failures[mappedOffset] = failure;
                  }
                }
                throw new BulkError("".concat(_this.name, ".bulkUpdate(): ").concat(numFailures, " of ").concat(numEntries, " operations failed"), failures);
              });
            });
          });
        };
        Table2.prototype.bulkDelete = function(keys4) {
          var _this = this;
          var numKeys = keys4.length;
          return this._trans("readwrite", function(trans) {
            return _this.core.mutate({ trans, type: "delete", keys: keys4 });
          }).then(function(_a10) {
            var numFailures = _a10.numFailures, lastResult = _a10.lastResult, failures = _a10.failures;
            if (numFailures === 0)
              return lastResult;
            throw new BulkError("".concat(_this.name, ".bulkDelete(): ").concat(numFailures, " of ").concat(numKeys, " operations failed"), failures);
          });
        };
        return Table2;
      }();
      function Events2(ctx) {
        var evs = {};
        var rv = /* @__PURE__ */ __name(function(eventName, subscriber) {
          if (subscriber) {
            var i2 = arguments.length, args2 = new Array(i2 - 1);
            while (--i2)
              args2[i2 - 1] = arguments[i2];
            evs[eventName].subscribe.apply(null, args2);
            return ctx;
          } else if (typeof eventName === "string") {
            return evs[eventName];
          }
        }, "rv");
        rv.addEventType = add3;
        for (var i = 1, l = arguments.length; i < l; ++i) {
          add3(arguments[i]);
        }
        return rv;
        function add3(eventName, chainFunction, defaultFunction) {
          if (typeof eventName === "object")
            return addConfiguredEvents(eventName);
          if (!chainFunction)
            chainFunction = reverseStoppableEventChain;
          if (!defaultFunction)
            defaultFunction = nop;
          var context2 = {
            subscribers: [],
            fire: defaultFunction,
            subscribe: /* @__PURE__ */ __name(function(cb) {
              if (context2.subscribers.indexOf(cb) === -1) {
                context2.subscribers.push(cb);
                context2.fire = chainFunction(context2.fire, cb);
              }
            }, "subscribe"),
            unsubscribe: /* @__PURE__ */ __name(function(cb) {
              context2.subscribers = context2.subscribers.filter(function(fn) {
                return fn !== cb;
              });
              context2.fire = context2.subscribers.reduce(chainFunction, defaultFunction);
            }, "unsubscribe")
          };
          evs[eventName] = rv[eventName] = context2;
          return context2;
        }
        __name(add3, "add");
        function addConfiguredEvents(cfg) {
          keys3(cfg).forEach(function(eventName) {
            var args2 = cfg[eventName];
            if (isArray6(args2)) {
              add3(eventName, cfg[eventName][0], cfg[eventName][1]);
            } else if (args2 === "asap") {
              var context2 = add3(eventName, mirror, /* @__PURE__ */ __name(function fire() {
                var i2 = arguments.length, args3 = new Array(i2);
                while (i2--)
                  args3[i2] = arguments[i2];
                context2.subscribers.forEach(function(fn) {
                  asap$1(/* @__PURE__ */ __name(function fireEvent() {
                    fn.apply(null, args3);
                  }, "fireEvent"));
                });
              }, "fire"));
            } else
              throw new exceptions.InvalidArgument("Invalid event config");
          });
        }
        __name(addConfiguredEvents, "addConfiguredEvents");
      }
      __name(Events2, "Events");
      function makeClassConstructor(prototype3, constructor) {
        derive(constructor).from({ prototype: prototype3 });
        return constructor;
      }
      __name(makeClassConstructor, "makeClassConstructor");
      function createTableConstructor(db) {
        return makeClassConstructor(Table.prototype, /* @__PURE__ */ __name(function Table2(name, tableSchema, trans) {
          this.db = db;
          this._tx = trans;
          this.name = name;
          this.schema = tableSchema;
          this.hook = db._allTables[name] ? db._allTables[name].hook : Events2(null, {
            "creating": [hookCreatingChain, nop],
            "reading": [pureFunctionChain, mirror],
            "updating": [hookUpdatingChain, nop],
            "deleting": [hookDeletingChain, nop]
          });
        }, "Table"));
      }
      __name(createTableConstructor, "createTableConstructor");
      function isPlainKeyRange(ctx, ignoreLimitFilter) {
        return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
      }
      __name(isPlainKeyRange, "isPlainKeyRange");
      function addFilter(ctx, fn) {
        ctx.filter = combine(ctx.filter, fn);
      }
      __name(addFilter, "addFilter");
      function addReplayFilter(ctx, factory, isLimitFilter) {
        var curr = ctx.replayFilter;
        ctx.replayFilter = curr ? function() {
          return combine(curr(), factory());
        } : factory;
        ctx.justLimit = isLimitFilter && !curr;
      }
      __name(addReplayFilter, "addReplayFilter");
      function addMatchFilter(ctx, fn) {
        ctx.isMatch = combine(ctx.isMatch, fn);
      }
      __name(addMatchFilter, "addMatchFilter");
      function getIndexOrStore(ctx, coreSchema) {
        if (ctx.isPrimKey)
          return coreSchema.primaryKey;
        var index = coreSchema.getIndexByKeyPath(ctx.index);
        if (!index)
          throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
        return index;
      }
      __name(getIndexOrStore, "getIndexOrStore");
      function openCursor(ctx, coreTable, trans) {
        var index = getIndexOrStore(ctx, coreTable.schema);
        return coreTable.openCursor({
          trans,
          values: !ctx.keysOnly,
          reverse: ctx.dir === "prev",
          unique: !!ctx.unique,
          query: {
            index,
            range: ctx.range
          }
        });
      }
      __name(openCursor, "openCursor");
      function iter(ctx, fn, coreTrans, coreTable) {
        var filter2 = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
        if (!ctx.or) {
          return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter2), fn, !ctx.keysOnly && ctx.valueMapper);
        } else {
          var set_1 = {};
          var union = /* @__PURE__ */ __name(function(item, cursor, advance) {
            if (!filter2 || filter2(cursor, advance, function(result) {
              return cursor.stop(result);
            }, function(err2) {
              return cursor.fail(err2);
            })) {
              var primaryKey = cursor.primaryKey;
              var key = "" + primaryKey;
              if (key === "[object ArrayBuffer]")
                key = "" + new Uint8Array(primaryKey);
              if (!hasOwn(set_1, key)) {
                set_1[key] = true;
                fn(item, cursor, advance);
              }
            }
          }, "union");
          return Promise.all([
            ctx.or._iterate(union, coreTrans),
            iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
          ]);
        }
      }
      __name(iter, "iter");
      function iterate(cursorPromise, filter2, fn, valueMapper) {
        var mappedFn = valueMapper ? function(x, c, a) {
          return fn(valueMapper(x), c, a);
        } : fn;
        var wrappedFn = wrap(mappedFn);
        return cursorPromise.then(function(cursor) {
          if (cursor) {
            return cursor.start(function() {
              var c = /* @__PURE__ */ __name(function() {
                return cursor.continue();
              }, "c");
              if (!filter2 || filter2(cursor, function(advancer) {
                return c = advancer;
              }, function(val) {
                cursor.stop(val);
                c = nop;
              }, function(e) {
                cursor.fail(e);
                c = nop;
              }))
                wrappedFn(cursor.value, cursor, function(advancer) {
                  return c = advancer;
                });
              c();
            });
          }
        });
      }
      __name(iterate, "iterate");
      var PropModification2 = function() {
        function PropModification3(spec) {
          this["@@propmod"] = spec;
        }
        __name(PropModification3, "PropModification");
        PropModification3.prototype.execute = function(value) {
          var _a10;
          var spec = this["@@propmod"];
          if (spec.add !== void 0) {
            var term = spec.add;
            if (isArray6(term)) {
              return __spreadArray2(__spreadArray2([], isArray6(value) ? value : [], true), term, true).sort();
            }
            if (typeof term === "number")
              return (Number(value) || 0) + term;
            if (typeof term === "bigint") {
              try {
                return BigInt(value) + term;
              } catch (_b2) {
                return BigInt(0) + term;
              }
            }
            throw new TypeError("Invalid term ".concat(term));
          }
          if (spec.remove !== void 0) {
            var subtrahend_1 = spec.remove;
            if (isArray6(subtrahend_1)) {
              return isArray6(value) ? value.filter(function(item) {
                return !subtrahend_1.includes(item);
              }).sort() : [];
            }
            if (typeof subtrahend_1 === "number")
              return Number(value) - subtrahend_1;
            if (typeof subtrahend_1 === "bigint") {
              try {
                return BigInt(value) - subtrahend_1;
              } catch (_c) {
                return BigInt(0) - subtrahend_1;
              }
            }
            throw new TypeError("Invalid subtrahend ".concat(subtrahend_1));
          }
          var prefixToReplace = (_a10 = spec.replacePrefix) === null || _a10 === void 0 ? void 0 : _a10[0];
          if (prefixToReplace && typeof value === "string" && value.startsWith(prefixToReplace)) {
            return spec.replacePrefix[1] + value.substring(prefixToReplace.length);
          }
          return value;
        };
        return PropModification3;
      }();
      var Collection = function() {
        function Collection2() {
        }
        __name(Collection2, "Collection");
        Collection2.prototype._read = function(fn, cb) {
          var ctx = this._ctx;
          return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readonly", fn).then(cb);
        };
        Collection2.prototype._write = function(fn) {
          var ctx = this._ctx;
          return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readwrite", fn, "locked");
        };
        Collection2.prototype._addAlgorithm = function(fn) {
          var ctx = this._ctx;
          ctx.algorithm = combine(ctx.algorithm, fn);
        };
        Collection2.prototype._iterate = function(fn, coreTrans) {
          return iter(this._ctx, fn, coreTrans, this._ctx.table.core);
        };
        Collection2.prototype.clone = function(props2) {
          var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
          if (props2)
            extend2(ctx, props2);
          rv._ctx = ctx;
          return rv;
        };
        Collection2.prototype.raw = function() {
          this._ctx.valueMapper = null;
          return this;
        };
        Collection2.prototype.each = function(fn) {
          var ctx = this._ctx;
          return this._read(function(trans) {
            return iter(ctx, fn, trans, ctx.table.core);
          });
        };
        Collection2.prototype.count = function(cb) {
          var _this = this;
          return this._read(function(trans) {
            var ctx = _this._ctx;
            var coreTable = ctx.table.core;
            if (isPlainKeyRange(ctx, true)) {
              return coreTable.count({
                trans,
                query: {
                  index: getIndexOrStore(ctx, coreTable.schema),
                  range: ctx.range
                }
              }).then(function(count3) {
                return Math.min(count3, ctx.limit);
              });
            } else {
              var count2 = 0;
              return iter(ctx, function() {
                ++count2;
                return false;
              }, trans, coreTable).then(function() {
                return count2;
              });
            }
          }).then(cb);
        };
        Collection2.prototype.sortBy = function(keyPath, cb) {
          var parts = keyPath.split(".").reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
          function getval(obj, i) {
            if (i)
              return getval(obj[parts[i]], i - 1);
            return obj[lastPart];
          }
          __name(getval, "getval");
          var order = this._ctx.dir === "next" ? 1 : -1;
          function sorter(a, b) {
            var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);
            return cmp2(aVal, bVal) * order;
          }
          __name(sorter, "sorter");
          return this.toArray(function(a) {
            return a.sort(sorter);
          }).then(cb);
        };
        Collection2.prototype.toArray = function(cb) {
          var _this = this;
          return this._read(function(trans) {
            var ctx = _this._ctx;
            if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
              var valueMapper_1 = ctx.valueMapper;
              var index = getIndexOrStore(ctx, ctx.table.core.schema);
              return ctx.table.core.query({
                trans,
                limit: ctx.limit,
                values: true,
                query: {
                  index,
                  range: ctx.range
                }
              }).then(function(_a10) {
                var result = _a10.result;
                return valueMapper_1 ? result.map(valueMapper_1) : result;
              });
            } else {
              var a_1 = [];
              return iter(ctx, function(item) {
                return a_1.push(item);
              }, trans, ctx.table.core).then(function() {
                return a_1;
              });
            }
          }, cb);
        };
        Collection2.prototype.offset = function(offset) {
          var ctx = this._ctx;
          if (offset <= 0)
            return this;
          ctx.offset += offset;
          if (isPlainKeyRange(ctx)) {
            addReplayFilter(ctx, function() {
              var offsetLeft = offset;
              return function(cursor, advance) {
                if (offsetLeft === 0)
                  return true;
                if (offsetLeft === 1) {
                  --offsetLeft;
                  return false;
                }
                advance(function() {
                  cursor.advance(offsetLeft);
                  offsetLeft = 0;
                });
                return false;
              };
            });
          } else {
            addReplayFilter(ctx, function() {
              var offsetLeft = offset;
              return function() {
                return --offsetLeft < 0;
              };
            });
          }
          return this;
        };
        Collection2.prototype.limit = function(numRows) {
          this._ctx.limit = Math.min(this._ctx.limit, numRows);
          addReplayFilter(this._ctx, function() {
            var rowsLeft = numRows;
            return function(cursor, advance, resolve) {
              if (--rowsLeft <= 0)
                advance(resolve);
              return rowsLeft >= 0;
            };
          }, true);
          return this;
        };
        Collection2.prototype.until = function(filterFunction, bIncludeStopEntry) {
          addFilter(this._ctx, function(cursor, advance, resolve) {
            if (filterFunction(cursor.value)) {
              advance(resolve);
              return bIncludeStopEntry;
            } else {
              return true;
            }
          });
          return this;
        };
        Collection2.prototype.first = function(cb) {
          return this.limit(1).toArray(function(a) {
            return a[0];
          }).then(cb);
        };
        Collection2.prototype.last = function(cb) {
          return this.reverse().first(cb);
        };
        Collection2.prototype.filter = function(filterFunction) {
          addFilter(this._ctx, function(cursor) {
            return filterFunction(cursor.value);
          });
          addMatchFilter(this._ctx, filterFunction);
          return this;
        };
        Collection2.prototype.and = function(filter2) {
          return this.filter(filter2);
        };
        Collection2.prototype.or = function(indexName) {
          return new this.db.WhereClause(this._ctx.table, indexName, this);
        };
        Collection2.prototype.reverse = function() {
          this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev";
          if (this._ondirectionchange)
            this._ondirectionchange(this._ctx.dir);
          return this;
        };
        Collection2.prototype.desc = function() {
          return this.reverse();
        };
        Collection2.prototype.eachKey = function(cb) {
          var ctx = this._ctx;
          ctx.keysOnly = !ctx.isMatch;
          return this.each(function(val, cursor) {
            cb(cursor.key, cursor);
          });
        };
        Collection2.prototype.eachUniqueKey = function(cb) {
          this._ctx.unique = "unique";
          return this.eachKey(cb);
        };
        Collection2.prototype.eachPrimaryKey = function(cb) {
          var ctx = this._ctx;
          ctx.keysOnly = !ctx.isMatch;
          return this.each(function(val, cursor) {
            cb(cursor.primaryKey, cursor);
          });
        };
        Collection2.prototype.keys = function(cb) {
          var ctx = this._ctx;
          ctx.keysOnly = !ctx.isMatch;
          var a = [];
          return this.each(function(item, cursor) {
            a.push(cursor.key);
          }).then(function() {
            return a;
          }).then(cb);
        };
        Collection2.prototype.primaryKeys = function(cb) {
          var ctx = this._ctx;
          if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
            return this._read(function(trans) {
              var index = getIndexOrStore(ctx, ctx.table.core.schema);
              return ctx.table.core.query({
                trans,
                values: false,
                limit: ctx.limit,
                query: {
                  index,
                  range: ctx.range
                }
              });
            }).then(function(_a10) {
              var result = _a10.result;
              return result;
            }).then(cb);
          }
          ctx.keysOnly = !ctx.isMatch;
          var a = [];
          return this.each(function(item, cursor) {
            a.push(cursor.primaryKey);
          }).then(function() {
            return a;
          }).then(cb);
        };
        Collection2.prototype.uniqueKeys = function(cb) {
          this._ctx.unique = "unique";
          return this.keys(cb);
        };
        Collection2.prototype.firstKey = function(cb) {
          return this.limit(1).keys(function(a) {
            return a[0];
          }).then(cb);
        };
        Collection2.prototype.lastKey = function(cb) {
          return this.reverse().firstKey(cb);
        };
        Collection2.prototype.distinct = function() {
          var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
          if (!idx || !idx.multi)
            return this;
          var set = {};
          addFilter(this._ctx, function(cursor) {
            var strKey = cursor.primaryKey.toString();
            var found = hasOwn(set, strKey);
            set[strKey] = true;
            return !found;
          });
          return this;
        };
        Collection2.prototype.modify = function(changes) {
          var _this = this;
          var ctx = this._ctx;
          return this._write(function(trans) {
            var modifyer;
            if (typeof changes === "function") {
              modifyer = changes;
            } else {
              var keyPaths = keys3(changes);
              var numKeys = keyPaths.length;
              modifyer = /* @__PURE__ */ __name(function(item) {
                var anythingModified = false;
                for (var i = 0; i < numKeys; ++i) {
                  var keyPath = keyPaths[i];
                  var val = changes[keyPath];
                  var origVal = getByKeyPath(item, keyPath);
                  if (val instanceof PropModification2) {
                    setByKeyPath(item, keyPath, val.execute(origVal));
                    anythingModified = true;
                  } else if (origVal !== val) {
                    setByKeyPath(item, keyPath, val);
                    anythingModified = true;
                  }
                }
                return anythingModified;
              }, "modifyer");
            }
            var coreTable = ctx.table.core;
            var _a10 = coreTable.schema.primaryKey, outbound = _a10.outbound, extractKey = _a10.extractKey;
            var limit = 200;
            var modifyChunkSize = _this.db._options.modifyChunkSize;
            if (modifyChunkSize) {
              if (typeof modifyChunkSize == "object") {
                limit = modifyChunkSize[coreTable.name] || modifyChunkSize["*"] || 200;
              } else {
                limit = modifyChunkSize;
              }
            }
            var totalFailures = [];
            var successCount = 0;
            var failedKeys = [];
            var applyMutateResult = /* @__PURE__ */ __name(function(expectedCount, res) {
              var failures = res.failures, numFailures = res.numFailures;
              successCount += expectedCount - numFailures;
              for (var _i = 0, _a11 = keys3(failures); _i < _a11.length; _i++) {
                var pos = _a11[_i];
                totalFailures.push(failures[pos]);
              }
            }, "applyMutateResult");
            return _this.clone().primaryKeys().then(function(keys4) {
              var criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== "function" || changes === deleteCallback) && {
                index: ctx.index,
                range: ctx.range
              };
              var nextChunk = /* @__PURE__ */ __name(function(offset) {
                var count2 = Math.min(limit, keys4.length - offset);
                return coreTable.getMany({
                  trans,
                  keys: keys4.slice(offset, offset + count2),
                  cache: "immutable"
                }).then(function(values) {
                  var addValues = [];
                  var putValues = [];
                  var putKeys = outbound ? [] : null;
                  var deleteKeys = [];
                  for (var i = 0; i < count2; ++i) {
                    var origValue = values[i];
                    var ctx_1 = {
                      value: deepClone(origValue),
                      primKey: keys4[offset + i]
                    };
                    if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {
                      if (ctx_1.value == null) {
                        deleteKeys.push(keys4[offset + i]);
                      } else if (!outbound && cmp2(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {
                        deleteKeys.push(keys4[offset + i]);
                        addValues.push(ctx_1.value);
                      } else {
                        putValues.push(ctx_1.value);
                        if (outbound)
                          putKeys.push(keys4[offset + i]);
                      }
                    }
                  }
                  return Promise.resolve(addValues.length > 0 && coreTable.mutate({ trans, type: "add", values: addValues }).then(function(res) {
                    for (var pos in res.failures) {
                      deleteKeys.splice(parseInt(pos), 1);
                    }
                    applyMutateResult(addValues.length, res);
                  })).then(function() {
                    return (putValues.length > 0 || criteria && typeof changes === "object") && coreTable.mutate({
                      trans,
                      type: "put",
                      keys: putKeys,
                      values: putValues,
                      criteria,
                      changeSpec: typeof changes !== "function" && changes,
                      isAdditionalChunk: offset > 0
                    }).then(function(res) {
                      return applyMutateResult(putValues.length, res);
                    });
                  }).then(function() {
                    return (deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({
                      trans,
                      type: "delete",
                      keys: deleteKeys,
                      criteria,
                      isAdditionalChunk: offset > 0
                    }).then(function(res) {
                      return applyMutateResult(deleteKeys.length, res);
                    });
                  }).then(function() {
                    return keys4.length > offset + count2 && nextChunk(offset + limit);
                  });
                });
              }, "nextChunk");
              return nextChunk(0).then(function() {
                if (totalFailures.length > 0)
                  throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
                return keys4.length;
              });
            });
          });
        };
        Collection2.prototype.delete = function() {
          var ctx = this._ctx, range = ctx.range;
          if (isPlainKeyRange(ctx) && (ctx.isPrimKey || range.type === 3)) {
            return this._write(function(trans) {
              var primaryKey = ctx.table.core.schema.primaryKey;
              var coreRange = range;
              return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then(function(count2) {
                return ctx.table.core.mutate({ trans, type: "deleteRange", range: coreRange }).then(function(_a10) {
                  var failures = _a10.failures;
                  _a10.lastResult;
                  _a10.results;
                  var numFailures = _a10.numFailures;
                  if (numFailures)
                    throw new ModifyError("Could not delete some values", Object.keys(failures).map(function(pos) {
                      return failures[pos];
                    }), count2 - numFailures);
                  return count2 - numFailures;
                });
              });
            });
          }
          return this.modify(deleteCallback);
        };
        return Collection2;
      }();
      var deleteCallback = /* @__PURE__ */ __name(function(value, ctx) {
        return ctx.value = null;
      }, "deleteCallback");
      function createCollectionConstructor(db) {
        return makeClassConstructor(Collection.prototype, /* @__PURE__ */ __name(function Collection2(whereClause, keyRangeGenerator) {
          this.db = db;
          var keyRange = AnyRange, error = null;
          if (keyRangeGenerator)
            try {
              keyRange = keyRangeGenerator();
            } catch (ex) {
              error = ex;
            }
          var whereCtx = whereClause._ctx;
          var table = whereCtx.table;
          var readingHook = table.hook.reading.fire;
          this._ctx = {
            table,
            index: whereCtx.index,
            isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,
            range: keyRange,
            keysOnly: false,
            dir: "next",
            unique: "",
            algorithm: null,
            filter: null,
            replayFilter: null,
            justLimit: true,
            isMatch: null,
            offset: 0,
            limit: Infinity,
            error,
            or: whereCtx.or,
            valueMapper: readingHook !== mirror ? readingHook : null
          };
        }, "Collection"));
      }
      __name(createCollectionConstructor, "createCollectionConstructor");
      function simpleCompare(a, b) {
        return a < b ? -1 : a === b ? 0 : 1;
      }
      __name(simpleCompare, "simpleCompare");
      function simpleCompareReverse(a, b) {
        return a > b ? -1 : a === b ? 0 : 1;
      }
      __name(simpleCompareReverse, "simpleCompareReverse");
      function fail(collectionOrWhereClause, err2, T) {
        var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;
        collection._ctx.error = T ? new T(err2) : new TypeError(err2);
        return collection;
      }
      __name(fail, "fail");
      function emptyCollection(whereClause) {
        return new whereClause.Collection(whereClause, function() {
          return rangeEqual("");
        }).limit(0);
      }
      __name(emptyCollection, "emptyCollection");
      function upperFactory(dir) {
        return dir === "next" ? function(s) {
          return s.toUpperCase();
        } : function(s) {
          return s.toLowerCase();
        };
      }
      __name(upperFactory, "upperFactory");
      function lowerFactory(dir) {
        return dir === "next" ? function(s) {
          return s.toLowerCase();
        } : function(s) {
          return s.toUpperCase();
        };
      }
      __name(lowerFactory, "lowerFactory");
      function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp3, dir) {
        var length2 = Math.min(key.length, lowerNeedle.length);
        var llp = -1;
        for (var i = 0; i < length2; ++i) {
          var lwrKeyChar = lowerKey[i];
          if (lwrKeyChar !== lowerNeedle[i]) {
            if (cmp3(key[i], upperNeedle[i]) < 0)
              return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
            if (cmp3(key[i], lowerNeedle[i]) < 0)
              return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
            if (llp >= 0)
              return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
            return null;
          }
          if (cmp3(key[i], lwrKeyChar) < 0)
            llp = i;
        }
        if (length2 < lowerNeedle.length && dir === "next")
          return key + upperNeedle.substr(key.length);
        if (length2 < key.length && dir === "prev")
          return key.substr(0, upperNeedle.length);
        return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);
      }
      __name(nextCasing, "nextCasing");
      function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
        var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;
        if (!needles.every(function(s) {
          return typeof s === "string";
        })) {
          return fail(whereClause, STRING_EXPECTED);
        }
        function initDirection(dir) {
          upper = upperFactory(dir);
          lower = lowerFactory(dir);
          compare = dir === "next" ? simpleCompare : simpleCompareReverse;
          var needleBounds = needles.map(function(needle) {
            return { lower: lower(needle), upper: upper(needle) };
          }).sort(function(a, b) {
            return compare(a.lower, b.lower);
          });
          upperNeedles = needleBounds.map(function(nb) {
            return nb.upper;
          });
          lowerNeedles = needleBounds.map(function(nb) {
            return nb.lower;
          });
          direction = dir;
          nextKeySuffix = dir === "next" ? "" : suffix;
        }
        __name(initDirection, "initDirection");
        initDirection("next");
        var c = new whereClause.Collection(whereClause, function() {
          return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix);
        });
        c._ondirectionchange = function(direction2) {
          initDirection(direction2);
        };
        var firstPossibleNeedle = 0;
        c._addAlgorithm(function(cursor, advance, resolve) {
          var key = cursor.key;
          if (typeof key !== "string")
            return false;
          var lowerKey = lower(key);
          if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
            return true;
          } else {
            var lowestPossibleCasing = null;
            for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
              var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
              if (casing === null && lowestPossibleCasing === null)
                firstPossibleNeedle = i + 1;
              else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
                lowestPossibleCasing = casing;
              }
            }
            if (lowestPossibleCasing !== null) {
              advance(function() {
                cursor.continue(lowestPossibleCasing + nextKeySuffix);
              });
            } else {
              advance(resolve);
            }
            return false;
          }
        });
        return c;
      }
      __name(addIgnoreCaseAlgorithm, "addIgnoreCaseAlgorithm");
      function createRange(lower, upper, lowerOpen, upperOpen) {
        return {
          type: 2,
          lower,
          upper,
          lowerOpen,
          upperOpen
        };
      }
      __name(createRange, "createRange");
      function rangeEqual(value) {
        return {
          type: 1,
          lower: value,
          upper: value
        };
      }
      __name(rangeEqual, "rangeEqual");
      var WhereClause = function() {
        function WhereClause2() {
        }
        __name(WhereClause2, "WhereClause");
        Object.defineProperty(WhereClause2.prototype, "Collection", {
          get: /* @__PURE__ */ __name(function() {
            return this._ctx.table.db.Collection;
          }, "get"),
          enumerable: false,
          configurable: true
        });
        WhereClause2.prototype.between = function(lower, upper, includeLower, includeUpper) {
          includeLower = includeLower !== false;
          includeUpper = includeUpper === true;
          try {
            if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper))
              return emptyCollection(this);
            return new this.Collection(this, function() {
              return createRange(lower, upper, !includeLower, !includeUpper);
            });
          } catch (e) {
            return fail(this, INVALID_KEY_ARGUMENT);
          }
        };
        WhereClause2.prototype.equals = function(value) {
          if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
          return new this.Collection(this, function() {
            return rangeEqual(value);
          });
        };
        WhereClause2.prototype.above = function(value) {
          if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
          return new this.Collection(this, function() {
            return createRange(value, void 0, true);
          });
        };
        WhereClause2.prototype.aboveOrEqual = function(value) {
          if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
          return new this.Collection(this, function() {
            return createRange(value, void 0, false);
          });
        };
        WhereClause2.prototype.below = function(value) {
          if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
          return new this.Collection(this, function() {
            return createRange(void 0, value, false, true);
          });
        };
        WhereClause2.prototype.belowOrEqual = function(value) {
          if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
          return new this.Collection(this, function() {
            return createRange(void 0, value);
          });
        };
        WhereClause2.prototype.startsWith = function(str) {
          if (typeof str !== "string")
            return fail(this, STRING_EXPECTED);
          return this.between(str, str + maxString, true, true);
        };
        WhereClause2.prototype.startsWithIgnoreCase = function(str) {
          if (str === "")
            return this.startsWith(str);
          return addIgnoreCaseAlgorithm(this, function(x, a) {
            return x.indexOf(a[0]) === 0;
          }, [str], maxString);
        };
        WhereClause2.prototype.equalsIgnoreCase = function(str) {
          return addIgnoreCaseAlgorithm(this, function(x, a) {
            return x === a[0];
          }, [str], "");
        };
        WhereClause2.prototype.anyOfIgnoreCase = function() {
          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
          if (set.length === 0)
            return emptyCollection(this);
          return addIgnoreCaseAlgorithm(this, function(x, a) {
            return a.indexOf(x) !== -1;
          }, set, "");
        };
        WhereClause2.prototype.startsWithAnyOfIgnoreCase = function() {
          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
          if (set.length === 0)
            return emptyCollection(this);
          return addIgnoreCaseAlgorithm(this, function(x, a) {
            return a.some(function(n) {
              return x.indexOf(n) === 0;
            });
          }, set, maxString);
        };
        WhereClause2.prototype.anyOf = function() {
          var _this = this;
          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
          var compare = this._cmp;
          try {
            set.sort(compare);
          } catch (e) {
            return fail(this, INVALID_KEY_ARGUMENT);
          }
          if (set.length === 0)
            return emptyCollection(this);
          var c = new this.Collection(this, function() {
            return createRange(set[0], set[set.length - 1]);
          });
          c._ondirectionchange = function(direction) {
            compare = direction === "next" ? _this._ascending : _this._descending;
            set.sort(compare);
          };
          var i = 0;
          c._addAlgorithm(function(cursor, advance, resolve) {
            var key = cursor.key;
            while (compare(key, set[i]) > 0) {
              ++i;
              if (i === set.length) {
                advance(resolve);
                return false;
              }
            }
            if (compare(key, set[i]) === 0) {
              return true;
            } else {
              advance(function() {
                cursor.continue(set[i]);
              });
              return false;
            }
          });
          return c;
        };
        WhereClause2.prototype.notEqual = function(value) {
          return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });
        };
        WhereClause2.prototype.noneOf = function() {
          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
          if (set.length === 0)
            return new this.Collection(this);
          try {
            set.sort(this._ascending);
          } catch (e) {
            return fail(this, INVALID_KEY_ARGUMENT);
          }
          var ranges = set.reduce(function(res, val) {
            return res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]];
          }, null);
          ranges.push([set[set.length - 1], this.db._maxKey]);
          return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
        };
        WhereClause2.prototype.inAnyRange = function(ranges, options) {
          var _this = this;
          var cmp3 = this._cmp, ascending = this._ascending, descending = this._descending, min2 = this._min, max3 = this._max;
          if (ranges.length === 0)
            return emptyCollection(this);
          if (!ranges.every(function(range) {
            return range[0] !== void 0 && range[1] !== void 0 && ascending(range[0], range[1]) <= 0;
          })) {
            return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
          }
          var includeLowers = !options || options.includeLowers !== false;
          var includeUppers = options && options.includeUppers === true;
          function addRange2(ranges2, newRange) {
            var i = 0, l = ranges2.length;
            for (; i < l; ++i) {
              var range = ranges2[i];
              if (cmp3(newRange[0], range[1]) < 0 && cmp3(newRange[1], range[0]) > 0) {
                range[0] = min2(range[0], newRange[0]);
                range[1] = max3(range[1], newRange[1]);
                break;
              }
            }
            if (i === l)
              ranges2.push(newRange);
            return ranges2;
          }
          __name(addRange2, "addRange");
          var sortDirection = ascending;
          function rangeSorter(a, b) {
            return sortDirection(a[0], b[0]);
          }
          __name(rangeSorter, "rangeSorter");
          var set;
          try {
            set = ranges.reduce(addRange2, []);
            set.sort(rangeSorter);
          } catch (ex) {
            return fail(this, INVALID_KEY_ARGUMENT);
          }
          var rangePos = 0;
          var keyIsBeyondCurrentEntry = includeUppers ? function(key) {
            return ascending(key, set[rangePos][1]) > 0;
          } : function(key) {
            return ascending(key, set[rangePos][1]) >= 0;
          };
          var keyIsBeforeCurrentEntry = includeLowers ? function(key) {
            return descending(key, set[rangePos][0]) > 0;
          } : function(key) {
            return descending(key, set[rangePos][0]) >= 0;
          };
          function keyWithinCurrentRange(key) {
            return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
          }
          __name(keyWithinCurrentRange, "keyWithinCurrentRange");
          var checkKey = keyIsBeyondCurrentEntry;
          var c = new this.Collection(this, function() {
            return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers);
          });
          c._ondirectionchange = function(direction) {
            if (direction === "next") {
              checkKey = keyIsBeyondCurrentEntry;
              sortDirection = ascending;
            } else {
              checkKey = keyIsBeforeCurrentEntry;
              sortDirection = descending;
            }
            set.sort(rangeSorter);
          };
          c._addAlgorithm(function(cursor, advance, resolve) {
            var key = cursor.key;
            while (checkKey(key)) {
              ++rangePos;
              if (rangePos === set.length) {
                advance(resolve);
                return false;
              }
            }
            if (keyWithinCurrentRange(key)) {
              return true;
            } else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) {
              return false;
            } else {
              advance(function() {
                if (sortDirection === ascending)
                  cursor.continue(set[rangePos][0]);
                else
                  cursor.continue(set[rangePos][1]);
              });
              return false;
            }
          });
          return c;
        };
        WhereClause2.prototype.startsWithAnyOf = function() {
          var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
          if (!set.every(function(s) {
            return typeof s === "string";
          })) {
            return fail(this, "startsWithAnyOf() only works with strings");
          }
          if (set.length === 0)
            return emptyCollection(this);
          return this.inAnyRange(set.map(function(str) {
            return [str, str + maxString];
          }));
        };
        return WhereClause2;
      }();
      function createWhereClauseConstructor(db) {
        return makeClassConstructor(WhereClause.prototype, /* @__PURE__ */ __name(function WhereClause2(table, index, orCollection) {
          this.db = db;
          this._ctx = {
            table,
            index: index === ":id" ? null : index,
            or: orCollection
          };
          this._cmp = this._ascending = cmp2;
          this._descending = function(a, b) {
            return cmp2(b, a);
          };
          this._max = function(a, b) {
            return cmp2(a, b) > 0 ? a : b;
          };
          this._min = function(a, b) {
            return cmp2(a, b) < 0 ? a : b;
          };
          this._IDBKeyRange = db._deps.IDBKeyRange;
          if (!this._IDBKeyRange)
            throw new exceptions.MissingAPI();
        }, "WhereClause"));
      }
      __name(createWhereClauseConstructor, "createWhereClauseConstructor");
      function eventRejectHandler(reject) {
        return wrap(function(event) {
          preventDefault(event);
          reject(event.target.error);
          return false;
        });
      }
      __name(eventRejectHandler, "eventRejectHandler");
      function preventDefault(event) {
        if (event.stopPropagation)
          event.stopPropagation();
        if (event.preventDefault)
          event.preventDefault();
      }
      __name(preventDefault, "preventDefault");
      var DEXIE_STORAGE_MUTATED_EVENT_NAME = "storagemutated";
      var STORAGE_MUTATED_DOM_EVENT_NAME = "x-storagemutated-1";
      var globalEvents = Events2(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);
      var Transaction2 = function() {
        function Transaction3() {
        }
        __name(Transaction3, "Transaction");
        Transaction3.prototype._lock = function() {
          assert(!PSD.global);
          ++this._reculock;
          if (this._reculock === 1 && !PSD.global)
            PSD.lockOwnerFor = this;
          return this;
        };
        Transaction3.prototype._unlock = function() {
          assert(!PSD.global);
          if (--this._reculock === 0) {
            if (!PSD.global)
              PSD.lockOwnerFor = null;
            while (this._blockedFuncs.length > 0 && !this._locked()) {
              var fnAndPSD = this._blockedFuncs.shift();
              try {
                usePSD(fnAndPSD[1], fnAndPSD[0]);
              } catch (e) {
              }
            }
          }
          return this;
        };
        Transaction3.prototype._locked = function() {
          return this._reculock && PSD.lockOwnerFor !== this;
        };
        Transaction3.prototype.create = function(idbtrans) {
          var _this = this;
          if (!this.mode)
            return this;
          var idbdb = this.db.idbdb;
          var dbOpenError = this.db._state.dbOpenError;
          assert(!this.idbtrans);
          if (!idbtrans && !idbdb) {
            switch (dbOpenError && dbOpenError.name) {
              case "DatabaseClosedError":
                throw new exceptions.DatabaseClosed(dbOpenError);
              case "MissingAPIError":
                throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
              default:
                throw new exceptions.OpenFailed(dbOpenError);
            }
          }
          if (!this.active)
            throw new exceptions.TransactionInactive();
          assert(this._completion._state === null);
          idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));
          idbtrans.onerror = wrap(function(ev) {
            preventDefault(ev);
            _this._reject(idbtrans.error);
          });
          idbtrans.onabort = wrap(function(ev) {
            preventDefault(ev);
            _this.active && _this._reject(new exceptions.Abort(idbtrans.error));
            _this.active = false;
            _this.on("abort").fire(ev);
          });
          idbtrans.oncomplete = wrap(function() {
            _this.active = false;
            _this._resolve();
            if ("mutatedParts" in idbtrans) {
              globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
            }
          });
          return this;
        };
        Transaction3.prototype._promise = function(mode, fn, bWriteLock) {
          var _this = this;
          if (mode === "readwrite" && this.mode !== "readwrite")
            return rejection(new exceptions.ReadOnly("Transaction is readonly"));
          if (!this.active)
            return rejection(new exceptions.TransactionInactive());
          if (this._locked()) {
            return new DexiePromise(function(resolve, reject) {
              _this._blockedFuncs.push([function() {
                _this._promise(mode, fn, bWriteLock).then(resolve, reject);
              }, PSD]);
            });
          } else if (bWriteLock) {
            return newScope(function() {
              var p2 = new DexiePromise(function(resolve, reject) {
                _this._lock();
                var rv = fn(resolve, reject, _this);
                if (rv && rv.then)
                  rv.then(resolve, reject);
              });
              p2.finally(function() {
                return _this._unlock();
              });
              p2._lib = true;
              return p2;
            });
          } else {
            var p = new DexiePromise(function(resolve, reject) {
              var rv = fn(resolve, reject, _this);
              if (rv && rv.then)
                rv.then(resolve, reject);
            });
            p._lib = true;
            return p;
          }
        };
        Transaction3.prototype._root = function() {
          return this.parent ? this.parent._root() : this;
        };
        Transaction3.prototype.waitFor = function(promiseLike) {
          var root2 = this._root();
          var promise = DexiePromise.resolve(promiseLike);
          if (root2._waitingFor) {
            root2._waitingFor = root2._waitingFor.then(function() {
              return promise;
            });
          } else {
            root2._waitingFor = promise;
            root2._waitingQueue = [];
            var store = root2.idbtrans.objectStore(root2.storeNames[0]);
            (/* @__PURE__ */ __name(function spin() {
              ++root2._spinCount;
              while (root2._waitingQueue.length)
                root2._waitingQueue.shift()();
              if (root2._waitingFor)
                store.get(-Infinity).onsuccess = spin;
            }, "spin"))();
          }
          var currentWaitPromise = root2._waitingFor;
          return new DexiePromise(function(resolve, reject) {
            promise.then(function(res) {
              return root2._waitingQueue.push(wrap(resolve.bind(null, res)));
            }, function(err2) {
              return root2._waitingQueue.push(wrap(reject.bind(null, err2)));
            }).finally(function() {
              if (root2._waitingFor === currentWaitPromise) {
                root2._waitingFor = null;
              }
            });
          });
        };
        Transaction3.prototype.abort = function() {
          if (this.active) {
            this.active = false;
            if (this.idbtrans)
              this.idbtrans.abort();
            this._reject(new exceptions.Abort());
          }
        };
        Transaction3.prototype.table = function(tableName) {
          var memoizedTables = this._memoizedTables || (this._memoizedTables = {});
          if (hasOwn(memoizedTables, tableName))
            return memoizedTables[tableName];
          var tableSchema = this.schema[tableName];
          if (!tableSchema) {
            throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
          }
          var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
          transactionBoundTable.core = this.db.core.table(tableName);
          memoizedTables[tableName] = transactionBoundTable;
          return transactionBoundTable;
        };
        return Transaction3;
      }();
      function createTransactionConstructor(db) {
        return makeClassConstructor(Transaction2.prototype, /* @__PURE__ */ __name(function Transaction3(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
          var _this = this;
          this.db = db;
          this.mode = mode;
          this.storeNames = storeNames;
          this.schema = dbschema;
          this.chromeTransactionDurability = chromeTransactionDurability;
          this.idbtrans = null;
          this.on = Events2(this, "complete", "error", "abort");
          this.parent = parent || null;
          this.active = true;
          this._reculock = 0;
          this._blockedFuncs = [];
          this._resolve = null;
          this._reject = null;
          this._waitingFor = null;
          this._waitingQueue = null;
          this._spinCount = 0;
          this._completion = new DexiePromise(function(resolve, reject) {
            _this._resolve = resolve;
            _this._reject = reject;
          });
          this._completion.then(function() {
            _this.active = false;
            _this.on.complete.fire();
          }, function(e) {
            var wasActive = _this.active;
            _this.active = false;
            _this.on.error.fire(e);
            _this.parent ? _this.parent._reject(e) : wasActive && _this.idbtrans && _this.idbtrans.abort();
            return rejection(e);
          });
        }, "Transaction"));
      }
      __name(createTransactionConstructor, "createTransactionConstructor");
      function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {
        return {
          name,
          keyPath,
          unique,
          multi,
          auto,
          compound,
          src: (unique && !isPrimKey ? "&" : "") + (multi ? "*" : "") + (auto ? "++" : "") + nameFromKeyPath(keyPath)
        };
      }
      __name(createIndexSpec, "createIndexSpec");
      function nameFromKeyPath(keyPath) {
        return typeof keyPath === "string" ? keyPath : keyPath ? "[" + [].join.call(keyPath, "+") + "]" : "";
      }
      __name(nameFromKeyPath, "nameFromKeyPath");
      function createTableSchema(name, primKey, indexes) {
        return {
          name,
          primKey,
          indexes,
          mappedClass: null,
          idxByName: arrayToObject2(indexes, function(index) {
            return [index.name, index];
          })
        };
      }
      __name(createTableSchema, "createTableSchema");
      function safariMultiStoreFix(storeNames) {
        return storeNames.length === 1 ? storeNames[0] : storeNames;
      }
      __name(safariMultiStoreFix, "safariMultiStoreFix");
      var getMaxKey = /* @__PURE__ */ __name(function(IdbKeyRange) {
        try {
          IdbKeyRange.only([[]]);
          getMaxKey = /* @__PURE__ */ __name(function() {
            return [[]];
          }, "getMaxKey");
          return [[]];
        } catch (e) {
          getMaxKey = /* @__PURE__ */ __name(function() {
            return maxString;
          }, "getMaxKey");
          return maxString;
        }
      }, "getMaxKey");
      function getKeyExtractor(keyPath) {
        if (keyPath == null) {
          return function() {
            return void 0;
          };
        } else if (typeof keyPath === "string") {
          return getSinglePathKeyExtractor(keyPath);
        } else {
          return function(obj) {
            return getByKeyPath(obj, keyPath);
          };
        }
      }
      __name(getKeyExtractor, "getKeyExtractor");
      function getSinglePathKeyExtractor(keyPath) {
        var split = keyPath.split(".");
        if (split.length === 1) {
          return function(obj) {
            return obj[keyPath];
          };
        } else {
          return function(obj) {
            return getByKeyPath(obj, keyPath);
          };
        }
      }
      __name(getSinglePathKeyExtractor, "getSinglePathKeyExtractor");
      function arrayify(arrayLike) {
        return [].slice.call(arrayLike);
      }
      __name(arrayify, "arrayify");
      var _id_counter = 0;
      function getKeyPathAlias(keyPath) {
        return keyPath == null ? ":id" : typeof keyPath === "string" ? keyPath : "[".concat(keyPath.join("+"), "]");
      }
      __name(getKeyPathAlias, "getKeyPathAlias");
      function createDBCore(db, IdbKeyRange, tmpTrans) {
        function extractSchema(db2, trans) {
          var tables2 = arrayify(db2.objectStoreNames);
          return {
            schema: {
              name: db2.name,
              tables: tables2.map(function(table) {
                return trans.objectStore(table);
              }).map(function(store) {
                var keyPath = store.keyPath, autoIncrement = store.autoIncrement;
                var compound = isArray6(keyPath);
                var outbound = keyPath == null;
                var indexByKeyPath = {};
                var result = {
                  name: store.name,
                  primaryKey: {
                    name: null,
                    isPrimaryKey: true,
                    outbound,
                    compound,
                    keyPath,
                    autoIncrement,
                    unique: true,
                    extractKey: getKeyExtractor(keyPath)
                  },
                  indexes: arrayify(store.indexNames).map(function(indexName) {
                    return store.index(indexName);
                  }).map(function(index) {
                    var name = index.name, unique = index.unique, multiEntry = index.multiEntry, keyPath2 = index.keyPath;
                    var compound2 = isArray6(keyPath2);
                    var result2 = {
                      name,
                      compound: compound2,
                      keyPath: keyPath2,
                      unique,
                      multiEntry,
                      extractKey: getKeyExtractor(keyPath2)
                    };
                    indexByKeyPath[getKeyPathAlias(keyPath2)] = result2;
                    return result2;
                  }),
                  getIndexByKeyPath: /* @__PURE__ */ __name(function(keyPath2) {
                    return indexByKeyPath[getKeyPathAlias(keyPath2)];
                  }, "getIndexByKeyPath")
                };
                indexByKeyPath[":id"] = result.primaryKey;
                if (keyPath != null) {
                  indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
                }
                return result;
              })
            },
            hasGetAll: tables2.length > 0 && "getAll" in trans.objectStore(tables2[0]) && !(typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
          };
        }
        __name(extractSchema, "extractSchema");
        function makeIDBKeyRange(range) {
          if (range.type === 3)
            return null;
          if (range.type === 4)
            throw new Error("Cannot convert never type to IDBKeyRange");
          var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;
          var idbRange = lower === void 0 ? upper === void 0 ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === void 0 ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
          return idbRange;
        }
        __name(makeIDBKeyRange, "makeIDBKeyRange");
        function createDbCoreTable(tableSchema) {
          var tableName = tableSchema.name;
          function mutate(_a11) {
            var trans = _a11.trans, type2 = _a11.type, keys4 = _a11.keys, values = _a11.values, range = _a11.range;
            return new Promise(function(resolve, reject) {
              resolve = wrap(resolve);
              var store = trans.objectStore(tableName);
              var outbound = store.keyPath == null;
              var isAddOrPut = type2 === "put" || type2 === "add";
              if (!isAddOrPut && type2 !== "delete" && type2 !== "deleteRange")
                throw new Error("Invalid operation type: " + type2);
              var length2 = (keys4 || values || { length: 1 }).length;
              if (keys4 && values && keys4.length !== values.length) {
                throw new Error("Given keys array must have same length as given values array.");
              }
              if (length2 === 0)
                return resolve({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              var req;
              var reqs = [];
              var failures = [];
              var numFailures = 0;
              var errorHandler = /* @__PURE__ */ __name(function(event) {
                ++numFailures;
                preventDefault(event);
              }, "errorHandler");
              if (type2 === "deleteRange") {
                if (range.type === 4)
                  return resolve({ numFailures, failures, results: [], lastResult: void 0 });
                if (range.type === 3)
                  reqs.push(req = store.clear());
                else
                  reqs.push(req = store.delete(makeIDBKeyRange(range)));
              } else {
                var _a12 = isAddOrPut ? outbound ? [values, keys4] : [values, null] : [keys4, null], args1 = _a12[0], args2 = _a12[1];
                if (isAddOrPut) {
                  for (var i = 0; i < length2; ++i) {
                    reqs.push(req = args2 && args2[i] !== void 0 ? store[type2](args1[i], args2[i]) : store[type2](args1[i]));
                    req.onerror = errorHandler;
                  }
                } else {
                  for (var i = 0; i < length2; ++i) {
                    reqs.push(req = store[type2](args1[i]));
                    req.onerror = errorHandler;
                  }
                }
              }
              var done = /* @__PURE__ */ __name(function(event) {
                var lastResult = event.target.result;
                reqs.forEach(function(req2, i2) {
                  return req2.error != null && (failures[i2] = req2.error);
                });
                resolve({
                  numFailures,
                  failures,
                  results: type2 === "delete" ? keys4 : reqs.map(function(req2) {
                    return req2.result;
                  }),
                  lastResult
                });
              }, "done");
              req.onerror = function(event) {
                errorHandler(event);
                done(event);
              };
              req.onsuccess = done;
            });
          }
          __name(mutate, "mutate");
          function openCursor2(_a11) {
            var trans = _a11.trans, values = _a11.values, query2 = _a11.query, reverse = _a11.reverse, unique = _a11.unique;
            return new Promise(function(resolve, reject) {
              resolve = wrap(resolve);
              var index = query2.index, range = query2.range;
              var store = trans.objectStore(tableName);
              var source = index.isPrimaryKey ? store : store.index(index.name);
              var direction = reverse ? unique ? "prevunique" : "prev" : unique ? "nextunique" : "next";
              var req = values || !("openKeyCursor" in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);
              req.onerror = eventRejectHandler(reject);
              req.onsuccess = wrap(function(ev) {
                var cursor = req.result;
                if (!cursor) {
                  resolve(null);
                  return;
                }
                cursor.___id = ++_id_counter;
                cursor.done = false;
                var _cursorContinue = cursor.continue.bind(cursor);
                var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;
                if (_cursorContinuePrimaryKey)
                  _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);
                var _cursorAdvance = cursor.advance.bind(cursor);
                var doThrowCursorIsNotStarted = /* @__PURE__ */ __name(function() {
                  throw new Error("Cursor not started");
                }, "doThrowCursorIsNotStarted");
                var doThrowCursorIsStopped = /* @__PURE__ */ __name(function() {
                  throw new Error("Cursor not stopped");
                }, "doThrowCursorIsStopped");
                cursor.trans = trans;
                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;
                cursor.fail = wrap(reject);
                cursor.next = function() {
                  var _this = this;
                  var gotOne = 1;
                  return this.start(function() {
                    return gotOne-- ? _this.continue() : _this.stop();
                  }).then(function() {
                    return _this;
                  });
                };
                cursor.start = function(callback) {
                  var iterationPromise = new Promise(function(resolveIteration, rejectIteration) {
                    resolveIteration = wrap(resolveIteration);
                    req.onerror = eventRejectHandler(rejectIteration);
                    cursor.fail = rejectIteration;
                    cursor.stop = function(value) {
                      cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;
                      resolveIteration(value);
                    };
                  });
                  var guardedCallback = /* @__PURE__ */ __name(function() {
                    if (req.result) {
                      try {
                        callback();
                      } catch (err2) {
                        cursor.fail(err2);
                      }
                    } else {
                      cursor.done = true;
                      cursor.start = function() {
                        throw new Error("Cursor behind last entry");
                      };
                      cursor.stop();
                    }
                  }, "guardedCallback");
                  req.onsuccess = wrap(function(ev2) {
                    req.onsuccess = guardedCallback;
                    guardedCallback();
                  });
                  cursor.continue = _cursorContinue;
                  cursor.continuePrimaryKey = _cursorContinuePrimaryKey;
                  cursor.advance = _cursorAdvance;
                  guardedCallback();
                  return iterationPromise;
                };
                resolve(cursor);
              }, reject);
            });
          }
          __name(openCursor2, "openCursor");
          function query(hasGetAll2) {
            return function(request) {
              return new Promise(function(resolve, reject) {
                resolve = wrap(resolve);
                var trans = request.trans, values = request.values, limit = request.limit, query2 = request.query;
                var nonInfinitLimit = limit === Infinity ? void 0 : limit;
                var index = query2.index, range = query2.range;
                var store = trans.objectStore(tableName);
                var source = index.isPrimaryKey ? store : store.index(index.name);
                var idbKeyRange = makeIDBKeyRange(range);
                if (limit === 0)
                  return resolve({ result: [] });
                if (hasGetAll2) {
                  var req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);
                  req.onsuccess = function(event) {
                    return resolve({ result: event.target.result });
                  };
                  req.onerror = eventRejectHandler(reject);
                } else {
                  var count_1 = 0;
                  var req_1 = values || !("openKeyCursor" in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);
                  var result_1 = [];
                  req_1.onsuccess = function(event) {
                    var cursor = req_1.result;
                    if (!cursor)
                      return resolve({ result: result_1 });
                    result_1.push(values ? cursor.value : cursor.primaryKey);
                    if (++count_1 === limit)
                      return resolve({ result: result_1 });
                    cursor.continue();
                  };
                  req_1.onerror = eventRejectHandler(reject);
                }
              });
            };
          }
          __name(query, "query");
          return {
            name: tableName,
            schema: tableSchema,
            mutate,
            getMany: /* @__PURE__ */ __name(function(_a11) {
              var trans = _a11.trans, keys4 = _a11.keys;
              return new Promise(function(resolve, reject) {
                resolve = wrap(resolve);
                var store = trans.objectStore(tableName);
                var length2 = keys4.length;
                var result = new Array(length2);
                var keyCount = 0;
                var callbackCount = 0;
                var req;
                var successHandler = /* @__PURE__ */ __name(function(event) {
                  var req2 = event.target;
                  if ((result[req2._pos] = req2.result) != null)
                    ;
                  if (++callbackCount === keyCount)
                    resolve(result);
                }, "successHandler");
                var errorHandler = eventRejectHandler(reject);
                for (var i = 0; i < length2; ++i) {
                  var key = keys4[i];
                  if (key != null) {
                    req = store.get(keys4[i]);
                    req._pos = i;
                    req.onsuccess = successHandler;
                    req.onerror = errorHandler;
                    ++keyCount;
                  }
                }
                if (keyCount === 0)
                  resolve(result);
              });
            }, "getMany"),
            get: /* @__PURE__ */ __name(function(_a11) {
              var trans = _a11.trans, key = _a11.key;
              return new Promise(function(resolve, reject) {
                resolve = wrap(resolve);
                var store = trans.objectStore(tableName);
                var req = store.get(key);
                req.onsuccess = function(event) {
                  return resolve(event.target.result);
                };
                req.onerror = eventRejectHandler(reject);
              });
            }, "get"),
            query: query(hasGetAll),
            openCursor: openCursor2,
            count: /* @__PURE__ */ __name(function(_a11) {
              var query2 = _a11.query, trans = _a11.trans;
              var index = query2.index, range = query2.range;
              return new Promise(function(resolve, reject) {
                var store = trans.objectStore(tableName);
                var source = index.isPrimaryKey ? store : store.index(index.name);
                var idbKeyRange = makeIDBKeyRange(range);
                var req = idbKeyRange ? source.count(idbKeyRange) : source.count();
                req.onsuccess = wrap(function(ev) {
                  return resolve(ev.target.result);
                });
                req.onerror = eventRejectHandler(reject);
              });
            }, "count")
          };
        }
        __name(createDbCoreTable, "createDbCoreTable");
        var _a10 = extractSchema(db, tmpTrans), schema = _a10.schema, hasGetAll = _a10.hasGetAll;
        var tables = schema.tables.map(function(tableSchema) {
          return createDbCoreTable(tableSchema);
        });
        var tableMap = {};
        tables.forEach(function(table) {
          return tableMap[table.name] = table;
        });
        return {
          stack: "dbcore",
          transaction: db.transaction.bind(db),
          table: /* @__PURE__ */ __name(function(name) {
            var result = tableMap[name];
            if (!result)
              throw new Error("Table '".concat(name, "' not found"));
            return tableMap[name];
          }, "table"),
          MIN_KEY: -Infinity,
          MAX_KEY: getMaxKey(IdbKeyRange),
          schema
        };
      }
      __name(createDBCore, "createDBCore");
      function createMiddlewareStack(stackImpl, middlewares) {
        return middlewares.reduce(function(down, _a10) {
          var create7 = _a10.create;
          return __assign(__assign({}, down), create7(down));
        }, stackImpl);
      }
      __name(createMiddlewareStack, "createMiddlewareStack");
      function createMiddlewareStacks(middlewares, idbdb, _a10, tmpTrans) {
        var IDBKeyRange2 = _a10.IDBKeyRange;
        _a10.indexedDB;
        var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange2, tmpTrans), middlewares.dbcore);
        return {
          dbcore
        };
      }
      __name(createMiddlewareStacks, "createMiddlewareStacks");
      function generateMiddlewareStacks(db, tmpTrans) {
        var idbdb = tmpTrans.db;
        var stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);
        db.core = stacks.dbcore;
        db.tables.forEach(function(table) {
          var tableName = table.name;
          if (db.core.schema.tables.some(function(tbl) {
            return tbl.name === tableName;
          })) {
            table.core = db.core.table(tableName);
            if (db[tableName] instanceof db.Table) {
              db[tableName].core = table.core;
            }
          }
        });
      }
      __name(generateMiddlewareStacks, "generateMiddlewareStacks");
      function setApiOnPlace(db, objs, tableNames, dbschema) {
        tableNames.forEach(function(tableName) {
          var schema = dbschema[tableName];
          objs.forEach(function(obj) {
            var propDesc = getPropertyDescriptor(obj, tableName);
            if (!propDesc || "value" in propDesc && propDesc.value === void 0) {
              if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {
                setProp(obj, tableName, {
                  get: /* @__PURE__ */ __name(function() {
                    return this.table(tableName);
                  }, "get"),
                  set: /* @__PURE__ */ __name(function(value) {
                    defineProperty2(this, tableName, { value, writable: true, configurable: true, enumerable: true });
                  }, "set")
                });
              } else {
                obj[tableName] = new db.Table(tableName, schema);
              }
            }
          });
        });
      }
      __name(setApiOnPlace, "setApiOnPlace");
      function removeTablesApi(db, objs) {
        objs.forEach(function(obj) {
          for (var key in obj) {
            if (obj[key] instanceof db.Table)
              delete obj[key];
          }
        });
      }
      __name(removeTablesApi, "removeTablesApi");
      function lowerVersionFirst(a, b) {
        return a._cfg.version - b._cfg.version;
      }
      __name(lowerVersionFirst, "lowerVersionFirst");
      function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {
        var globalSchema = db._dbSchema;
        if (idbUpgradeTrans.objectStoreNames.contains("$meta") && !globalSchema.$meta) {
          globalSchema.$meta = createTableSchema("$meta", parseIndexSyntax("")[0], []);
          db._storeNames.push("$meta");
        }
        var trans = db._createTransaction("readwrite", db._storeNames, globalSchema);
        trans.create(idbUpgradeTrans);
        trans._completion.catch(reject);
        var rejectTransaction = trans._reject.bind(trans);
        var transless = PSD.transless || PSD;
        newScope(function() {
          PSD.trans = trans;
          PSD.transless = transless;
          if (oldVersion === 0) {
            keys3(globalSchema).forEach(function(tableName) {
              createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
            });
            generateMiddlewareStacks(db, idbUpgradeTrans);
            DexiePromise.follow(function() {
              return db.on.populate.fire(trans);
            }).catch(rejectTransaction);
          } else {
            generateMiddlewareStacks(db, idbUpgradeTrans);
            return getExistingVersion(db, trans, oldVersion).then(function(oldVersion2) {
              return updateTablesAndIndexes(db, oldVersion2, trans, idbUpgradeTrans);
            }).catch(rejectTransaction);
          }
        });
      }
      __name(runUpgraders, "runUpgraders");
      function patchCurrentVersion(db, idbUpgradeTrans) {
        createMissingTables(db._dbSchema, idbUpgradeTrans);
        if (idbUpgradeTrans.db.version % 10 === 0 && !idbUpgradeTrans.objectStoreNames.contains("$meta")) {
          idbUpgradeTrans.db.createObjectStore("$meta").add(Math.ceil(idbUpgradeTrans.db.version / 10 - 1), "version");
        }
        var globalSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
        adjustToExistingIndexNames(db, db._dbSchema, idbUpgradeTrans);
        var diff = getSchemaDiff(globalSchema, db._dbSchema);
        var _loop_1 = /* @__PURE__ */ __name(function(tableChange2) {
          if (tableChange2.change.length || tableChange2.recreate) {
            console.warn("Unable to patch indexes of table ".concat(tableChange2.name, " because it has changes on the type of index or primary key."));
            return { value: void 0 };
          }
          var store = idbUpgradeTrans.objectStore(tableChange2.name);
          tableChange2.add.forEach(function(idx) {
            if (debug23)
              console.debug("Dexie upgrade patch: Creating missing index ".concat(tableChange2.name, ".").concat(idx.src));
            addIndex(store, idx);
          });
        }, "_loop_1");
        for (var _i = 0, _a10 = diff.change; _i < _a10.length; _i++) {
          var tableChange = _a10[_i];
          var state_1 = _loop_1(tableChange);
          if (typeof state_1 === "object")
            return state_1.value;
        }
      }
      __name(patchCurrentVersion, "patchCurrentVersion");
      function getExistingVersion(db, trans, oldVersion) {
        if (trans.storeNames.includes("$meta")) {
          return trans.table("$meta").get("version").then(function(metaVersion) {
            return metaVersion != null ? metaVersion : oldVersion;
          });
        } else {
          return DexiePromise.resolve(oldVersion);
        }
      }
      __name(getExistingVersion, "getExistingVersion");
      function updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans) {
        var queue = [];
        var versions = db._versions;
        var globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
        var versToRun = versions.filter(function(v) {
          return v._cfg.version >= oldVersion;
        });
        if (versToRun.length === 0) {
          return DexiePromise.resolve();
        }
        versToRun.forEach(function(version) {
          queue.push(function() {
            var oldSchema = globalSchema;
            var newSchema = version._cfg.dbschema;
            adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);
            adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);
            globalSchema = db._dbSchema = newSchema;
            var diff = getSchemaDiff(oldSchema, newSchema);
            diff.add.forEach(function(tuple) {
              createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
            });
            diff.change.forEach(function(change) {
              if (change.recreate) {
                throw new exceptions.Upgrade("Not yet support for changing primary key");
              } else {
                var store_1 = idbUpgradeTrans.objectStore(change.name);
                change.add.forEach(function(idx) {
                  return addIndex(store_1, idx);
                });
                change.change.forEach(function(idx) {
                  store_1.deleteIndex(idx.name);
                  addIndex(store_1, idx);
                });
                change.del.forEach(function(idxName) {
                  return store_1.deleteIndex(idxName);
                });
              }
            });
            var contentUpgrade = version._cfg.contentUpgrade;
            if (contentUpgrade && version._cfg.version > oldVersion) {
              generateMiddlewareStacks(db, idbUpgradeTrans);
              trans._memoizedTables = {};
              var upgradeSchema_1 = shallowClone(newSchema);
              diff.del.forEach(function(table) {
                upgradeSchema_1[table] = oldSchema[table];
              });
              removeTablesApi(db, [db.Transaction.prototype]);
              setApiOnPlace(db, [db.Transaction.prototype], keys3(upgradeSchema_1), upgradeSchema_1);
              trans.schema = upgradeSchema_1;
              var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);
              if (contentUpgradeIsAsync_1) {
                incrementExpectedAwaits();
              }
              var returnValue_1;
              var promiseFollowed = DexiePromise.follow(function() {
                returnValue_1 = contentUpgrade(trans);
                if (returnValue_1) {
                  if (contentUpgradeIsAsync_1) {
                    var decrementor = decrementExpectedAwaits.bind(null, null);
                    returnValue_1.then(decrementor, decrementor);
                  }
                }
              });
              return returnValue_1 && typeof returnValue_1.then === "function" ? DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function() {
                return returnValue_1;
              });
            }
          });
          queue.push(function(idbtrans) {
            var newSchema = version._cfg.dbschema;
            deleteRemovedTables(newSchema, idbtrans);
            removeTablesApi(db, [db.Transaction.prototype]);
            setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);
            trans.schema = db._dbSchema;
          });
          queue.push(function(idbtrans) {
            if (db.idbdb.objectStoreNames.contains("$meta")) {
              if (Math.ceil(db.idbdb.version / 10) === version._cfg.version) {
                db.idbdb.deleteObjectStore("$meta");
                delete db._dbSchema.$meta;
                db._storeNames = db._storeNames.filter(function(name) {
                  return name !== "$meta";
                });
              } else {
                idbtrans.objectStore("$meta").put(version._cfg.version, "version");
              }
            }
          });
        });
        function runQueue() {
          return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();
        }
        __name(runQueue, "runQueue");
        return runQueue().then(function() {
          createMissingTables(globalSchema, idbUpgradeTrans);
        });
      }
      __name(updateTablesAndIndexes, "updateTablesAndIndexes");
      function getSchemaDiff(oldSchema, newSchema) {
        var diff = {
          del: [],
          add: [],
          change: []
        };
        var table;
        for (table in oldSchema) {
          if (!newSchema[table])
            diff.del.push(table);
        }
        for (table in newSchema) {
          var oldDef = oldSchema[table], newDef = newSchema[table];
          if (!oldDef) {
            diff.add.push([table, newDef]);
          } else {
            var change = {
              name: table,
              def: newDef,
              recreate: false,
              del: [],
              add: [],
              change: []
            };
            if ("" + (oldDef.primKey.keyPath || "") !== "" + (newDef.primKey.keyPath || "") || oldDef.primKey.auto !== newDef.primKey.auto) {
              change.recreate = true;
              diff.change.push(change);
            } else {
              var oldIndexes = oldDef.idxByName;
              var newIndexes = newDef.idxByName;
              var idxName = void 0;
              for (idxName in oldIndexes) {
                if (!newIndexes[idxName])
                  change.del.push(idxName);
              }
              for (idxName in newIndexes) {
                var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
                if (!oldIdx)
                  change.add.push(newIdx);
                else if (oldIdx.src !== newIdx.src)
                  change.change.push(newIdx);
              }
              if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
                diff.change.push(change);
              }
            }
          }
        }
        return diff;
      }
      __name(getSchemaDiff, "getSchemaDiff");
      function createTable(idbtrans, tableName, primKey, indexes) {
        var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? { keyPath: primKey.keyPath, autoIncrement: primKey.auto } : { autoIncrement: primKey.auto });
        indexes.forEach(function(idx) {
          return addIndex(store, idx);
        });
        return store;
      }
      __name(createTable, "createTable");
      function createMissingTables(newSchema, idbtrans) {
        keys3(newSchema).forEach(function(tableName) {
          if (!idbtrans.db.objectStoreNames.contains(tableName)) {
            if (debug23)
              console.debug("Dexie: Creating missing table", tableName);
            createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
          }
        });
      }
      __name(createMissingTables, "createMissingTables");
      function deleteRemovedTables(newSchema, idbtrans) {
        [].slice.call(idbtrans.db.objectStoreNames).forEach(function(storeName) {
          return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);
        });
      }
      __name(deleteRemovedTables, "deleteRemovedTables");
      function addIndex(store, idx) {
        store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
      }
      __name(addIndex, "addIndex");
      function buildGlobalSchema(db, idbdb, tmpTrans) {
        var globalSchema = {};
        var dbStoreNames = slice(idbdb.objectStoreNames, 0);
        dbStoreNames.forEach(function(storeName) {
          var store = tmpTrans.objectStore(storeName);
          var keyPath = store.keyPath;
          var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", true, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
          var indexes = [];
          for (var j = 0; j < store.indexNames.length; ++j) {
            var idbindex = store.index(store.indexNames[j]);
            keyPath = idbindex.keyPath;
            var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
            indexes.push(index);
          }
          globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
        });
        return globalSchema;
      }
      __name(buildGlobalSchema, "buildGlobalSchema");
      function readGlobalSchema(db, idbdb, tmpTrans) {
        db.verno = idbdb.version / 10;
        var globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);
        db._storeNames = slice(idbdb.objectStoreNames, 0);
        setApiOnPlace(db, [db._allTables], keys3(globalSchema), globalSchema);
      }
      __name(readGlobalSchema, "readGlobalSchema");
      function verifyInstalledSchema(db, tmpTrans) {
        var installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);
        var diff = getSchemaDiff(installedSchema, db._dbSchema);
        return !(diff.add.length || diff.change.some(function(ch) {
          return ch.add.length || ch.change.length;
        }));
      }
      __name(verifyInstalledSchema, "verifyInstalledSchema");
      function adjustToExistingIndexNames(db, schema, idbtrans) {
        var storeNames = idbtrans.db.objectStoreNames;
        for (var i = 0; i < storeNames.length; ++i) {
          var storeName = storeNames[i];
          var store = idbtrans.objectStore(storeName);
          db._hasGetAll = "getAll" in store;
          for (var j = 0; j < store.indexNames.length; ++j) {
            var indexName = store.indexNames[j];
            var keyPath = store.index(indexName).keyPath;
            var dexieName = typeof keyPath === "string" ? keyPath : "[" + slice(keyPath).join("+") + "]";
            if (schema[storeName]) {
              var indexSpec = schema[storeName].idxByName[dexieName];
              if (indexSpec) {
                indexSpec.name = indexName;
                delete schema[storeName].idxByName[dexieName];
                schema[storeName].idxByName[indexName] = indexSpec;
              }
            }
          }
        }
        if (typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && _global2.WorkerGlobalScope && _global2 instanceof _global2.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
          db._hasGetAll = false;
        }
      }
      __name(adjustToExistingIndexNames, "adjustToExistingIndexNames");
      function parseIndexSyntax(primKeyAndIndexes) {
        return primKeyAndIndexes.split(",").map(function(index, indexNum) {
          index = index.trim();
          var name = index.replace(/([&*]|\+\+)/g, "");
          var keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split("+") : name;
          return createIndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray6(keyPath), indexNum === 0);
        });
      }
      __name(parseIndexSyntax, "parseIndexSyntax");
      var Version = function() {
        function Version2() {
        }
        __name(Version2, "Version");
        Version2.prototype._parseStoresSpec = function(stores, outSchema) {
          keys3(stores).forEach(function(tableName) {
            if (stores[tableName] !== null) {
              var indexes = parseIndexSyntax(stores[tableName]);
              var primKey = indexes.shift();
              primKey.unique = true;
              if (primKey.multi)
                throw new exceptions.Schema("Primary key cannot be multi-valued");
              indexes.forEach(function(idx) {
                if (idx.auto)
                  throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
                if (!idx.keyPath)
                  throw new exceptions.Schema("Index must have a name and cannot be an empty string");
              });
              outSchema[tableName] = createTableSchema(tableName, primKey, indexes);
            }
          });
        };
        Version2.prototype.stores = function(stores) {
          var db = this.db;
          this._cfg.storesSource = this._cfg.storesSource ? extend2(this._cfg.storesSource, stores) : stores;
          var versions = db._versions;
          var storesSpec = {};
          var dbschema = {};
          versions.forEach(function(version) {
            extend2(storesSpec, version._cfg.storesSource);
            dbschema = version._cfg.dbschema = {};
            version._parseStoresSpec(storesSpec, dbschema);
          });
          db._dbSchema = dbschema;
          removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);
          setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys3(dbschema), dbschema);
          db._storeNames = keys3(dbschema);
          return this;
        };
        Version2.prototype.upgrade = function(upgradeFunction) {
          this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);
          return this;
        };
        return Version2;
      }();
      function createVersionConstructor(db) {
        return makeClassConstructor(Version.prototype, /* @__PURE__ */ __name(function Version2(versionNumber) {
          this.db = db;
          this._cfg = {
            version: versionNumber,
            storesSource: null,
            dbschema: {},
            tables: {},
            contentUpgrade: null
          };
        }, "Version"));
      }
      __name(createVersionConstructor, "createVersionConstructor");
      function getDbNamesTable(indexedDB2, IDBKeyRange2) {
        var dbNamesDB = indexedDB2["_dbNamesDB"];
        if (!dbNamesDB) {
          dbNamesDB = indexedDB2["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
            addons: [],
            indexedDB: indexedDB2,
            IDBKeyRange: IDBKeyRange2
          });
          dbNamesDB.version(1).stores({ dbnames: "name" });
        }
        return dbNamesDB.table("dbnames");
      }
      __name(getDbNamesTable, "getDbNamesTable");
      function hasDatabasesNative(indexedDB2) {
        return indexedDB2 && typeof indexedDB2.databases === "function";
      }
      __name(hasDatabasesNative, "hasDatabasesNative");
      function getDatabaseNames(_a10) {
        var indexedDB2 = _a10.indexedDB, IDBKeyRange2 = _a10.IDBKeyRange;
        return hasDatabasesNative(indexedDB2) ? Promise.resolve(indexedDB2.databases()).then(function(infos) {
          return infos.map(function(info) {
            return info.name;
          }).filter(function(name) {
            return name !== DBNAMES_DB;
          });
        }) : getDbNamesTable(indexedDB2, IDBKeyRange2).toCollection().primaryKeys();
      }
      __name(getDatabaseNames, "getDatabaseNames");
      function _onDatabaseCreated(_a10, name) {
        var indexedDB2 = _a10.indexedDB, IDBKeyRange2 = _a10.IDBKeyRange;
        !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange2).put({ name }).catch(nop);
      }
      __name(_onDatabaseCreated, "_onDatabaseCreated");
      function _onDatabaseDeleted(_a10, name) {
        var indexedDB2 = _a10.indexedDB, IDBKeyRange2 = _a10.IDBKeyRange;
        !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange2).delete(name).catch(nop);
      }
      __name(_onDatabaseDeleted, "_onDatabaseDeleted");
      function vip(fn) {
        return newScope(function() {
          PSD.letThrough = true;
          return fn();
        });
      }
      __name(vip, "vip");
      function idbReady() {
        var isSafari = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent);
        if (!isSafari || !indexedDB.databases)
          return Promise.resolve();
        var intervalId;
        return new Promise(function(resolve) {
          var tryIdb = /* @__PURE__ */ __name(function() {
            return indexedDB.databases().finally(resolve);
          }, "tryIdb");
          intervalId = setInterval(tryIdb, 100);
          tryIdb();
        }).finally(function() {
          return clearInterval(intervalId);
        });
      }
      __name(idbReady, "idbReady");
      var _a9;
      function isEmptyRange(node) {
        return !("from" in node);
      }
      __name(isEmptyRange, "isEmptyRange");
      var RangeSet3 = /* @__PURE__ */ __name(function(fromOrTree, to) {
        if (this) {
          extend2(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });
        } else {
          var rv = new RangeSet3();
          if (fromOrTree && "d" in fromOrTree) {
            extend2(rv, fromOrTree);
          }
          return rv;
        }
      }, "RangeSet");
      props(RangeSet3.prototype, (_a9 = {
        add: /* @__PURE__ */ __name(function(rangeSet) {
          mergeRanges2(this, rangeSet);
          return this;
        }, "add"),
        addKey: /* @__PURE__ */ __name(function(key) {
          addRange(this, key, key);
          return this;
        }, "addKey"),
        addKeys: /* @__PURE__ */ __name(function(keys4) {
          var _this = this;
          keys4.forEach(function(key) {
            return addRange(_this, key, key);
          });
          return this;
        }, "addKeys"),
        hasKey: /* @__PURE__ */ __name(function(key) {
          var node = getRangeSetIterator(this).next(key).value;
          return node && cmp2(node.from, key) <= 0 && cmp2(node.to, key) >= 0;
        }, "hasKey")
      }, _a9[iteratorSymbol] = function() {
        return getRangeSetIterator(this);
      }, _a9));
      function addRange(target, from3, to) {
        var diff = cmp2(from3, to);
        if (isNaN(diff))
          return;
        if (diff > 0)
          throw RangeError();
        if (isEmptyRange(target))
          return extend2(target, { from: from3, to, d: 1 });
        var left = target.l;
        var right = target.r;
        if (cmp2(to, target.from) < 0) {
          left ? addRange(left, from3, to) : target.l = { from: from3, to, d: 1, l: null, r: null };
          return rebalance(target);
        }
        if (cmp2(from3, target.to) > 0) {
          right ? addRange(right, from3, to) : target.r = { from: from3, to, d: 1, l: null, r: null };
          return rebalance(target);
        }
        if (cmp2(from3, target.from) < 0) {
          target.from = from3;
          target.l = null;
          target.d = right ? right.d + 1 : 1;
        }
        if (cmp2(to, target.to) > 0) {
          target.to = to;
          target.r = null;
          target.d = target.l ? target.l.d + 1 : 1;
        }
        var rightWasCutOff = !target.r;
        if (left && !target.l) {
          mergeRanges2(target, left);
        }
        if (right && rightWasCutOff) {
          mergeRanges2(target, right);
        }
      }
      __name(addRange, "addRange");
      function mergeRanges2(target, newSet) {
        function _addRangeSet(target2, _a10) {
          var from3 = _a10.from, to = _a10.to, l = _a10.l, r = _a10.r;
          addRange(target2, from3, to);
          if (l)
            _addRangeSet(target2, l);
          if (r)
            _addRangeSet(target2, r);
        }
        __name(_addRangeSet, "_addRangeSet");
        if (!isEmptyRange(newSet))
          _addRangeSet(target, newSet);
      }
      __name(mergeRanges2, "mergeRanges");
      function rangesOverlap2(rangeSet1, rangeSet2) {
        var i1 = getRangeSetIterator(rangeSet2);
        var nextResult1 = i1.next();
        if (nextResult1.done)
          return false;
        var a = nextResult1.value;
        var i2 = getRangeSetIterator(rangeSet1);
        var nextResult2 = i2.next(a.from);
        var b = nextResult2.value;
        while (!nextResult1.done && !nextResult2.done) {
          if (cmp2(b.from, a.to) <= 0 && cmp2(b.to, a.from) >= 0)
            return true;
          cmp2(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;
        }
        return false;
      }
      __name(rangesOverlap2, "rangesOverlap");
      function getRangeSetIterator(node) {
        var state = isEmptyRange(node) ? null : { s: 0, n: node };
        return {
          next: /* @__PURE__ */ __name(function(key) {
            var keyProvided = arguments.length > 0;
            while (state) {
              switch (state.s) {
                case 0:
                  state.s = 1;
                  if (keyProvided) {
                    while (state.n.l && cmp2(key, state.n.from) < 0)
                      state = { up: state, n: state.n.l, s: 1 };
                  } else {
                    while (state.n.l)
                      state = { up: state, n: state.n.l, s: 1 };
                  }
                case 1:
                  state.s = 2;
                  if (!keyProvided || cmp2(key, state.n.to) <= 0)
                    return { value: state.n, done: false };
                case 2:
                  if (state.n.r) {
                    state.s = 3;
                    state = { up: state, n: state.n.r, s: 0 };
                    continue;
                  }
                case 3:
                  state = state.up;
              }
            }
            return { done: true };
          }, "next")
        };
      }
      __name(getRangeSetIterator, "getRangeSetIterator");
      function rebalance(target) {
        var _a10, _b2;
        var diff = (((_a10 = target.r) === null || _a10 === void 0 ? void 0 : _a10.d) || 0) - (((_b2 = target.l) === null || _b2 === void 0 ? void 0 : _b2.d) || 0);
        var r = diff > 1 ? "r" : diff < -1 ? "l" : "";
        if (r) {
          var l = r === "r" ? "l" : "r";
          var rootClone = __assign({}, target);
          var oldRootRight = target[r];
          target.from = oldRootRight.from;
          target.to = oldRootRight.to;
          target[r] = oldRootRight[r];
          rootClone[r] = oldRootRight[l];
          target[l] = rootClone;
          rootClone.d = computeDepth(rootClone);
        }
        target.d = computeDepth(target);
      }
      __name(rebalance, "rebalance");
      function computeDepth(_a10) {
        var r = _a10.r, l = _a10.l;
        return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;
      }
      __name(computeDepth, "computeDepth");
      function extendObservabilitySet(target, newSet) {
        keys3(newSet).forEach(function(part) {
          if (target[part])
            mergeRanges2(target[part], newSet[part]);
          else
            target[part] = cloneSimpleObjectTree(newSet[part]);
        });
        return target;
      }
      __name(extendObservabilitySet, "extendObservabilitySet");
      function obsSetsOverlap(os1, os2) {
        return os1.all || os2.all || Object.keys(os1).some(function(key) {
          return os2[key] && rangesOverlap2(os2[key], os1[key]);
        });
      }
      __name(obsSetsOverlap, "obsSetsOverlap");
      var cache = {};
      var unsignaledParts = {};
      var isTaskEnqueued = false;
      function signalSubscribersLazily(part, optimistic) {
        extendObservabilitySet(unsignaledParts, part);
        if (!isTaskEnqueued) {
          isTaskEnqueued = true;
          setTimeout(function() {
            isTaskEnqueued = false;
            var parts = unsignaledParts;
            unsignaledParts = {};
            signalSubscribersNow(parts, false);
          }, 0);
        }
      }
      __name(signalSubscribersLazily, "signalSubscribersLazily");
      function signalSubscribersNow(updatedParts, deleteAffectedCacheEntries) {
        if (deleteAffectedCacheEntries === void 0) {
          deleteAffectedCacheEntries = false;
        }
        var queriesToSignal = /* @__PURE__ */ new Set();
        if (updatedParts.all) {
          for (var _i = 0, _a10 = Object.values(cache); _i < _a10.length; _i++) {
            var tblCache = _a10[_i];
            collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);
          }
        } else {
          for (var key in updatedParts) {
            var parts = /^idb\:\/\/(.*)\/(.*)\//.exec(key);
            if (parts) {
              var dbName = parts[1], tableName = parts[2];
              var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
              if (tblCache)
                collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);
            }
          }
        }
        queriesToSignal.forEach(function(requery) {
          return requery();
        });
      }
      __name(signalSubscribersNow, "signalSubscribersNow");
      function collectTableSubscribers(tblCache, updatedParts, outQueriesToSignal, deleteAffectedCacheEntries) {
        var updatedEntryLists = [];
        for (var _i = 0, _a10 = Object.entries(tblCache.queries.query); _i < _a10.length; _i++) {
          var _b2 = _a10[_i], indexName = _b2[0], entries = _b2[1];
          var filteredEntries = [];
          for (var _c = 0, entries_1 = entries; _c < entries_1.length; _c++) {
            var entry = entries_1[_c];
            if (obsSetsOverlap(updatedParts, entry.obsSet)) {
              entry.subscribers.forEach(function(requery) {
                return outQueriesToSignal.add(requery);
              });
            } else if (deleteAffectedCacheEntries) {
              filteredEntries.push(entry);
            }
          }
          if (deleteAffectedCacheEntries)
            updatedEntryLists.push([indexName, filteredEntries]);
        }
        if (deleteAffectedCacheEntries) {
          for (var _d = 0, updatedEntryLists_1 = updatedEntryLists; _d < updatedEntryLists_1.length; _d++) {
            var _e = updatedEntryLists_1[_d], indexName = _e[0], filteredEntries = _e[1];
            tblCache.queries.query[indexName] = filteredEntries;
          }
        }
      }
      __name(collectTableSubscribers, "collectTableSubscribers");
      function dexieOpen(db) {
        var state = db._state;
        var indexedDB2 = db._deps.indexedDB;
        if (state.isBeingOpened || db.idbdb)
          return state.dbReadyPromise.then(function() {
            return state.dbOpenError ? rejection(state.dbOpenError) : db;
          });
        state.isBeingOpened = true;
        state.dbOpenError = null;
        state.openComplete = false;
        var openCanceller = state.openCanceller;
        var nativeVerToOpen = Math.round(db.verno * 10);
        var schemaPatchMode = false;
        function throwIfCancelled() {
          if (state.openCanceller !== openCanceller)
            throw new exceptions.DatabaseClosed("db.open() was cancelled");
        }
        __name(throwIfCancelled, "throwIfCancelled");
        var resolveDbReady = state.dbReadyResolve, upgradeTransaction = null, wasCreated = false;
        var tryOpenDB = /* @__PURE__ */ __name(function() {
          return new DexiePromise(function(resolve, reject) {
            throwIfCancelled();
            if (!indexedDB2)
              throw new exceptions.MissingAPI();
            var dbName = db.name;
            var req = state.autoSchema || !nativeVerToOpen ? indexedDB2.open(dbName) : indexedDB2.open(dbName, nativeVerToOpen);
            if (!req)
              throw new exceptions.MissingAPI();
            req.onerror = eventRejectHandler(reject);
            req.onblocked = wrap(db._fireOnBlocked);
            req.onupgradeneeded = wrap(function(e) {
              upgradeTransaction = req.transaction;
              if (state.autoSchema && !db._options.allowEmptyDB) {
                req.onerror = preventDefault;
                upgradeTransaction.abort();
                req.result.close();
                var delreq = indexedDB2.deleteDatabase(dbName);
                delreq.onsuccess = delreq.onerror = wrap(function() {
                  reject(new exceptions.NoSuchDatabase("Database ".concat(dbName, " doesnt exist")));
                });
              } else {
                upgradeTransaction.onerror = eventRejectHandler(reject);
                var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
                wasCreated = oldVer < 1;
                db.idbdb = req.result;
                if (schemaPatchMode) {
                  patchCurrentVersion(db, upgradeTransaction);
                }
                runUpgraders(db, oldVer / 10, upgradeTransaction, reject);
              }
            }, reject);
            req.onsuccess = wrap(function() {
              upgradeTransaction = null;
              var idbdb = db.idbdb = req.result;
              var objectStoreNames = slice(idbdb.objectStoreNames);
              if (objectStoreNames.length > 0)
                try {
                  var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), "readonly");
                  if (state.autoSchema)
                    readGlobalSchema(db, idbdb, tmpTrans);
                  else {
                    adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);
                    if (!verifyInstalledSchema(db, tmpTrans) && !schemaPatchMode) {
                      console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this.");
                      idbdb.close();
                      nativeVerToOpen = idbdb.version + 1;
                      schemaPatchMode = true;
                      return resolve(tryOpenDB());
                    }
                  }
                  generateMiddlewareStacks(db, tmpTrans);
                } catch (e) {
                }
              connections.push(db);
              idbdb.onversionchange = wrap(function(ev) {
                state.vcFired = true;
                db.on("versionchange").fire(ev);
              });
              idbdb.onclose = wrap(function(ev) {
                db.on("close").fire(ev);
              });
              if (wasCreated)
                _onDatabaseCreated(db._deps, dbName);
              resolve();
            }, reject);
          }).catch(function(err2) {
            switch (err2 === null || err2 === void 0 ? void 0 : err2.name) {
              case "UnknownError":
                if (state.PR1398_maxLoop > 0) {
                  state.PR1398_maxLoop--;
                  console.warn("Dexie: Workaround for Chrome UnknownError on open()");
                  return tryOpenDB();
                }
                break;
              case "VersionError":
                if (nativeVerToOpen > 0) {
                  nativeVerToOpen = 0;
                  return tryOpenDB();
                }
                break;
            }
            return DexiePromise.reject(err2);
          });
        }, "tryOpenDB");
        return DexiePromise.race([
          openCanceller,
          (typeof navigator === "undefined" ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)
        ]).then(function() {
          throwIfCancelled();
          state.onReadyBeingFired = [];
          return DexiePromise.resolve(vip(function() {
            return db.on.ready.fire(db.vip);
          })).then(/* @__PURE__ */ __name(function fireRemainders() {
            if (state.onReadyBeingFired.length > 0) {
              var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);
              state.onReadyBeingFired = [];
              return DexiePromise.resolve(vip(function() {
                return remainders_1(db.vip);
              })).then(fireRemainders);
            }
          }, "fireRemainders"));
        }).finally(function() {
          if (state.openCanceller === openCanceller) {
            state.onReadyBeingFired = null;
            state.isBeingOpened = false;
          }
        }).catch(function(err2) {
          state.dbOpenError = err2;
          try {
            upgradeTransaction && upgradeTransaction.abort();
          } catch (_a10) {
          }
          if (openCanceller === state.openCanceller) {
            db._close();
          }
          return rejection(err2);
        }).finally(function() {
          state.openComplete = true;
          resolveDbReady();
        }).then(function() {
          if (wasCreated) {
            var everything_1 = {};
            db.tables.forEach(function(table) {
              table.schema.indexes.forEach(function(idx) {
                if (idx.name)
                  everything_1["idb://".concat(db.name, "/").concat(table.name, "/").concat(idx.name)] = new RangeSet3(-Infinity, [[[]]]);
              });
              everything_1["idb://".concat(db.name, "/").concat(table.name, "/")] = everything_1["idb://".concat(db.name, "/").concat(table.name, "/:dels")] = new RangeSet3(-Infinity, [[[]]]);
            });
            globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME).fire(everything_1);
            signalSubscribersNow(everything_1, true);
          }
          return db;
        });
      }
      __name(dexieOpen, "dexieOpen");
      function awaitIterator(iterator3) {
        var callNext = /* @__PURE__ */ __name(function(result) {
          return iterator3.next(result);
        }, "callNext"), doThrow = /* @__PURE__ */ __name(function(error) {
          return iterator3.throw(error);
        }, "doThrow"), onSuccess = step(callNext), onError = step(doThrow);
        function step(getNext) {
          return function(val) {
            var next = getNext(val), value = next.value;
            return next.done ? value : !value || typeof value.then !== "function" ? isArray6(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);
          };
        }
        __name(step, "step");
        return step(callNext)();
      }
      __name(awaitIterator, "awaitIterator");
      function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
        var i = arguments.length;
        if (i < 2)
          throw new exceptions.InvalidArgument("Too few arguments");
        var args2 = new Array(i - 1);
        while (--i)
          args2[i - 1] = arguments[i];
        scopeFunc = args2.pop();
        var tables = flatten(args2);
        return [mode, tables, scopeFunc];
      }
      __name(extractTransactionArgs, "extractTransactionArgs");
      function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {
        return DexiePromise.resolve().then(function() {
          var transless = PSD.transless || PSD;
          var trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);
          trans.explicit = true;
          var zoneProps = {
            trans,
            transless
          };
          if (parentTransaction) {
            trans.idbtrans = parentTransaction.idbtrans;
          } else {
            try {
              trans.create();
              trans.idbtrans._explicit = true;
              db._state.PR1398_maxLoop = 3;
            } catch (ex) {
              if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
                console.warn("Dexie: Need to reopen db");
                db.close({ disableAutoOpen: false });
                return db.open().then(function() {
                  return enterTransactionScope(db, mode, storeNames, null, scopeFunc);
                });
              }
              return rejection(ex);
            }
          }
          var scopeFuncIsAsync = isAsyncFunction(scopeFunc);
          if (scopeFuncIsAsync) {
            incrementExpectedAwaits();
          }
          var returnValue;
          var promiseFollowed = DexiePromise.follow(function() {
            returnValue = scopeFunc.call(trans, trans);
            if (returnValue) {
              if (scopeFuncIsAsync) {
                var decrementor = decrementExpectedAwaits.bind(null, null);
                returnValue.then(decrementor, decrementor);
              } else if (typeof returnValue.next === "function" && typeof returnValue.throw === "function") {
                returnValue = awaitIterator(returnValue);
              }
            }
          }, zoneProps);
          return (returnValue && typeof returnValue.then === "function" ? DexiePromise.resolve(returnValue).then(function(x) {
            return trans.active ? x : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
          }) : promiseFollowed.then(function() {
            return returnValue;
          })).then(function(x) {
            if (parentTransaction)
              trans._resolve();
            return trans._completion.then(function() {
              return x;
            });
          }).catch(function(e) {
            trans._reject(e);
            return rejection(e);
          });
        });
      }
      __name(enterTransactionScope, "enterTransactionScope");
      function pad(a, value, count2) {
        var result = isArray6(a) ? a.slice() : [a];
        for (var i = 0; i < count2; ++i)
          result.push(value);
        return result;
      }
      __name(pad, "pad");
      function createVirtualIndexMiddleware(down) {
        return __assign(__assign({}, down), { table: /* @__PURE__ */ __name(function(tableName) {
          var table = down.table(tableName);
          var schema = table.schema;
          var indexLookup = {};
          var allVirtualIndexes = [];
          function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
            var keyPathAlias = getKeyPathAlias(keyPath);
            var indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];
            var keyLength = keyPath == null ? 0 : typeof keyPath === "string" ? 1 : keyPath.length;
            var isVirtual = keyTail > 0;
            var virtualIndex = __assign(__assign({}, lowLevelIndex), { name: isVirtual ? "".concat(keyPathAlias, "(virtual-from:").concat(lowLevelIndex.name, ")") : lowLevelIndex.name, lowLevelIndex, isVirtual, keyTail, keyLength, extractKey: getKeyExtractor(keyPath), unique: !isVirtual && lowLevelIndex.unique });
            indexList.push(virtualIndex);
            if (!virtualIndex.isPrimaryKey) {
              allVirtualIndexes.push(virtualIndex);
            }
            if (keyLength > 1) {
              var virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);
              addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
            }
            indexList.sort(function(a, b) {
              return a.keyTail - b.keyTail;
            });
            return virtualIndex;
          }
          __name(addVirtualIndexes, "addVirtualIndexes");
          var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
          indexLookup[":id"] = [primaryKey];
          for (var _i = 0, _a10 = schema.indexes; _i < _a10.length; _i++) {
            var index = _a10[_i];
            addVirtualIndexes(index.keyPath, 0, index);
          }
          function findBestIndex(keyPath) {
            var result2 = indexLookup[getKeyPathAlias(keyPath)];
            return result2 && result2[0];
          }
          __name(findBestIndex, "findBestIndex");
          function translateRange(range, keyTail) {
            return {
              type: range.type === 1 ? 2 : range.type,
              lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
              lowerOpen: true,
              upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
              upperOpen: true
            };
          }
          __name(translateRange, "translateRange");
          function translateRequest(req) {
            var index2 = req.query.index;
            return index2.isVirtual ? __assign(__assign({}, req), { query: {
              index: index2.lowLevelIndex,
              range: translateRange(req.query.range, index2.keyTail)
            } }) : req;
          }
          __name(translateRequest, "translateRequest");
          var result = __assign(__assign({}, table), { schema: __assign(__assign({}, schema), { primaryKey, indexes: allVirtualIndexes, getIndexByKeyPath: findBestIndex }), count: /* @__PURE__ */ __name(function(req) {
            return table.count(translateRequest(req));
          }, "count"), query: /* @__PURE__ */ __name(function(req) {
            return table.query(translateRequest(req));
          }, "query"), openCursor: /* @__PURE__ */ __name(function(req) {
            var _a11 = req.query.index, keyTail = _a11.keyTail, isVirtual = _a11.isVirtual, keyLength = _a11.keyLength;
            if (!isVirtual)
              return table.openCursor(req);
            function createVirtualCursor(cursor) {
              function _continue(key) {
                key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();
              }
              __name(_continue, "_continue");
              var virtualCursor = Object.create(cursor, {
                continue: { value: _continue },
                continuePrimaryKey: {
                  value: /* @__PURE__ */ __name(function(key, primaryKey2) {
                    cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey2);
                  }, "value")
                },
                primaryKey: {
                  get: /* @__PURE__ */ __name(function() {
                    return cursor.primaryKey;
                  }, "get")
                },
                key: {
                  get: /* @__PURE__ */ __name(function() {
                    var key = cursor.key;
                    return keyLength === 1 ? key[0] : key.slice(0, keyLength);
                  }, "get")
                },
                value: {
                  get: /* @__PURE__ */ __name(function() {
                    return cursor.value;
                  }, "get")
                }
              });
              return virtualCursor;
            }
            __name(createVirtualCursor, "createVirtualCursor");
            return table.openCursor(translateRequest(req)).then(function(cursor) {
              return cursor && createVirtualCursor(cursor);
            });
          }, "openCursor") });
          return result;
        }, "table") });
      }
      __name(createVirtualIndexMiddleware, "createVirtualIndexMiddleware");
      var virtualIndexMiddleware = {
        stack: "dbcore",
        name: "VirtualIndexMiddleware",
        level: 1,
        create: createVirtualIndexMiddleware
      };
      function getObjectDiff(a, b, rv, prfx) {
        rv = rv || {};
        prfx = prfx || "";
        keys3(a).forEach(function(prop) {
          if (!hasOwn(b, prop)) {
            rv[prfx + prop] = void 0;
          } else {
            var ap = a[prop], bp = b[prop];
            if (typeof ap === "object" && typeof bp === "object" && ap && bp) {
              var apTypeName = toStringTag2(ap);
              var bpTypeName = toStringTag2(bp);
              if (apTypeName !== bpTypeName) {
                rv[prfx + prop] = b[prop];
              } else if (apTypeName === "Object") {
                getObjectDiff(ap, bp, rv, prfx + prop + ".");
              } else if (ap !== bp) {
                rv[prfx + prop] = b[prop];
              }
            } else if (ap !== bp)
              rv[prfx + prop] = b[prop];
          }
        });
        keys3(b).forEach(function(prop) {
          if (!hasOwn(a, prop)) {
            rv[prfx + prop] = b[prop];
          }
        });
        return rv;
      }
      __name(getObjectDiff, "getObjectDiff");
      function getEffectiveKeys(primaryKey, req) {
        if (req.type === "delete")
          return req.keys;
        return req.keys || req.values.map(primaryKey.extractKey);
      }
      __name(getEffectiveKeys, "getEffectiveKeys");
      var hooksMiddleware = {
        stack: "dbcore",
        name: "HooksMiddleware",
        level: 2,
        create: /* @__PURE__ */ __name(function(downCore) {
          return __assign(__assign({}, downCore), { table: /* @__PURE__ */ __name(function(tableName) {
            var downTable = downCore.table(tableName);
            var primaryKey = downTable.schema.primaryKey;
            var tableMiddleware = __assign(__assign({}, downTable), { mutate: /* @__PURE__ */ __name(function(req) {
              var dxTrans = PSD.trans;
              var _a10 = dxTrans.table(tableName).hook, deleting = _a10.deleting, creating = _a10.creating, updating = _a10.updating;
              switch (req.type) {
                case "add":
                  if (creating.fire === nop)
                    break;
                  return dxTrans._promise("readwrite", function() {
                    return addPutOrDelete(req);
                  }, true);
                case "put":
                  if (creating.fire === nop && updating.fire === nop)
                    break;
                  return dxTrans._promise("readwrite", function() {
                    return addPutOrDelete(req);
                  }, true);
                case "delete":
                  if (deleting.fire === nop)
                    break;
                  return dxTrans._promise("readwrite", function() {
                    return addPutOrDelete(req);
                  }, true);
                case "deleteRange":
                  if (deleting.fire === nop)
                    break;
                  return dxTrans._promise("readwrite", function() {
                    return deleteRange(req);
                  }, true);
              }
              return downTable.mutate(req);
              function addPutOrDelete(req2) {
                var dxTrans2 = PSD.trans;
                var keys4 = req2.keys || getEffectiveKeys(primaryKey, req2);
                if (!keys4)
                  throw new Error("Keys missing");
                req2 = req2.type === "add" || req2.type === "put" ? __assign(__assign({}, req2), { keys: keys4 }) : __assign({}, req2);
                if (req2.type !== "delete")
                  req2.values = __spreadArray2([], req2.values, true);
                if (req2.keys)
                  req2.keys = __spreadArray2([], req2.keys, true);
                return getExistingValues(downTable, req2, keys4).then(function(existingValues) {
                  var contexts = keys4.map(function(key, i) {
                    var existingValue = existingValues[i];
                    var ctx = { onerror: null, onsuccess: null };
                    if (req2.type === "delete") {
                      deleting.fire.call(ctx, key, existingValue, dxTrans2);
                    } else if (req2.type === "add" || existingValue === void 0) {
                      var generatedPrimaryKey = creating.fire.call(ctx, key, req2.values[i], dxTrans2);
                      if (key == null && generatedPrimaryKey != null) {
                        key = generatedPrimaryKey;
                        req2.keys[i] = key;
                        if (!primaryKey.outbound) {
                          setByKeyPath(req2.values[i], primaryKey.keyPath, key);
                        }
                      }
                    } else {
                      var objectDiff = getObjectDiff(existingValue, req2.values[i]);
                      var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans2);
                      if (additionalChanges_1) {
                        var requestedValue_1 = req2.values[i];
                        Object.keys(additionalChanges_1).forEach(function(keyPath) {
                          if (hasOwn(requestedValue_1, keyPath)) {
                            requestedValue_1[keyPath] = additionalChanges_1[keyPath];
                          } else {
                            setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);
                          }
                        });
                      }
                    }
                    return ctx;
                  });
                  return downTable.mutate(req2).then(function(_a11) {
                    var failures = _a11.failures, results = _a11.results, numFailures = _a11.numFailures, lastResult = _a11.lastResult;
                    for (var i = 0; i < keys4.length; ++i) {
                      var primKey = results ? results[i] : keys4[i];
                      var ctx = contexts[i];
                      if (primKey == null) {
                        ctx.onerror && ctx.onerror(failures[i]);
                      } else {
                        ctx.onsuccess && ctx.onsuccess(
                          req2.type === "put" && existingValues[i] ? req2.values[i] : primKey
                        );
                      }
                    }
                    return { failures, results, numFailures, lastResult };
                  }).catch(function(error) {
                    contexts.forEach(function(ctx) {
                      return ctx.onerror && ctx.onerror(error);
                    });
                    return Promise.reject(error);
                  });
                });
              }
              __name(addPutOrDelete, "addPutOrDelete");
              function deleteRange(req2) {
                return deleteNextChunk(req2.trans, req2.range, 1e4);
              }
              __name(deleteRange, "deleteRange");
              function deleteNextChunk(trans, range, limit) {
                return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit }).then(function(_a11) {
                  var result = _a11.result;
                  return addPutOrDelete({ type: "delete", keys: result, trans }).then(function(res) {
                    if (res.numFailures > 0)
                      return Promise.reject(res.failures[0]);
                    if (result.length < limit) {
                      return { failures: [], numFailures: 0, lastResult: void 0 };
                    } else {
                      return deleteNextChunk(trans, __assign(__assign({}, range), { lower: result[result.length - 1], lowerOpen: true }), limit);
                    }
                  });
                });
              }
              __name(deleteNextChunk, "deleteNextChunk");
            }, "mutate") });
            return tableMiddleware;
          }, "table") });
        }, "create")
      };
      function getExistingValues(table, req, effectiveKeys) {
        return req.type === "add" ? Promise.resolve([]) : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: "immutable" });
      }
      __name(getExistingValues, "getExistingValues");
      function getFromTransactionCache(keys4, cache2, clone) {
        try {
          if (!cache2)
            return null;
          if (cache2.keys.length < keys4.length)
            return null;
          var result = [];
          for (var i = 0, j = 0; i < cache2.keys.length && j < keys4.length; ++i) {
            if (cmp2(cache2.keys[i], keys4[j]) !== 0)
              continue;
            result.push(clone ? deepClone(cache2.values[i]) : cache2.values[i]);
            ++j;
          }
          return result.length === keys4.length ? result : null;
        } catch (_a10) {
          return null;
        }
      }
      __name(getFromTransactionCache, "getFromTransactionCache");
      var cacheExistingValuesMiddleware = {
        stack: "dbcore",
        level: -1,
        create: /* @__PURE__ */ __name(function(core) {
          return {
            table: /* @__PURE__ */ __name(function(tableName) {
              var table = core.table(tableName);
              return __assign(__assign({}, table), { getMany: /* @__PURE__ */ __name(function(req) {
                if (!req.cache) {
                  return table.getMany(req);
                }
                var cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");
                if (cachedResult) {
                  return DexiePromise.resolve(cachedResult);
                }
                return table.getMany(req).then(function(res) {
                  req.trans["_cache"] = {
                    keys: req.keys,
                    values: req.cache === "clone" ? deepClone(res) : res
                  };
                  return res;
                });
              }, "getMany"), mutate: /* @__PURE__ */ __name(function(req) {
                if (req.type !== "add")
                  req.trans["_cache"] = null;
                return table.mutate(req);
              }, "mutate") });
            }, "table")
          };
        }, "create")
      };
      function isCachableContext(ctx, table) {
        return ctx.trans.mode === "readonly" && !!ctx.subscr && !ctx.trans.explicit && ctx.trans.db._options.cache !== "disabled" && !table.schema.primaryKey.outbound;
      }
      __name(isCachableContext, "isCachableContext");
      function isCachableRequest(type2, req) {
        switch (type2) {
          case "query":
            return req.values && !req.unique;
          case "get":
            return false;
          case "getMany":
            return false;
          case "count":
            return false;
          case "openCursor":
            return false;
        }
      }
      __name(isCachableRequest, "isCachableRequest");
      var observabilityMiddleware = {
        stack: "dbcore",
        level: 0,
        name: "Observability",
        create: /* @__PURE__ */ __name(function(core) {
          var dbName = core.schema.name;
          var FULL_RANGE = new RangeSet3(core.MIN_KEY, core.MAX_KEY);
          return __assign(__assign({}, core), { transaction: /* @__PURE__ */ __name(function(stores, mode, options) {
            if (PSD.subscr && mode !== "readonly") {
              throw new exceptions.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(PSD.querier));
            }
            return core.transaction(stores, mode, options);
          }, "transaction"), table: /* @__PURE__ */ __name(function(tableName) {
            var table = core.table(tableName);
            var schema = table.schema;
            var primaryKey = schema.primaryKey, indexes = schema.indexes;
            var extractKey = primaryKey.extractKey, outbound = primaryKey.outbound;
            var indexesWithAutoIncPK = primaryKey.autoIncrement && indexes.filter(function(index) {
              return index.compound && index.keyPath.includes(primaryKey.keyPath);
            });
            var tableClone = __assign(__assign({}, table), { mutate: /* @__PURE__ */ __name(function(req) {
              var _a10, _b2;
              var trans = req.trans;
              var mutatedParts = req.mutatedParts || (req.mutatedParts = {});
              var getRangeSet = /* @__PURE__ */ __name(function(indexName) {
                var part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                return mutatedParts[part] || (mutatedParts[part] = new RangeSet3());
              }, "getRangeSet");
              var pkRangeSet = getRangeSet("");
              var delsRangeSet = getRangeSet(":dels");
              var type2 = req.type;
              var _c = req.type === "deleteRange" ? [req.range] : req.type === "delete" ? [req.keys] : req.values.length < 50 ? [getEffectiveKeys(primaryKey, req).filter(function(id2) {
                return id2;
              }), req.values] : [], keys4 = _c[0], newObjs = _c[1];
              var oldCache = req.trans["_cache"];
              if (isArray6(keys4)) {
                pkRangeSet.addKeys(keys4);
                var oldObjs = type2 === "delete" || keys4.length === newObjs.length ? getFromTransactionCache(keys4, oldCache) : null;
                if (!oldObjs) {
                  delsRangeSet.addKeys(keys4);
                }
                if (oldObjs || newObjs) {
                  trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                }
              } else if (keys4) {
                var range = {
                  from: (_a10 = keys4.lower) !== null && _a10 !== void 0 ? _a10 : core.MIN_KEY,
                  to: (_b2 = keys4.upper) !== null && _b2 !== void 0 ? _b2 : core.MAX_KEY
                };
                delsRangeSet.add(range);
                pkRangeSet.add(range);
              } else {
                pkRangeSet.add(FULL_RANGE);
                delsRangeSet.add(FULL_RANGE);
                schema.indexes.forEach(function(idx) {
                  return getRangeSet(idx.name).add(FULL_RANGE);
                });
              }
              return table.mutate(req).then(function(res) {
                if (keys4 && (req.type === "add" || req.type === "put")) {
                  pkRangeSet.addKeys(res.results);
                  if (indexesWithAutoIncPK) {
                    indexesWithAutoIncPK.forEach(function(idx) {
                      var idxVals = req.values.map(function(v) {
                        return idx.extractKey(v);
                      });
                      var pkPos = idx.keyPath.findIndex(function(prop) {
                        return prop === primaryKey.keyPath;
                      });
                      for (var i = 0, len = res.results.length; i < len; ++i) {
                        idxVals[i][pkPos] = res.results[i];
                      }
                      getRangeSet(idx.name).addKeys(idxVals);
                    });
                  }
                }
                trans.mutatedParts = extendObservabilitySet(trans.mutatedParts || {}, mutatedParts);
                return res;
              });
            }, "mutate") });
            var getRange = /* @__PURE__ */ __name(function(_a10) {
              var _b2, _c;
              var _d = _a10.query, index = _d.index, range = _d.range;
              return [
                index,
                new RangeSet3((_b2 = range.lower) !== null && _b2 !== void 0 ? _b2 : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY)
              ];
            }, "getRange");
            var readSubscribers = {
              get: /* @__PURE__ */ __name(function(req) {
                return [primaryKey, new RangeSet3(req.key)];
              }, "get"),
              getMany: /* @__PURE__ */ __name(function(req) {
                return [primaryKey, new RangeSet3().addKeys(req.keys)];
              }, "getMany"),
              count: getRange,
              query: getRange,
              openCursor: getRange
            };
            keys3(readSubscribers).forEach(function(method) {
              tableClone[method] = function(req) {
                var subscr = PSD.subscr;
                var isLiveQuery = !!subscr;
                var cachable = isCachableContext(PSD, table) && isCachableRequest(method, req);
                var obsSet = cachable ? req.obsSet = {} : subscr;
                if (isLiveQuery) {
                  var getRangeSet = /* @__PURE__ */ __name(function(indexName) {
                    var part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                    return obsSet[part] || (obsSet[part] = new RangeSet3());
                  }, "getRangeSet");
                  var pkRangeSet_1 = getRangeSet("");
                  var delsRangeSet_1 = getRangeSet(":dels");
                  var _a10 = readSubscribers[method](req), queriedIndex = _a10[0], queriedRanges = _a10[1];
                  if (method === "query" && queriedIndex.isPrimaryKey && !req.values) {
                    delsRangeSet_1.add(queriedRanges);
                  } else {
                    getRangeSet(queriedIndex.name || "").add(queriedRanges);
                  }
                  if (!queriedIndex.isPrimaryKey) {
                    if (method === "count") {
                      delsRangeSet_1.add(FULL_RANGE);
                    } else {
                      var keysPromise_1 = method === "query" && outbound && req.values && table.query(__assign(__assign({}, req), { values: false }));
                      return table[method].apply(this, arguments).then(function(res) {
                        if (method === "query") {
                          if (outbound && req.values) {
                            return keysPromise_1.then(function(_a11) {
                              var resultingKeys = _a11.result;
                              pkRangeSet_1.addKeys(resultingKeys);
                              return res;
                            });
                          }
                          var pKeys = req.values ? res.result.map(extractKey) : res.result;
                          if (req.values) {
                            pkRangeSet_1.addKeys(pKeys);
                          } else {
                            delsRangeSet_1.addKeys(pKeys);
                          }
                        } else if (method === "openCursor") {
                          var cursor_1 = res;
                          var wantValues_1 = req.values;
                          return cursor_1 && Object.create(cursor_1, {
                            key: {
                              get: /* @__PURE__ */ __name(function() {
                                delsRangeSet_1.addKey(cursor_1.primaryKey);
                                return cursor_1.key;
                              }, "get")
                            },
                            primaryKey: {
                              get: /* @__PURE__ */ __name(function() {
                                var pkey = cursor_1.primaryKey;
                                delsRangeSet_1.addKey(pkey);
                                return pkey;
                              }, "get")
                            },
                            value: {
                              get: /* @__PURE__ */ __name(function() {
                                wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);
                                return cursor_1.value;
                              }, "get")
                            }
                          });
                        }
                        return res;
                      });
                    }
                  }
                }
                return table[method].apply(this, arguments);
              };
            });
            return tableClone;
          }, "table") });
        }, "create")
      };
      function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
        function addAffectedIndex(ix) {
          var rangeSet = getRangeSet(ix.name || "");
          function extractKey(obj) {
            return obj != null ? ix.extractKey(obj) : null;
          }
          __name(extractKey, "extractKey");
          var addKeyOrKeys = /* @__PURE__ */ __name(function(key) {
            return ix.multiEntry && isArray6(key) ? key.forEach(function(key2) {
              return rangeSet.addKey(key2);
            }) : rangeSet.addKey(key);
          }, "addKeyOrKeys");
          (oldObjs || newObjs).forEach(function(_, i) {
            var oldKey = oldObjs && extractKey(oldObjs[i]);
            var newKey = newObjs && extractKey(newObjs[i]);
            if (cmp2(oldKey, newKey) !== 0) {
              if (oldKey != null)
                addKeyOrKeys(oldKey);
              if (newKey != null)
                addKeyOrKeys(newKey);
            }
          });
        }
        __name(addAffectedIndex, "addAffectedIndex");
        schema.indexes.forEach(addAffectedIndex);
      }
      __name(trackAffectedIndexes, "trackAffectedIndexes");
      function adjustOptimisticFromFailures(tblCache, req, res) {
        if (res.numFailures === 0)
          return req;
        if (req.type === "deleteRange") {
          return null;
        }
        var numBulkOps = req.keys ? req.keys.length : "values" in req && req.values ? req.values.length : 1;
        if (res.numFailures === numBulkOps) {
          return null;
        }
        var clone = __assign({}, req);
        if (isArray6(clone.keys)) {
          clone.keys = clone.keys.filter(function(_, i) {
            return !(i in res.failures);
          });
        }
        if ("values" in clone && isArray6(clone.values)) {
          clone.values = clone.values.filter(function(_, i) {
            return !(i in res.failures);
          });
        }
        return clone;
      }
      __name(adjustOptimisticFromFailures, "adjustOptimisticFromFailures");
      function isAboveLower(key, range) {
        return range.lower === void 0 ? true : range.lowerOpen ? cmp2(key, range.lower) > 0 : cmp2(key, range.lower) >= 0;
      }
      __name(isAboveLower, "isAboveLower");
      function isBelowUpper(key, range) {
        return range.upper === void 0 ? true : range.upperOpen ? cmp2(key, range.upper) < 0 : cmp2(key, range.upper) <= 0;
      }
      __name(isBelowUpper, "isBelowUpper");
      function isWithinRange(key, range) {
        return isAboveLower(key, range) && isBelowUpper(key, range);
      }
      __name(isWithinRange, "isWithinRange");
      function applyOptimisticOps(result, req, ops, table, cacheEntry, immutable) {
        if (!ops || ops.length === 0)
          return result;
        var index = req.query.index;
        var multiEntry = index.multiEntry;
        var queryRange = req.query.range;
        var primaryKey = table.schema.primaryKey;
        var extractPrimKey = primaryKey.extractKey;
        var extractIndex = index.extractKey;
        var extractLowLevelIndex = (index.lowLevelIndex || index).extractKey;
        var finalResult = ops.reduce(function(result2, op) {
          var modifedResult = result2;
          var includedValues = [];
          if (op.type === "add" || op.type === "put") {
            var includedPKs = new RangeSet3();
            for (var i = op.values.length - 1; i >= 0; --i) {
              var value = op.values[i];
              var pk = extractPrimKey(value);
              if (includedPKs.hasKey(pk))
                continue;
              var key = extractIndex(value);
              if (multiEntry && isArray6(key) ? key.some(function(k) {
                return isWithinRange(k, queryRange);
              }) : isWithinRange(key, queryRange)) {
                includedPKs.addKey(pk);
                includedValues.push(value);
              }
            }
          }
          switch (op.type) {
            case "add": {
              var existingKeys_1 = new RangeSet3().addKeys(req.values ? result2.map(function(v) {
                return extractPrimKey(v);
              }) : result2);
              modifedResult = result2.concat(req.values ? includedValues.filter(function(v) {
                var key2 = extractPrimKey(v);
                if (existingKeys_1.hasKey(key2))
                  return false;
                existingKeys_1.addKey(key2);
                return true;
              }) : includedValues.map(function(v) {
                return extractPrimKey(v);
              }).filter(function(k) {
                if (existingKeys_1.hasKey(k))
                  return false;
                existingKeys_1.addKey(k);
                return true;
              }));
              break;
            }
            case "put": {
              var keySet_1 = new RangeSet3().addKeys(op.values.map(function(v) {
                return extractPrimKey(v);
              }));
              modifedResult = result2.filter(
                function(item) {
                  return !keySet_1.hasKey(req.values ? extractPrimKey(item) : item);
                }
              ).concat(
                req.values ? includedValues : includedValues.map(function(v) {
                  return extractPrimKey(v);
                })
              );
              break;
            }
            case "delete":
              var keysToDelete_1 = new RangeSet3().addKeys(op.keys);
              modifedResult = result2.filter(function(item) {
                return !keysToDelete_1.hasKey(req.values ? extractPrimKey(item) : item);
              });
              break;
            case "deleteRange":
              var range_1 = op.range;
              modifedResult = result2.filter(function(item) {
                return !isWithinRange(extractPrimKey(item), range_1);
              });
              break;
          }
          return modifedResult;
        }, result);
        if (finalResult === result)
          return result;
        finalResult.sort(function(a, b) {
          return cmp2(extractLowLevelIndex(a), extractLowLevelIndex(b)) || cmp2(extractPrimKey(a), extractPrimKey(b));
        });
        if (req.limit && req.limit < Infinity) {
          if (finalResult.length > req.limit) {
            finalResult.length = req.limit;
          } else if (result.length === req.limit && finalResult.length < req.limit) {
            cacheEntry.dirty = true;
          }
        }
        return immutable ? Object.freeze(finalResult) : finalResult;
      }
      __name(applyOptimisticOps, "applyOptimisticOps");
      function areRangesEqual(r1, r2) {
        return cmp2(r1.lower, r2.lower) === 0 && cmp2(r1.upper, r2.upper) === 0 && !!r1.lowerOpen === !!r2.lowerOpen && !!r1.upperOpen === !!r2.upperOpen;
      }
      __name(areRangesEqual, "areRangesEqual");
      function compareLowers(lower1, lower2, lowerOpen1, lowerOpen2) {
        if (lower1 === void 0)
          return lower2 !== void 0 ? -1 : 0;
        if (lower2 === void 0)
          return 1;
        var c = cmp2(lower1, lower2);
        if (c === 0) {
          if (lowerOpen1 && lowerOpen2)
            return 0;
          if (lowerOpen1)
            return 1;
          if (lowerOpen2)
            return -1;
        }
        return c;
      }
      __name(compareLowers, "compareLowers");
      function compareUppers(upper1, upper2, upperOpen1, upperOpen2) {
        if (upper1 === void 0)
          return upper2 !== void 0 ? 1 : 0;
        if (upper2 === void 0)
          return -1;
        var c = cmp2(upper1, upper2);
        if (c === 0) {
          if (upperOpen1 && upperOpen2)
            return 0;
          if (upperOpen1)
            return -1;
          if (upperOpen2)
            return 1;
        }
        return c;
      }
      __name(compareUppers, "compareUppers");
      function isSuperRange(r1, r2) {
        return compareLowers(r1.lower, r2.lower, r1.lowerOpen, r2.lowerOpen) <= 0 && compareUppers(r1.upper, r2.upper, r1.upperOpen, r2.upperOpen) >= 0;
      }
      __name(isSuperRange, "isSuperRange");
      function findCompatibleQuery(dbName, tableName, type2, req) {
        var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
        if (!tblCache)
          return [];
        var queries = tblCache.queries[type2];
        if (!queries)
          return [null, false, tblCache, null];
        var indexName = req.query ? req.query.index.name : null;
        var entries = queries[indexName || ""];
        if (!entries)
          return [null, false, tblCache, null];
        switch (type2) {
          case "query":
            var equalEntry = entries.find(function(entry) {
              return entry.req.limit === req.limit && entry.req.values === req.values && areRangesEqual(entry.req.query.range, req.query.range);
            });
            if (equalEntry)
              return [
                equalEntry,
                true,
                tblCache,
                entries
              ];
            var superEntry = entries.find(function(entry) {
              var limit = "limit" in entry.req ? entry.req.limit : Infinity;
              return limit >= req.limit && (req.values ? entry.req.values : true) && isSuperRange(entry.req.query.range, req.query.range);
            });
            return [superEntry, false, tblCache, entries];
          case "count":
            var countQuery = entries.find(function(entry) {
              return areRangesEqual(entry.req.query.range, req.query.range);
            });
            return [countQuery, !!countQuery, tblCache, entries];
        }
      }
      __name(findCompatibleQuery, "findCompatibleQuery");
      function subscribeToCacheEntry(cacheEntry, container, requery, signal) {
        cacheEntry.subscribers.add(requery);
        signal.addEventListener("abort", function() {
          cacheEntry.subscribers.delete(requery);
          if (cacheEntry.subscribers.size === 0) {
            enqueForDeletion(cacheEntry, container);
          }
        });
      }
      __name(subscribeToCacheEntry, "subscribeToCacheEntry");
      function enqueForDeletion(cacheEntry, container) {
        setTimeout(function() {
          if (cacheEntry.subscribers.size === 0) {
            delArrayItem(container, cacheEntry);
          }
        }, 3e3);
      }
      __name(enqueForDeletion, "enqueForDeletion");
      var cacheMiddleware = {
        stack: "dbcore",
        level: 0,
        name: "Cache",
        create: /* @__PURE__ */ __name(function(core) {
          var dbName = core.schema.name;
          var coreMW = __assign(__assign({}, core), { transaction: /* @__PURE__ */ __name(function(stores, mode, options) {
            var idbtrans = core.transaction(stores, mode, options);
            if (mode === "readwrite") {
              var ac_1 = new AbortController();
              var signal = ac_1.signal;
              var endTransaction = /* @__PURE__ */ __name(function(wasCommitted) {
                return function() {
                  ac_1.abort();
                  if (mode === "readwrite") {
                    var affectedSubscribers_1 = /* @__PURE__ */ new Set();
                    for (var _i = 0, stores_1 = stores; _i < stores_1.length; _i++) {
                      var storeName = stores_1[_i];
                      var tblCache = cache["idb://".concat(dbName, "/").concat(storeName)];
                      if (tblCache) {
                        var table = core.table(storeName);
                        var ops = tblCache.optimisticOps.filter(function(op) {
                          return op.trans === idbtrans;
                        });
                        if (idbtrans._explicit && wasCommitted && idbtrans.mutatedParts) {
                          for (var _a10 = 0, _b2 = Object.values(tblCache.queries.query); _a10 < _b2.length; _a10++) {
                            var entries = _b2[_a10];
                            for (var _c = 0, _d = entries.slice(); _c < _d.length; _c++) {
                              var entry = _d[_c];
                              if (obsSetsOverlap(entry.obsSet, idbtrans.mutatedParts)) {
                                delArrayItem(entries, entry);
                                entry.subscribers.forEach(function(requery) {
                                  return affectedSubscribers_1.add(requery);
                                });
                              }
                            }
                          }
                        } else if (ops.length > 0) {
                          tblCache.optimisticOps = tblCache.optimisticOps.filter(function(op) {
                            return op.trans !== idbtrans;
                          });
                          for (var _e = 0, _f = Object.values(tblCache.queries.query); _e < _f.length; _e++) {
                            var entries = _f[_e];
                            for (var _g = 0, _h = entries.slice(); _g < _h.length; _g++) {
                              var entry = _h[_g];
                              if (entry.res != null && idbtrans.mutatedParts) {
                                if (wasCommitted && !entry.dirty) {
                                  var freezeResults = Object.isFrozen(entry.res);
                                  var modRes = applyOptimisticOps(entry.res, entry.req, ops, table, entry, freezeResults);
                                  if (entry.dirty) {
                                    delArrayItem(entries, entry);
                                    entry.subscribers.forEach(function(requery) {
                                      return affectedSubscribers_1.add(requery);
                                    });
                                  } else if (modRes !== entry.res) {
                                    entry.res = modRes;
                                    entry.promise = DexiePromise.resolve({ result: modRes });
                                  }
                                } else {
                                  if (entry.dirty) {
                                    delArrayItem(entries, entry);
                                  }
                                  entry.subscribers.forEach(function(requery) {
                                    return affectedSubscribers_1.add(requery);
                                  });
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    affectedSubscribers_1.forEach(function(requery) {
                      return requery();
                    });
                  }
                };
              }, "endTransaction");
              idbtrans.addEventListener("abort", endTransaction(false), {
                signal
              });
              idbtrans.addEventListener("error", endTransaction(false), {
                signal
              });
              idbtrans.addEventListener("complete", endTransaction(true), {
                signal
              });
            }
            return idbtrans;
          }, "transaction"), table: /* @__PURE__ */ __name(function(tableName) {
            var downTable = core.table(tableName);
            var primKey = downTable.schema.primaryKey;
            var tableMW = __assign(__assign({}, downTable), { mutate: /* @__PURE__ */ __name(function(req) {
              var trans = PSD.trans;
              if (primKey.outbound || trans.db._options.cache === "disabled" || trans.explicit || trans.idbtrans.mode !== "readwrite") {
                return downTable.mutate(req);
              }
              var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
              if (!tblCache)
                return downTable.mutate(req);
              var promise = downTable.mutate(req);
              if ((req.type === "add" || req.type === "put") && (req.values.length >= 50 || getEffectiveKeys(primKey, req).some(function(key) {
                return key == null;
              }))) {
                promise.then(function(res) {
                  var reqWithResolvedKeys = __assign(__assign({}, req), { values: req.values.map(function(value, i) {
                    var _a10;
                    if (res.failures[i])
                      return value;
                    var valueWithKey = ((_a10 = primKey.keyPath) === null || _a10 === void 0 ? void 0 : _a10.includes(".")) ? deepClone(value) : __assign({}, value);
                    setByKeyPath(valueWithKey, primKey.keyPath, res.results[i]);
                    return valueWithKey;
                  }) });
                  var adjustedReq = adjustOptimisticFromFailures(tblCache, reqWithResolvedKeys, res);
                  tblCache.optimisticOps.push(adjustedReq);
                  queueMicrotask(function() {
                    return req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                  });
                });
              } else {
                tblCache.optimisticOps.push(req);
                req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                promise.then(function(res) {
                  if (res.numFailures > 0) {
                    delArrayItem(tblCache.optimisticOps, req);
                    var adjustedReq = adjustOptimisticFromFailures(tblCache, req, res);
                    if (adjustedReq) {
                      tblCache.optimisticOps.push(adjustedReq);
                    }
                    req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                  }
                });
                promise.catch(function() {
                  delArrayItem(tblCache.optimisticOps, req);
                  req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                });
              }
              return promise;
            }, "mutate"), query: /* @__PURE__ */ __name(function(req) {
              var _a10;
              if (!isCachableContext(PSD, downTable) || !isCachableRequest("query", req))
                return downTable.query(req);
              var freezeResults = ((_a10 = PSD.trans) === null || _a10 === void 0 ? void 0 : _a10.db._options.cache) === "immutable";
              var _b2 = PSD, requery = _b2.requery, signal = _b2.signal;
              var _c = findCompatibleQuery(dbName, tableName, "query", req), cacheEntry = _c[0], exactMatch = _c[1], tblCache = _c[2], container = _c[3];
              if (cacheEntry && exactMatch) {
                cacheEntry.obsSet = req.obsSet;
              } else {
                var promise = downTable.query(req).then(function(res) {
                  var result = res.result;
                  if (cacheEntry)
                    cacheEntry.res = result;
                  if (freezeResults) {
                    for (var i = 0, l = result.length; i < l; ++i) {
                      Object.freeze(result[i]);
                    }
                    Object.freeze(result);
                  } else {
                    res.result = deepClone(result);
                  }
                  return res;
                }).catch(function(error) {
                  if (container && cacheEntry)
                    delArrayItem(container, cacheEntry);
                  return Promise.reject(error);
                });
                cacheEntry = {
                  obsSet: req.obsSet,
                  promise,
                  subscribers: /* @__PURE__ */ new Set(),
                  type: "query",
                  req,
                  dirty: false
                };
                if (container) {
                  container.push(cacheEntry);
                } else {
                  container = [cacheEntry];
                  if (!tblCache) {
                    tblCache = cache["idb://".concat(dbName, "/").concat(tableName)] = {
                      queries: {
                        query: {},
                        count: {}
                      },
                      objs: /* @__PURE__ */ new Map(),
                      optimisticOps: [],
                      unsignaledParts: {}
                    };
                  }
                  tblCache.queries.query[req.query.index.name || ""] = container;
                }
              }
              subscribeToCacheEntry(cacheEntry, container, requery, signal);
              return cacheEntry.promise.then(function(res) {
                return {
                  result: applyOptimisticOps(res.result, req, tblCache === null || tblCache === void 0 ? void 0 : tblCache.optimisticOps, downTable, cacheEntry, freezeResults)
                };
              });
            }, "query") });
            return tableMW;
          }, "table") });
          return coreMW;
        }, "create")
      };
      function vipify(target, vipDb) {
        return new Proxy(target, {
          get: /* @__PURE__ */ __name(function(target2, prop, receiver) {
            if (prop === "db")
              return vipDb;
            return Reflect.get(target2, prop, receiver);
          }, "get")
        });
      }
      __name(vipify, "vipify");
      var Dexie$1 = function() {
        function Dexie3(name, options) {
          var _this = this;
          this._middlewares = {};
          this.verno = 0;
          var deps = Dexie3.dependencies;
          this._options = options = __assign({
            addons: Dexie3.addons,
            autoOpen: true,
            indexedDB: deps.indexedDB,
            IDBKeyRange: deps.IDBKeyRange,
            cache: "cloned"
          }, options);
          this._deps = {
            indexedDB: options.indexedDB,
            IDBKeyRange: options.IDBKeyRange
          };
          var addons = options.addons;
          this._dbSchema = {};
          this._versions = [];
          this._storeNames = [];
          this._allTables = {};
          this.idbdb = null;
          this._novip = this;
          var state = {
            dbOpenError: null,
            isBeingOpened: false,
            onReadyBeingFired: null,
            openComplete: false,
            dbReadyResolve: nop,
            dbReadyPromise: null,
            cancelOpen: nop,
            openCanceller: null,
            autoSchema: true,
            PR1398_maxLoop: 3,
            autoOpen: options.autoOpen
          };
          state.dbReadyPromise = new DexiePromise(function(resolve) {
            state.dbReadyResolve = resolve;
          });
          state.openCanceller = new DexiePromise(function(_, reject) {
            state.cancelOpen = reject;
          });
          this._state = state;
          this.name = name;
          this.on = Events2(this, "populate", "blocked", "versionchange", "close", { ready: [promisableChain, nop] });
          this.on.ready.subscribe = override(this.on.ready.subscribe, function(subscribe) {
            return function(subscriber, bSticky) {
              Dexie3.vip(function() {
                var state2 = _this._state;
                if (state2.openComplete) {
                  if (!state2.dbOpenError)
                    DexiePromise.resolve().then(subscriber);
                  if (bSticky)
                    subscribe(subscriber);
                } else if (state2.onReadyBeingFired) {
                  state2.onReadyBeingFired.push(subscriber);
                  if (bSticky)
                    subscribe(subscriber);
                } else {
                  subscribe(subscriber);
                  var db_1 = _this;
                  if (!bSticky)
                    subscribe(/* @__PURE__ */ __name(function unsubscribe() {
                      db_1.on.ready.unsubscribe(subscriber);
                      db_1.on.ready.unsubscribe(unsubscribe);
                    }, "unsubscribe"));
                }
              });
            };
          });
          this.Collection = createCollectionConstructor(this);
          this.Table = createTableConstructor(this);
          this.Transaction = createTransactionConstructor(this);
          this.Version = createVersionConstructor(this);
          this.WhereClause = createWhereClauseConstructor(this);
          this.on("versionchange", function(ev) {
            if (ev.newVersion > 0)
              console.warn("Another connection wants to upgrade database '".concat(_this.name, "'. Closing db now to resume the upgrade."));
            else
              console.warn("Another connection wants to delete database '".concat(_this.name, "'. Closing db now to resume the delete request."));
            _this.close({ disableAutoOpen: false });
          });
          this.on("blocked", function(ev) {
            if (!ev.newVersion || ev.newVersion < ev.oldVersion)
              console.warn("Dexie.delete('".concat(_this.name, "') was blocked"));
            else
              console.warn("Upgrade '".concat(_this.name, "' blocked by other connection holding version ").concat(ev.oldVersion / 10));
          });
          this._maxKey = getMaxKey(options.IDBKeyRange);
          this._createTransaction = function(mode, storeNames, dbschema, parentTransaction) {
            return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction);
          };
          this._fireOnBlocked = function(ev) {
            _this.on("blocked").fire(ev);
            connections.filter(function(c) {
              return c.name === _this.name && c !== _this && !c._state.vcFired;
            }).map(function(c) {
              return c.on("versionchange").fire(ev);
            });
          };
          this.use(cacheExistingValuesMiddleware);
          this.use(cacheMiddleware);
          this.use(observabilityMiddleware);
          this.use(virtualIndexMiddleware);
          this.use(hooksMiddleware);
          var vipDB = new Proxy(this, {
            get: /* @__PURE__ */ __name(function(_, prop, receiver) {
              if (prop === "_vip")
                return true;
              if (prop === "table")
                return function(tableName) {
                  return vipify(_this.table(tableName), vipDB);
                };
              var rv = Reflect.get(_, prop, receiver);
              if (rv instanceof Table)
                return vipify(rv, vipDB);
              if (prop === "tables")
                return rv.map(function(t) {
                  return vipify(t, vipDB);
                });
              if (prop === "_createTransaction")
                return function() {
                  var tx = rv.apply(this, arguments);
                  return vipify(tx, vipDB);
                };
              return rv;
            }, "get")
          });
          this.vip = vipDB;
          addons.forEach(function(addon) {
            return addon(_this);
          });
        }
        __name(Dexie3, "Dexie");
        Dexie3.prototype.version = function(versionNumber) {
          if (isNaN(versionNumber) || versionNumber < 0.1)
            throw new exceptions.Type("Given version is not a positive number");
          versionNumber = Math.round(versionNumber * 10) / 10;
          if (this.idbdb || this._state.isBeingOpened)
            throw new exceptions.Schema("Cannot add version when database is open");
          this.verno = Math.max(this.verno, versionNumber);
          var versions = this._versions;
          var versionInstance = versions.filter(function(v) {
            return v._cfg.version === versionNumber;
          })[0];
          if (versionInstance)
            return versionInstance;
          versionInstance = new this.Version(versionNumber);
          versions.push(versionInstance);
          versions.sort(lowerVersionFirst);
          versionInstance.stores({});
          this._state.autoSchema = false;
          return versionInstance;
        };
        Dexie3.prototype._whenReady = function(fn) {
          var _this = this;
          return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise(function(resolve, reject) {
            if (_this._state.openComplete) {
              return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));
            }
            if (!_this._state.isBeingOpened) {
              if (!_this._state.autoOpen) {
                reject(new exceptions.DatabaseClosed());
                return;
              }
              _this.open().catch(nop);
            }
            _this._state.dbReadyPromise.then(resolve, reject);
          }).then(fn);
        };
        Dexie3.prototype.use = function(_a10) {
          var stack = _a10.stack, create7 = _a10.create, level = _a10.level, name = _a10.name;
          if (name)
            this.unuse({ stack, name });
          var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
          middlewares.push({ stack, create: create7, level: level == null ? 10 : level, name });
          middlewares.sort(function(a, b) {
            return a.level - b.level;
          });
          return this;
        };
        Dexie3.prototype.unuse = function(_a10) {
          var stack = _a10.stack, name = _a10.name, create7 = _a10.create;
          if (stack && this._middlewares[stack]) {
            this._middlewares[stack] = this._middlewares[stack].filter(function(mw) {
              return create7 ? mw.create !== create7 : name ? mw.name !== name : false;
            });
          }
          return this;
        };
        Dexie3.prototype.open = function() {
          var _this = this;
          return usePSD(
            globalPSD,
            function() {
              return dexieOpen(_this);
            }
          );
        };
        Dexie3.prototype._close = function() {
          var state = this._state;
          var idx = connections.indexOf(this);
          if (idx >= 0)
            connections.splice(idx, 1);
          if (this.idbdb) {
            try {
              this.idbdb.close();
            } catch (e) {
            }
            this.idbdb = null;
          }
          if (!state.isBeingOpened) {
            state.dbReadyPromise = new DexiePromise(function(resolve) {
              state.dbReadyResolve = resolve;
            });
            state.openCanceller = new DexiePromise(function(_, reject) {
              state.cancelOpen = reject;
            });
          }
        };
        Dexie3.prototype.close = function(_a10) {
          var _b2 = _a10 === void 0 ? { disableAutoOpen: true } : _a10, disableAutoOpen = _b2.disableAutoOpen;
          var state = this._state;
          if (disableAutoOpen) {
            if (state.isBeingOpened) {
              state.cancelOpen(new exceptions.DatabaseClosed());
            }
            this._close();
            state.autoOpen = false;
            state.dbOpenError = new exceptions.DatabaseClosed();
          } else {
            this._close();
            state.autoOpen = this._options.autoOpen || state.isBeingOpened;
            state.openComplete = false;
            state.dbOpenError = null;
          }
        };
        Dexie3.prototype.delete = function(closeOptions) {
          var _this = this;
          if (closeOptions === void 0) {
            closeOptions = { disableAutoOpen: true };
          }
          var hasInvalidArguments = arguments.length > 0 && typeof arguments[0] !== "object";
          var state = this._state;
          return new DexiePromise(function(resolve, reject) {
            var doDelete = /* @__PURE__ */ __name(function() {
              _this.close(closeOptions);
              var req = _this._deps.indexedDB.deleteDatabase(_this.name);
              req.onsuccess = wrap(function() {
                _onDatabaseDeleted(_this._deps, _this.name);
                resolve();
              });
              req.onerror = eventRejectHandler(reject);
              req.onblocked = _this._fireOnBlocked;
            }, "doDelete");
            if (hasInvalidArguments)
              throw new exceptions.InvalidArgument("Invalid closeOptions argument to db.delete()");
            if (state.isBeingOpened) {
              state.dbReadyPromise.then(doDelete);
            } else {
              doDelete();
            }
          });
        };
        Dexie3.prototype.backendDB = function() {
          return this.idbdb;
        };
        Dexie3.prototype.isOpen = function() {
          return this.idbdb !== null;
        };
        Dexie3.prototype.hasBeenClosed = function() {
          var dbOpenError = this._state.dbOpenError;
          return dbOpenError && dbOpenError.name === "DatabaseClosed";
        };
        Dexie3.prototype.hasFailed = function() {
          return this._state.dbOpenError !== null;
        };
        Dexie3.prototype.dynamicallyOpened = function() {
          return this._state.autoSchema;
        };
        Object.defineProperty(Dexie3.prototype, "tables", {
          get: /* @__PURE__ */ __name(function() {
            var _this = this;
            return keys3(this._allTables).map(function(name) {
              return _this._allTables[name];
            });
          }, "get"),
          enumerable: false,
          configurable: true
        });
        Dexie3.prototype.transaction = function() {
          var args2 = extractTransactionArgs.apply(this, arguments);
          return this._transaction.apply(this, args2);
        };
        Dexie3.prototype._transaction = function(mode, tables, scopeFunc) {
          var _this = this;
          var parentTransaction = PSD.trans;
          if (!parentTransaction || parentTransaction.db !== this || mode.indexOf("!") !== -1)
            parentTransaction = null;
          var onlyIfCompatible = mode.indexOf("?") !== -1;
          mode = mode.replace("!", "").replace("?", "");
          var idbMode, storeNames;
          try {
            storeNames = tables.map(function(table) {
              var storeName = table instanceof _this.Table ? table.name : table;
              if (typeof storeName !== "string")
                throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
              return storeName;
            });
            if (mode == "r" || mode === READONLY)
              idbMode = READONLY;
            else if (mode == "rw" || mode == READWRITE)
              idbMode = READWRITE;
            else
              throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
            if (parentTransaction) {
              if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
                if (onlyIfCompatible) {
                  parentTransaction = null;
                } else
                  throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              }
              if (parentTransaction) {
                storeNames.forEach(function(storeName) {
                  if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
                    if (onlyIfCompatible) {
                      parentTransaction = null;
                    } else
                      throw new exceptions.SubTransaction("Table " + storeName + " not included in parent transaction.");
                  }
                });
              }
              if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
                parentTransaction = null;
              }
            }
          } catch (e) {
            return parentTransaction ? parentTransaction._promise(null, function(_, reject) {
              reject(e);
            }) : rejection(e);
          }
          var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
          return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, "lock") : PSD.trans ? usePSD(PSD.transless, function() {
            return _this._whenReady(enterTransaction);
          }) : this._whenReady(enterTransaction);
        };
        Dexie3.prototype.table = function(tableName) {
          if (!hasOwn(this._allTables, tableName)) {
            throw new exceptions.InvalidTable("Table ".concat(tableName, " does not exist"));
          }
          return this._allTables[tableName];
        };
        return Dexie3;
      }();
      var symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol ? Symbol.observable : "@@observable";
      var Observable8 = function() {
        function Observable9(subscribe) {
          this._subscribe = subscribe;
        }
        __name(Observable9, "Observable");
        Observable9.prototype.subscribe = function(x, error, complete) {
          return this._subscribe(!x || typeof x === "function" ? { next: x, error, complete } : x);
        };
        Observable9.prototype[symbolObservable] = function() {
          return this;
        };
        return Observable9;
      }();
      var domDeps;
      try {
        domDeps = {
          indexedDB: _global2.indexedDB || _global2.mozIndexedDB || _global2.webkitIndexedDB || _global2.msIndexedDB,
          IDBKeyRange: _global2.IDBKeyRange || _global2.webkitIDBKeyRange
        };
      } catch (e) {
        domDeps = { indexedDB: null, IDBKeyRange: null };
      }
      function liveQuery2(querier) {
        var hasValue = false;
        var currentValue;
        var observable2 = new Observable8(function(observer) {
          var scopeFuncIsAsync = isAsyncFunction(querier);
          function execute(ctx) {
            var wasRootExec = beginMicroTickScope();
            try {
              if (scopeFuncIsAsync) {
                incrementExpectedAwaits();
              }
              var rv = newScope(querier, ctx);
              if (scopeFuncIsAsync) {
                rv = rv.finally(decrementExpectedAwaits);
              }
              return rv;
            } finally {
              wasRootExec && endMicroTickScope();
            }
          }
          __name(execute, "execute");
          var closed = false;
          var abortController;
          var accumMuts = {};
          var currentObs = {};
          var subscription = {
            get closed() {
              return closed;
            },
            unsubscribe: /* @__PURE__ */ __name(function() {
              if (closed)
                return;
              closed = true;
              if (abortController)
                abortController.abort();
              if (startedListening)
                globalEvents.storagemutated.unsubscribe(mutationListener);
            }, "unsubscribe")
          };
          observer.start && observer.start(subscription);
          var startedListening = false;
          var doQuery = /* @__PURE__ */ __name(function() {
            return execInGlobalContext(_doQuery);
          }, "doQuery");
          function shouldNotify() {
            return obsSetsOverlap(currentObs, accumMuts);
          }
          __name(shouldNotify, "shouldNotify");
          var mutationListener = /* @__PURE__ */ __name(function(parts) {
            extendObservabilitySet(accumMuts, parts);
            if (shouldNotify()) {
              doQuery();
            }
          }, "mutationListener");
          var _doQuery = /* @__PURE__ */ __name(function() {
            if (closed || !domDeps.indexedDB) {
              return;
            }
            accumMuts = {};
            var subscr = {};
            if (abortController)
              abortController.abort();
            abortController = new AbortController();
            var ctx = {
              subscr,
              signal: abortController.signal,
              requery: doQuery,
              querier,
              trans: null
            };
            var ret = execute(ctx);
            Promise.resolve(ret).then(function(result) {
              hasValue = true;
              currentValue = result;
              if (closed || ctx.signal.aborted) {
                return;
              }
              accumMuts = {};
              currentObs = subscr;
              if (!objectIsEmpty(currentObs) && !startedListening) {
                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
                startedListening = true;
              }
              execInGlobalContext(function() {
                return !closed && observer.next && observer.next(result);
              });
            }, function(err2) {
              hasValue = false;
              if (!["DatabaseClosedError", "AbortError"].includes(err2 === null || err2 === void 0 ? void 0 : err2.name)) {
                if (!closed)
                  execInGlobalContext(function() {
                    if (closed)
                      return;
                    observer.error && observer.error(err2);
                  });
              }
            });
          }, "_doQuery");
          setTimeout(doQuery, 0);
          return subscription;
        });
        observable2.hasValue = function() {
          return hasValue;
        };
        observable2.getValue = function() {
          return currentValue;
        };
        return observable2;
      }
      __name(liveQuery2, "liveQuery");
      var Dexie2 = Dexie$1;
      props(Dexie2, __assign(__assign({}, fullNameExceptions), {
        delete: /* @__PURE__ */ __name(function(databaseName) {
          var db = new Dexie2(databaseName, { addons: [] });
          return db.delete();
        }, "delete"),
        exists: /* @__PURE__ */ __name(function(name) {
          return new Dexie2(name, { addons: [] }).open().then(function(db) {
            db.close();
            return true;
          }).catch("NoSuchDatabaseError", function() {
            return false;
          });
        }, "exists"),
        getDatabaseNames: /* @__PURE__ */ __name(function(cb) {
          try {
            return getDatabaseNames(Dexie2.dependencies).then(cb);
          } catch (_a10) {
            return rejection(new exceptions.MissingAPI());
          }
        }, "getDatabaseNames"),
        defineClass: /* @__PURE__ */ __name(function() {
          function Class(content) {
            extend2(this, content);
          }
          __name(Class, "Class");
          return Class;
        }, "defineClass"),
        ignoreTransaction: /* @__PURE__ */ __name(function(scopeFunc) {
          return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();
        }, "ignoreTransaction"),
        vip,
        async: /* @__PURE__ */ __name(function(generatorFn) {
          return function() {
            try {
              var rv = awaitIterator(generatorFn.apply(this, arguments));
              if (!rv || typeof rv.then !== "function")
                return DexiePromise.resolve(rv);
              return rv;
            } catch (e) {
              return rejection(e);
            }
          };
        }, "async"),
        spawn: /* @__PURE__ */ __name(function(generatorFn, args2, thiz) {
          try {
            var rv = awaitIterator(generatorFn.apply(thiz, args2 || []));
            if (!rv || typeof rv.then !== "function")
              return DexiePromise.resolve(rv);
            return rv;
          } catch (e) {
            return rejection(e);
          }
        }, "spawn"),
        currentTransaction: {
          get: /* @__PURE__ */ __name(function() {
            return PSD.trans || null;
          }, "get")
        },
        waitFor: /* @__PURE__ */ __name(function(promiseOrFunction, optionalTimeout) {
          var promise = DexiePromise.resolve(typeof promiseOrFunction === "function" ? Dexie2.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 6e4);
          return PSD.trans ? PSD.trans.waitFor(promise) : promise;
        }, "waitFor"),
        Promise: DexiePromise,
        debug: {
          get: /* @__PURE__ */ __name(function() {
            return debug23;
          }, "get"),
          set: /* @__PURE__ */ __name(function(value) {
            setDebug(value);
          }, "set")
        },
        derive,
        extend: extend2,
        props,
        override,
        Events: Events2,
        on: globalEvents,
        liveQuery: liveQuery2,
        extendObservabilitySet,
        getByKeyPath,
        setByKeyPath,
        delByKeyPath,
        shallowClone,
        deepClone,
        getObjectDiff,
        cmp: cmp2,
        asap: asap$1,
        minKey,
        addons: [],
        connections,
        errnames,
        dependencies: domDeps,
        cache,
        semVer: DEXIE_VERSION,
        version: DEXIE_VERSION.split(".").map(function(n) {
          return parseInt(n);
        }).reduce(function(p, c, i) {
          return p + c / Math.pow(10, i * 2);
        })
      }));
      Dexie2.maxKey = getMaxKey(Dexie2.dependencies.IDBKeyRange);
      if (typeof dispatchEvent !== "undefined" && typeof addEventListener !== "undefined") {
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function(updatedParts) {
          if (!propagatingLocally) {
            var event_1;
            event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
              detail: updatedParts
            });
            propagatingLocally = true;
            dispatchEvent(event_1);
            propagatingLocally = false;
          }
        });
        addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function(_a10) {
          var detail = _a10.detail;
          if (!propagatingLocally) {
            propagateLocally(detail);
          }
        });
      }
      function propagateLocally(updateParts) {
        var wasMe = propagatingLocally;
        try {
          propagatingLocally = true;
          globalEvents.storagemutated.fire(updateParts);
          signalSubscribersNow(updateParts, true);
        } finally {
          propagatingLocally = wasMe;
        }
      }
      __name(propagateLocally, "propagateLocally");
      var propagatingLocally = false;
      var bc;
      var createBC = /* @__PURE__ */ __name(function() {
      }, "createBC");
      if (typeof BroadcastChannel !== "undefined") {
        createBC = /* @__PURE__ */ __name(function() {
          bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
          bc.onmessage = function(ev) {
            return ev.data && propagateLocally(ev.data);
          };
        }, "createBC");
        createBC();
        if (typeof bc.unref === "function") {
          bc.unref();
        }
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function(changedParts) {
          if (!propagatingLocally) {
            bc.postMessage(changedParts);
          }
        });
      }
      if (typeof addEventListener !== "undefined") {
        addEventListener("pagehide", function(event) {
          if (!Dexie$1.disableBfCache && event.persisted) {
            if (debug23)
              console.debug("Dexie: handling persisted pagehide");
            bc === null || bc === void 0 ? void 0 : bc.close();
            for (var _i = 0, connections_1 = connections; _i < connections_1.length; _i++) {
              var db = connections_1[_i];
              db.close({ disableAutoOpen: false });
            }
          }
        });
        addEventListener("pageshow", function(event) {
          if (!Dexie$1.disableBfCache && event.persisted) {
            if (debug23)
              console.debug("Dexie: handling persisted pageshow");
            createBC();
            propagateLocally({ all: new RangeSet3(-Infinity, [[]]) });
          }
        });
      }
      function add2(value) {
        return new PropModification2({ add: value });
      }
      __name(add2, "add");
      function remove2(value) {
        return new PropModification2({ remove: value });
      }
      __name(remove2, "remove");
      function replacePrefix2(a, b) {
        return new PropModification2({ replacePrefix: [a, b] });
      }
      __name(replacePrefix2, "replacePrefix");
      DexiePromise.rejectionMapper = mapError;
      setDebug(debug23);
      var namedExports = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        Dexie: Dexie$1,
        liveQuery: liveQuery2,
        Entity: Entity2,
        cmp: cmp2,
        PropModification: PropModification2,
        replacePrefix: replacePrefix2,
        add: add2,
        remove: remove2,
        "default": Dexie$1,
        RangeSet: RangeSet3,
        mergeRanges: mergeRanges2,
        rangesOverlap: rangesOverlap2
      });
      __assign(Dexie$1, namedExports, { default: Dexie$1 });
      return Dexie$1;
    });
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    init_process_shim();
    exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d2 = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d2;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d2, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d2, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d2 = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d2, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d2, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d2] |= s * 128;
    };
  }
});

// (disabled):crypto
var require_crypto = __commonJS({
  "(disabled):crypto"() {
    init_process_shim();
  }
});

// (disabled):buffer
var require_buffer = __commonJS({
  "(disabled):buffer"() {
    init_process_shim();
  }
});

// node_modules/js-md5/src/md5.js
var require_md5 = __commonJS({
  "node_modules/js-md5/src/md5.js"(exports2, module2) {
    init_process_shim();
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root2 = WINDOW ? window : {};
      if (root2.JS_MD5_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root2.JS_MD5_NO_NODE_JS && typeof import_browser.default === "object" && import_browser.default.versions && import_browser.default.versions.node;
      if (NODE_JS) {
        root2 = global;
      } else if (WEB_WORKER) {
        root2 = self;
      }
      var COMMON_JS = !root2.JS_MD5_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root2.JS_MD5_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [128, 32768, 8388608, -2147483648];
      var SHIFT = [0, 8, 16, 24];
      var OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer", "base64"];
      var BASE64_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
      var blocks = [], buffer8;
      if (ARRAY_BUFFER) {
        var buffer = new ArrayBuffer(68);
        buffer8 = new Uint8Array(buffer);
        blocks = new Uint32Array(buffer);
      }
      var isArray6 = Array.isArray;
      if (root2.JS_MD5_NO_NODE_JS || !isArray6) {
        isArray6 = /* @__PURE__ */ __name(function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        }, "isArray");
      }
      var isView = ArrayBuffer.isView;
      if (ARRAY_BUFFER && (root2.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW || !isView)) {
        isView = /* @__PURE__ */ __name(function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        }, "isView");
      }
      var formatMessage = /* @__PURE__ */ __name(function(message) {
        var type = typeof message;
        if (type === "string") {
          return [message, true];
        }
        if (type !== "object" || message === null) {
          throw new Error(INPUT_ERROR);
        }
        if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          return [new Uint8Array(message), false];
        }
        if (!isArray6(message) && !isView(message)) {
          throw new Error(INPUT_ERROR);
        }
        return [message, false];
      }, "formatMessage");
      var createOutputMethod = /* @__PURE__ */ __name(function(outputType) {
        return function(message) {
          return new Md5(true).update(message)[outputType]();
        };
      }, "createOutputMethod");
      var createMethod = /* @__PURE__ */ __name(function() {
        var method = createOutputMethod("hex");
        if (NODE_JS) {
          method = nodeWrap(method);
        }
        method.create = function() {
          return new Md5();
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createOutputMethod(type);
        }
        return method;
      }, "createMethod");
      var nodeWrap = /* @__PURE__ */ __name(function(method) {
        var crypto2 = require_crypto();
        var Buffer3 = require_buffer().Buffer;
        var bufferFrom;
        if (Buffer3.from && !root2.JS_MD5_NO_BUFFER_FROM) {
          bufferFrom = Buffer3.from;
        } else {
          bufferFrom = /* @__PURE__ */ __name(function(message) {
            return new Buffer3(message);
          }, "bufferFrom");
        }
        var nodeMethod = /* @__PURE__ */ __name(function(message) {
          if (typeof message === "string") {
            return crypto2.createHash("md5").update(message, "utf8").digest("hex");
          } else {
            if (message === null || message === void 0) {
              throw new Error(INPUT_ERROR);
            } else if (message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            }
          }
          if (isArray6(message) || isView(message) || message.constructor === Buffer3) {
            return crypto2.createHash("md5").update(bufferFrom(message)).digest("hex");
          } else {
            return method(message);
          }
        }, "nodeMethod");
        return nodeMethod;
      }, "nodeWrap");
      var createHmacOutputMethod = /* @__PURE__ */ __name(function(outputType) {
        return function(key, message) {
          return new HmacMd5(key, true).update(message)[outputType]();
        };
      }, "createHmacOutputMethod");
      var createHmacMethod = /* @__PURE__ */ __name(function() {
        var method = createHmacOutputMethod("hex");
        method.create = function(key) {
          return new HmacMd5(key);
        };
        method.update = function(key, message) {
          return method.create(key).update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createHmacOutputMethod(type);
        }
        return method;
      }, "createHmacMethod");
      function Md5(sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
          this.buffer8 = buffer8;
        } else {
          if (ARRAY_BUFFER) {
            var buffer2 = new ArrayBuffer(68);
            this.buffer8 = new Uint8Array(buffer2);
            this.blocks = new Uint32Array(buffer2);
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
        }
        this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
      }
      __name(Md5, "Md5");
      Md5.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var result = formatMessage(message);
        message = result[0];
        var isString2 = result[1];
        var code, index = 0, i, length2 = message.length, blocks2 = this.blocks;
        var buffer82 = this.buffer8;
        while (index < length2) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = blocks2[16];
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (isString2) {
            if (ARRAY_BUFFER) {
              for (i = this.start; index < length2 && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  buffer82[i++] = code;
                } else if (code < 2048) {
                  buffer82[i++] = 192 | code >>> 6;
                  buffer82[i++] = 128 | code & 63;
                } else if (code < 55296 || code >= 57344) {
                  buffer82[i++] = 224 | code >>> 12;
                  buffer82[i++] = 128 | code >>> 6 & 63;
                  buffer82[i++] = 128 | code & 63;
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  buffer82[i++] = 240 | code >>> 18;
                  buffer82[i++] = 128 | code >>> 12 & 63;
                  buffer82[i++] = 128 | code >>> 6 & 63;
                  buffer82[i++] = 128 | code & 63;
                }
              }
            } else {
              for (i = this.start; index < length2 && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks2[i >>> 2] |= code << SHIFT[i++ & 3];
                } else if (code < 2048) {
                  blocks2[i >>> 2] |= (192 | code >>> 6) << SHIFT[i++ & 3];
                  blocks2[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks2[i >>> 2] |= (224 | code >>> 12) << SHIFT[i++ & 3];
                  blocks2[i >>> 2] |= (128 | code >>> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks2[i >>> 2] |= (240 | code >>> 18) << SHIFT[i++ & 3];
                  blocks2[i >>> 2] |= (128 | code >>> 12 & 63) << SHIFT[i++ & 3];
                  blocks2[i >>> 2] |= (128 | code >>> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                }
              }
            }
          } else {
            if (ARRAY_BUFFER) {
              for (i = this.start; index < length2 && i < 64; ++index) {
                buffer82[i++] = message[index];
              }
            } else {
              for (i = this.start; index < length2 && i < 64; ++index) {
                blocks2[i >>> 2] |= message[index] << SHIFT[i++ & 3];
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Md5.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i = this.lastByteIndex;
        blocks2[i >>> 2] |= EXTRA[i & 3];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = blocks2[16];
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.bytes << 3;
        blocks2[15] = this.hBytes << 3 | this.bytes >>> 29;
        this.hash();
      };
      Md5.prototype.hash = function() {
        var a, b, c, d2, bc, da, blocks2 = this.blocks;
        if (this.first) {
          a = blocks2[0] - 680876937;
          a = (a << 7 | a >>> 25) - 271733879 << 0;
          d2 = (-1732584194 ^ a & 2004318071) + blocks2[1] - 117830708;
          d2 = (d2 << 12 | d2 >>> 20) + a << 0;
          c = (-271733879 ^ d2 & (a ^ -271733879)) + blocks2[2] - 1126478375;
          c = (c << 17 | c >>> 15) + d2 << 0;
          b = (a ^ c & (d2 ^ a)) + blocks2[3] - 1316259209;
          b = (b << 22 | b >>> 10) + c << 0;
        } else {
          a = this.h0;
          b = this.h1;
          c = this.h2;
          d2 = this.h3;
          a += (d2 ^ b & (c ^ d2)) + blocks2[0] - 680876936;
          a = (a << 7 | a >>> 25) + b << 0;
          d2 += (c ^ a & (b ^ c)) + blocks2[1] - 389564586;
          d2 = (d2 << 12 | d2 >>> 20) + a << 0;
          c += (b ^ d2 & (a ^ b)) + blocks2[2] + 606105819;
          c = (c << 17 | c >>> 15) + d2 << 0;
          b += (a ^ c & (d2 ^ a)) + blocks2[3] - 1044525330;
          b = (b << 22 | b >>> 10) + c << 0;
        }
        a += (d2 ^ b & (c ^ d2)) + blocks2[4] - 176418897;
        a = (a << 7 | a >>> 25) + b << 0;
        d2 += (c ^ a & (b ^ c)) + blocks2[5] + 1200080426;
        d2 = (d2 << 12 | d2 >>> 20) + a << 0;
        c += (b ^ d2 & (a ^ b)) + blocks2[6] - 1473231341;
        c = (c << 17 | c >>> 15) + d2 << 0;
        b += (a ^ c & (d2 ^ a)) + blocks2[7] - 45705983;
        b = (b << 22 | b >>> 10) + c << 0;
        a += (d2 ^ b & (c ^ d2)) + blocks2[8] + 1770035416;
        a = (a << 7 | a >>> 25) + b << 0;
        d2 += (c ^ a & (b ^ c)) + blocks2[9] - 1958414417;
        d2 = (d2 << 12 | d2 >>> 20) + a << 0;
        c += (b ^ d2 & (a ^ b)) + blocks2[10] - 42063;
        c = (c << 17 | c >>> 15) + d2 << 0;
        b += (a ^ c & (d2 ^ a)) + blocks2[11] - 1990404162;
        b = (b << 22 | b >>> 10) + c << 0;
        a += (d2 ^ b & (c ^ d2)) + blocks2[12] + 1804603682;
        a = (a << 7 | a >>> 25) + b << 0;
        d2 += (c ^ a & (b ^ c)) + blocks2[13] - 40341101;
        d2 = (d2 << 12 | d2 >>> 20) + a << 0;
        c += (b ^ d2 & (a ^ b)) + blocks2[14] - 1502002290;
        c = (c << 17 | c >>> 15) + d2 << 0;
        b += (a ^ c & (d2 ^ a)) + blocks2[15] + 1236535329;
        b = (b << 22 | b >>> 10) + c << 0;
        a += (c ^ d2 & (b ^ c)) + blocks2[1] - 165796510;
        a = (a << 5 | a >>> 27) + b << 0;
        d2 += (b ^ c & (a ^ b)) + blocks2[6] - 1069501632;
        d2 = (d2 << 9 | d2 >>> 23) + a << 0;
        c += (a ^ b & (d2 ^ a)) + blocks2[11] + 643717713;
        c = (c << 14 | c >>> 18) + d2 << 0;
        b += (d2 ^ a & (c ^ d2)) + blocks2[0] - 373897302;
        b = (b << 20 | b >>> 12) + c << 0;
        a += (c ^ d2 & (b ^ c)) + blocks2[5] - 701558691;
        a = (a << 5 | a >>> 27) + b << 0;
        d2 += (b ^ c & (a ^ b)) + blocks2[10] + 38016083;
        d2 = (d2 << 9 | d2 >>> 23) + a << 0;
        c += (a ^ b & (d2 ^ a)) + blocks2[15] - 660478335;
        c = (c << 14 | c >>> 18) + d2 << 0;
        b += (d2 ^ a & (c ^ d2)) + blocks2[4] - 405537848;
        b = (b << 20 | b >>> 12) + c << 0;
        a += (c ^ d2 & (b ^ c)) + blocks2[9] + 568446438;
        a = (a << 5 | a >>> 27) + b << 0;
        d2 += (b ^ c & (a ^ b)) + blocks2[14] - 1019803690;
        d2 = (d2 << 9 | d2 >>> 23) + a << 0;
        c += (a ^ b & (d2 ^ a)) + blocks2[3] - 187363961;
        c = (c << 14 | c >>> 18) + d2 << 0;
        b += (d2 ^ a & (c ^ d2)) + blocks2[8] + 1163531501;
        b = (b << 20 | b >>> 12) + c << 0;
        a += (c ^ d2 & (b ^ c)) + blocks2[13] - 1444681467;
        a = (a << 5 | a >>> 27) + b << 0;
        d2 += (b ^ c & (a ^ b)) + blocks2[2] - 51403784;
        d2 = (d2 << 9 | d2 >>> 23) + a << 0;
        c += (a ^ b & (d2 ^ a)) + blocks2[7] + 1735328473;
        c = (c << 14 | c >>> 18) + d2 << 0;
        b += (d2 ^ a & (c ^ d2)) + blocks2[12] - 1926607734;
        b = (b << 20 | b >>> 12) + c << 0;
        bc = b ^ c;
        a += (bc ^ d2) + blocks2[5] - 378558;
        a = (a << 4 | a >>> 28) + b << 0;
        d2 += (bc ^ a) + blocks2[8] - 2022574463;
        d2 = (d2 << 11 | d2 >>> 21) + a << 0;
        da = d2 ^ a;
        c += (da ^ b) + blocks2[11] + 1839030562;
        c = (c << 16 | c >>> 16) + d2 << 0;
        b += (da ^ c) + blocks2[14] - 35309556;
        b = (b << 23 | b >>> 9) + c << 0;
        bc = b ^ c;
        a += (bc ^ d2) + blocks2[1] - 1530992060;
        a = (a << 4 | a >>> 28) + b << 0;
        d2 += (bc ^ a) + blocks2[4] + 1272893353;
        d2 = (d2 << 11 | d2 >>> 21) + a << 0;
        da = d2 ^ a;
        c += (da ^ b) + blocks2[7] - 155497632;
        c = (c << 16 | c >>> 16) + d2 << 0;
        b += (da ^ c) + blocks2[10] - 1094730640;
        b = (b << 23 | b >>> 9) + c << 0;
        bc = b ^ c;
        a += (bc ^ d2) + blocks2[13] + 681279174;
        a = (a << 4 | a >>> 28) + b << 0;
        d2 += (bc ^ a) + blocks2[0] - 358537222;
        d2 = (d2 << 11 | d2 >>> 21) + a << 0;
        da = d2 ^ a;
        c += (da ^ b) + blocks2[3] - 722521979;
        c = (c << 16 | c >>> 16) + d2 << 0;
        b += (da ^ c) + blocks2[6] + 76029189;
        b = (b << 23 | b >>> 9) + c << 0;
        bc = b ^ c;
        a += (bc ^ d2) + blocks2[9] - 640364487;
        a = (a << 4 | a >>> 28) + b << 0;
        d2 += (bc ^ a) + blocks2[12] - 421815835;
        d2 = (d2 << 11 | d2 >>> 21) + a << 0;
        da = d2 ^ a;
        c += (da ^ b) + blocks2[15] + 530742520;
        c = (c << 16 | c >>> 16) + d2 << 0;
        b += (da ^ c) + blocks2[2] - 995338651;
        b = (b << 23 | b >>> 9) + c << 0;
        a += (c ^ (b | ~d2)) + blocks2[0] - 198630844;
        a = (a << 6 | a >>> 26) + b << 0;
        d2 += (b ^ (a | ~c)) + blocks2[7] + 1126891415;
        d2 = (d2 << 10 | d2 >>> 22) + a << 0;
        c += (a ^ (d2 | ~b)) + blocks2[14] - 1416354905;
        c = (c << 15 | c >>> 17) + d2 << 0;
        b += (d2 ^ (c | ~a)) + blocks2[5] - 57434055;
        b = (b << 21 | b >>> 11) + c << 0;
        a += (c ^ (b | ~d2)) + blocks2[12] + 1700485571;
        a = (a << 6 | a >>> 26) + b << 0;
        d2 += (b ^ (a | ~c)) + blocks2[3] - 1894986606;
        d2 = (d2 << 10 | d2 >>> 22) + a << 0;
        c += (a ^ (d2 | ~b)) + blocks2[10] - 1051523;
        c = (c << 15 | c >>> 17) + d2 << 0;
        b += (d2 ^ (c | ~a)) + blocks2[1] - 2054922799;
        b = (b << 21 | b >>> 11) + c << 0;
        a += (c ^ (b | ~d2)) + blocks2[8] + 1873313359;
        a = (a << 6 | a >>> 26) + b << 0;
        d2 += (b ^ (a | ~c)) + blocks2[15] - 30611744;
        d2 = (d2 << 10 | d2 >>> 22) + a << 0;
        c += (a ^ (d2 | ~b)) + blocks2[6] - 1560198380;
        c = (c << 15 | c >>> 17) + d2 << 0;
        b += (d2 ^ (c | ~a)) + blocks2[13] + 1309151649;
        b = (b << 21 | b >>> 11) + c << 0;
        a += (c ^ (b | ~d2)) + blocks2[4] - 145523070;
        a = (a << 6 | a >>> 26) + b << 0;
        d2 += (b ^ (a | ~c)) + blocks2[11] - 1120210379;
        d2 = (d2 << 10 | d2 >>> 22) + a << 0;
        c += (a ^ (d2 | ~b)) + blocks2[2] + 718787259;
        c = (c << 15 | c >>> 17) + d2 << 0;
        b += (d2 ^ (c | ~a)) + blocks2[9] - 343485551;
        b = (b << 21 | b >>> 11) + c << 0;
        if (this.first) {
          this.h0 = a + 1732584193 << 0;
          this.h1 = b - 271733879 << 0;
          this.h2 = c - 1732584194 << 0;
          this.h3 = d2 + 271733878 << 0;
          this.first = false;
        } else {
          this.h0 = this.h0 + a << 0;
          this.h1 = this.h1 + b << 0;
          this.h2 = this.h2 + c << 0;
          this.h3 = this.h3 + d2 << 0;
        }
      };
      Md5.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
        return HEX_CHARS[h0 >>> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h0 >>> 12 & 15] + HEX_CHARS[h0 >>> 8 & 15] + HEX_CHARS[h0 >>> 20 & 15] + HEX_CHARS[h0 >>> 16 & 15] + HEX_CHARS[h0 >>> 28 & 15] + HEX_CHARS[h0 >>> 24 & 15] + HEX_CHARS[h1 >>> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h1 >>> 12 & 15] + HEX_CHARS[h1 >>> 8 & 15] + HEX_CHARS[h1 >>> 20 & 15] + HEX_CHARS[h1 >>> 16 & 15] + HEX_CHARS[h1 >>> 28 & 15] + HEX_CHARS[h1 >>> 24 & 15] + HEX_CHARS[h2 >>> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h2 >>> 12 & 15] + HEX_CHARS[h2 >>> 8 & 15] + HEX_CHARS[h2 >>> 20 & 15] + HEX_CHARS[h2 >>> 16 & 15] + HEX_CHARS[h2 >>> 28 & 15] + HEX_CHARS[h2 >>> 24 & 15] + HEX_CHARS[h3 >>> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h3 >>> 12 & 15] + HEX_CHARS[h3 >>> 8 & 15] + HEX_CHARS[h3 >>> 20 & 15] + HEX_CHARS[h3 >>> 16 & 15] + HEX_CHARS[h3 >>> 28 & 15] + HEX_CHARS[h3 >>> 24 & 15];
      };
      Md5.prototype.toString = Md5.prototype.hex;
      Md5.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
        return [
          h0 & 255,
          h0 >>> 8 & 255,
          h0 >>> 16 & 255,
          h0 >>> 24 & 255,
          h1 & 255,
          h1 >>> 8 & 255,
          h1 >>> 16 & 255,
          h1 >>> 24 & 255,
          h2 & 255,
          h2 >>> 8 & 255,
          h2 >>> 16 & 255,
          h2 >>> 24 & 255,
          h3 & 255,
          h3 >>> 8 & 255,
          h3 >>> 16 & 255,
          h3 >>> 24 & 255
        ];
      };
      Md5.prototype.array = Md5.prototype.digest;
      Md5.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer2 = new ArrayBuffer(16);
        var blocks2 = new Uint32Array(buffer2);
        blocks2[0] = this.h0;
        blocks2[1] = this.h1;
        blocks2[2] = this.h2;
        blocks2[3] = this.h3;
        return buffer2;
      };
      Md5.prototype.buffer = Md5.prototype.arrayBuffer;
      Md5.prototype.base64 = function() {
        var v1, v2, v3, base64Str = "", bytes = this.array();
        for (var i = 0; i < 15; ) {
          v1 = bytes[i++];
          v2 = bytes[i++];
          v3 = bytes[i++];
          base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[(v1 << 4 | v2 >>> 4) & 63] + BASE64_ENCODE_CHAR[(v2 << 2 | v3 >>> 6) & 63] + BASE64_ENCODE_CHAR[v3 & 63];
        }
        v1 = bytes[i];
        base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[v1 << 4 & 63] + "==";
        return base64Str;
      };
      function HmacMd5(key, sharedMemory) {
        var i, result = formatMessage(key);
        key = result[0];
        if (result[1]) {
          var bytes = [], length2 = key.length, index = 0, code;
          for (i = 0; i < length2; ++i) {
            code = key.charCodeAt(i);
            if (code < 128) {
              bytes[index++] = code;
            } else if (code < 2048) {
              bytes[index++] = 192 | code >>> 6;
              bytes[index++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              bytes[index++] = 224 | code >>> 12;
              bytes[index++] = 128 | code >>> 6 & 63;
              bytes[index++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023);
              bytes[index++] = 240 | code >>> 18;
              bytes[index++] = 128 | code >>> 12 & 63;
              bytes[index++] = 128 | code >>> 6 & 63;
              bytes[index++] = 128 | code & 63;
            }
          }
          key = bytes;
        }
        if (key.length > 64) {
          key = new Md5(true).update(key).array();
        }
        var oKeyPad = [], iKeyPad = [];
        for (i = 0; i < 64; ++i) {
          var b = key[i] || 0;
          oKeyPad[i] = 92 ^ b;
          iKeyPad[i] = 54 ^ b;
        }
        Md5.call(this, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      __name(HmacMd5, "HmacMd5");
      HmacMd5.prototype = new Md5();
      HmacMd5.prototype.finalize = function() {
        Md5.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Md5.call(this, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Md5.prototype.finalize.call(this);
        }
      };
      var exports3 = createMethod();
      exports3.md5 = exports3;
      exports3.md5.hmac = createHmacMethod();
      if (COMMON_JS) {
        module2.exports = exports3;
      } else {
        root2.md5 = exports3;
        if (AMD) {
          define(function() {
            return exports3;
          });
        }
      }
    })();
  }
});

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports2, module2) {
    init_process_shim();
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames5() {
        var classes = "";
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      __name(classNames5, "classNames");
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames5.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      __name(parseValue, "parseValue");
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      __name(appendClass, "appendClass");
      if (typeof module2 !== "undefined" && module2.exports) {
        classNames5.default = classNames5;
        module2.exports = classNames5;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames5;
        });
      } else {
        window.classNames = classNames5;
      }
    })();
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);
init_process_shim();

// src/ScreenGardenPlugin.ts
init_process_shim();

// src/db/index.ts
init_process_shim();

// src/db/Database.ts
init_process_shim();

// src/services/index.ts
init_process_shim();

// src/services/protocols/index.ts
init_process_shim();

// src/services/protocols/ProtocolHandlerService.ts
init_process_shim();

// src/services/Service.ts
init_process_shim();
var import_obsidian = require("obsidian");
var _Service = class _Service extends import_obsidian.Events {
  constructor(plugin) {
    super();
    this.plugin = plugin;
  }
  get db() {
    return this.plugin.db;
  }
  register(cb) {
    this.plugin.register(cb);
  }
  registerEvent(ref) {
    this.plugin.registerEvent(ref);
  }
  trigger(name, ...data) {
    super.trigger("screengarden:" + name, ...data);
  }
  on(name, callback, ctx) {
    return super.on("screengarden:" + name, callback, ctx);
  }
  async onload() {
  }
  async onLayoutReady() {
  }
  async onunload() {
  }
};
__name(_Service, "Service");
var Service = _Service;

// src/services/protocols/ProtocolHandlerService.ts
var import_debug = __toESM(require_browser2());
var _ProtocolHandlerService = class _ProtocolHandlerService extends Service {
  async onload() {
    const log17 = (0, import_debug.default)("screen.garden:protocols");
    log17("registering protocol handlers");
    this.plugin.registerObsidianProtocolHandler(
      "screengarden-login",
      this.handleLogin.bind(this)
    );
  }
  async handleLogin(params2) {
    const log17 = (0, import_debug.default)("screen.garden:protocols:login");
    log17("starting");
    if (!params2["token"]) {
      log17("missing token in login protocol handler");
      return;
    }
    log17("setting token");
    await this.plugin.settings.updateConfig({
      token: params2["token"],
      needsReauth: false
    });
    log17("done");
  }
};
__name(_ProtocolHandlerService, "ProtocolHandlerService");
var ProtocolHandlerService = _ProtocolHandlerService;

// src/services/settings/index.ts
init_process_shim();

// src/services/settings/SettingsService.ts
init_process_shim();

// src/services/settings/SettingsTab.ts
init_process_shim();

// src/constants.ts
init_process_shim();
var BASE_HTTP_URL = "https://app.screen.garden";
var baseWsUrl = new URL(BASE_HTTP_URL);
baseWsUrl.protocol = baseWsUrl.protocol.startsWith("https") ? "wss:" : "ws:";
var BASE_WS_URL = baseWsUrl.toString();

// src/services/views/View.tsx
init_process_shim();

// src/services/views/context/DefaultProviders.tsx
init_process_shim();

// src/services/views/context/AppContext.tsx
init_process_shim();
var import_react = __toESM(require_react());
var AppContext = (0, import_react.createContext)(void 0);

// src/services/views/context/PluginContext.tsx
init_process_shim();
var import_react2 = __toESM(require_react());
var PluginContext = (0, import_react2.createContext)(void 0);
var usePlugin = /* @__PURE__ */ __name(() => {
  return (0, import_react2.useContext)(PluginContext);
}, "usePlugin");

// src/services/views/context/DefaultProviders.tsx
var import_react3 = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var DefaultProviders = /* @__PURE__ */ __name(({ app, plugin, children }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react3.StrictMode, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AppContext.Provider, { value: app, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PluginContext.Provider, { value: plugin, children }) }) }), "DefaultProviders");

// src/services/views/View.tsx
var import_obsidian2 = require("obsidian");
var import_react4 = __toESM(require_react());
var import_client = __toESM(require_client());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var _View = class _View extends import_obsidian2.ItemView {
  constructor(plugin, leaf) {
    super(leaf);
    this.plugin = plugin;
    this.root = null;
  }
  getViewType() {
    return this.constructor.ViewType();
  }
  createRoot(children) {
    this.root = (0, import_client.createRoot)(this.contentEl);
    this.root.render(
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(DefaultProviders, { app: this.app, plugin: this.plugin, children })
    );
  }
  async onClose() {
    var _a9;
    (_a9 = this.root) == null ? void 0 : _a9.unmount();
  }
};
__name(_View, "View");
var View = _View;
function useObservable(obs, initial, deps = []) {
  const [value, setValue] = (0, import_react4.useState)(initial);
  (0, import_react4.useEffect)(() => {
    const subscription = obs.subscribe({
      next: /* @__PURE__ */ __name((v) => {
        setValue(v);
      }, "next")
    });
    return () => {
      subscription.unsubscribe();
    };
  }, deps);
  return value;
}
__name(useObservable, "useObservable");

// src/services/settings/SettingsTab.ts
var import_debug2 = __toESM(require_browser2());
var import_obsidian3 = require("obsidian");

// node_modules/rxjs/dist/esm5/index.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/Observable.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
init_process_shim();

// node_modules/tslib/tslib.es6.mjs
init_process_shim();
var extendStatics = /* @__PURE__ */ __name(function(d2, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
    d3.__proto__ = b2;
  } || function(d3, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d3[p] = b2[p];
  };
  return extendStatics(d2, b);
}, "extendStatics");
function __extends(d2, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d2, b);
  function __() {
    this.constructor = d2;
  }
  __name(__, "__");
  d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
__name(__extends, "__extends");
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
__name(__awaiter, "__awaiter");
function __generator(thisArg, body) {
  var _ = { label: 0, sent: /* @__PURE__ */ __name(function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, "sent"), trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  __name(verb, "verb");
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
  __name(step, "step");
}
__name(__generator, "__generator");
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: /* @__PURE__ */ __name(function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }, "next")
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
__name(__values, "__values");
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
__name(__read, "__read");
function __spreadArray(to, from3, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from3.length, ar; i < l; i++) {
    if (ar || !(i in from3)) {
      if (!ar) ar = Array.prototype.slice.call(from3, 0, i);
      ar[i] = from3[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from3));
}
__name(__spreadArray, "__spreadArray");
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
__name(__await, "__await");
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  __name(awaitReturn, "awaitReturn");
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  __name(verb, "verb");
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle2(q[0][3], e);
    }
  }
  __name(resume, "resume");
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle2(q[0][2], r);
  }
  __name(step, "step");
  function fulfill(value) {
    resume("next", value);
  }
  __name(fulfill, "fulfill");
  function reject(value) {
    resume("throw", value);
  }
  __name(reject, "reject");
  function settle2(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
  __name(settle2, "settle");
}
__name(__asyncGenerator, "__asyncGenerator");
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle2(resolve, reject, v.done, v.value);
      });
    };
  }
  __name(verb, "verb");
  function settle2(resolve, reject, d2, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d2 });
    }, reject);
  }
  __name(settle2, "settle");
}
__name(__asyncValues, "__asyncValues");

// node_modules/rxjs/dist/esm5/internal/util/isFunction.js
init_process_shim();
function isFunction(value) {
  return typeof value === "function";
}
__name(isFunction, "isFunction");

// node_modules/rxjs/dist/esm5/internal/Subscription.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
init_process_shim();
function createErrorClass(createImpl) {
  var _super = /* @__PURE__ */ __name(function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  }, "_super");
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
__name(createErrorClass, "createErrorClass");

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return /* @__PURE__ */ __name(function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err2, i) {
      return i + 1 + ") " + err2.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  }, "UnsubscriptionErrorImpl");
});

// node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
init_process_shim();
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}
__name(arrRemove, "arrRemove");

// node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription3(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  __name(Subscription3, "Subscription");
  Subscription3.prototype.unsubscribe = function() {
    var e_1, _a9, e_2, _b2;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a9 = _parentage_1.return)) _a9.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err2) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err2 instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err2.errors));
              } else {
                errors.push(err2);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b2 = _finalizers_1.return)) _b2.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription3.prototype.add = function(teardown) {
    var _a9;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription3) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a9 = this._finalizers) !== null && _a9 !== void 0 ? _a9 : []).push(teardown);
      }
    }
  };
  Subscription3.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription3.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription3.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription3.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription3) {
      teardown._removeParent(this);
    }
  };
  Subscription3.EMPTY = function() {
    var empty = new Subscription3();
    empty.closed = true;
    return empty;
  }();
  return Subscription3;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
__name(isSubscription, "isSubscription");
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
__name(execFinalizer, "execFinalizer");

// node_modules/rxjs/dist/esm5/internal/config.js
init_process_shim();
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
init_process_shim();
var timeoutProvider = {
  setTimeout: /* @__PURE__ */ __name(function(handler, timeout) {
    var args2 = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args2[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args2)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args2)));
  }, "setTimeout"),
  clearTimeout: /* @__PURE__ */ __name(function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  }, "clearTimeout"),
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err2) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err2);
    } else {
      throw err2;
    }
  });
}
__name(reportUnhandledError, "reportUnhandledError");

// node_modules/rxjs/dist/esm5/internal/util/noop.js
init_process_shim();
function noop() {
}
__name(noop, "noop");

// node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
init_process_shim();
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
__name(errorNotification, "errorNotification");
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
__name(nextNotification, "nextNotification");
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}
__name(createNotification, "createNotification");

// node_modules/rxjs/dist/esm5/internal/util/errorContext.js
init_process_shim();
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a9 = context, errorThrown = _a9.errorThrown, error = _a9.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
__name(errorContext, "errorContext");
function captureError(err2) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err2;
  }
}
__name(captureError, "captureError");

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  __name(Subscriber2, "Subscriber");
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err2) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err2), this);
    } else {
      this.isStopped = true;
      this._error(err2);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err2) {
    try {
      this.destination.error(err2);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
__name(bind, "bind");
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  __name(ConsumerObserver2, "ConsumerObserver");
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err2) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err2);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err2);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  __name(SafeSubscriber2, "SafeSubscriber");
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
__name(handleUnhandledError, "handleUnhandledError");
function defaultErrorHandler(err2) {
  throw err2;
}
__name(defaultErrorHandler, "defaultErrorHandler");
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
__name(handleStoppedNotification, "handleStoppedNotification");
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// node_modules/rxjs/dist/esm5/internal/symbol/observable.js
init_process_shim();
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/util/identity.js
init_process_shim();
function identity(x) {
  return x;
}
__name(identity, "identity");

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return /* @__PURE__ */ __name(function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  }, "piped");
}
__name(pipeFromArray, "pipeFromArray");

// node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable8(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  __name(Observable8, "Observable");
  Observable8.prototype.lift = function(operator) {
    var observable2 = new Observable8();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable8.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a9 = _this, operator = _a9.operator, source = _a9.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable8.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err2) {
      sink.error(err2);
    }
  };
  Observable8.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: /* @__PURE__ */ __name(function(value) {
          try {
            next(value);
          } catch (err2) {
            reject(err2);
            subscriber.unsubscribe();
          }
        }, "next"),
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable8.prototype._subscribe = function(subscriber) {
    var _a9;
    return (_a9 = this.source) === null || _a9 === void 0 ? void 0 : _a9.subscribe(subscriber);
  };
  Observable8.prototype[observable] = function() {
    return this;
  };
  Observable8.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable8.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err2) {
        return reject(err2);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable8.create = function(subscribe) {
    return new Observable8(subscribe);
  };
  return Observable8;
}();
function getPromiseCtor(promiseCtor) {
  var _a9;
  return (_a9 = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a9 !== void 0 ? _a9 : Promise;
}
__name(getPromiseCtor, "getPromiseCtor");
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
__name(isObserver, "isObserver");
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
__name(isSubscriber, "isSubscriber");

// node_modules/rxjs/dist/esm5/internal/util/lift.js
init_process_shim();
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
__name(hasLift, "hasLift");
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err2) {
          this.error(err2);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
__name(operate, "operate");

// node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
init_process_shim();
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
__name(createOperatorSubscriber, "createOperatorSubscriber");
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err2) {
        destination.error(err2);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err2) {
      try {
        onError(err2);
      } catch (err3) {
        destination.error(err3);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  __name(OperatorSubscriber2, "OperatorSubscriber");
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a9;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a9 = this.onFinalize) === null || _a9 === void 0 ? void 0 : _a9.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);

// node_modules/rxjs/dist/esm5/internal/Subject.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
init_process_shim();
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return /* @__PURE__ */ __name(function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  }, "ObjectUnsubscribedErrorImpl");
});

// node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  __name(Subject2, "Subject");
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a9;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b2 = __values(_this.currentObservers), _c = _b2.next(); !_c.done; _c = _b2.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a9 = _b2.return)) _a9.call(_b2);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err2) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err2;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err2);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: /* @__PURE__ */ __name(function() {
      var _a9;
      return ((_a9 = this.observers) === null || _a9 === void 0 ? void 0 : _a9.length) > 0;
    }, "get"),
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a9 = this, hasError = _a9.hasError, isStopped = _a9.isStopped, observers = _a9.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a9 = this, hasError = _a9.hasError, thrownError = _a9.thrownError, isStopped = _a9.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  __name(AnonymousSubject2, "AnonymousSubject");
  AnonymousSubject2.prototype.next = function(value) {
    var _a9, _b2;
    (_b2 = (_a9 = this.destination) === null || _a9 === void 0 ? void 0 : _a9.next) === null || _b2 === void 0 ? void 0 : _b2.call(_a9, value);
  };
  AnonymousSubject2.prototype.error = function(err2) {
    var _a9, _b2;
    (_b2 = (_a9 = this.destination) === null || _a9 === void 0 ? void 0 : _a9.error) === null || _b2 === void 0 ? void 0 : _b2.call(_a9, err2);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a9, _b2;
    (_b2 = (_a9 = this.destination) === null || _a9 === void 0 ? void 0 : _a9.complete) === null || _b2 === void 0 ? void 0 : _b2.call(_a9);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a9, _b2;
    return (_b2 = (_a9 = this.source) === null || _a9 === void 0 ? void 0 : _a9.subscribe(subscriber)) !== null && _b2 !== void 0 ? _b2 : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
init_process_shim();
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  __name(BehaviorSubject2, "BehaviorSubject");
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: /* @__PURE__ */ __name(function() {
      return this.getValue();
    }, "get"),
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a9 = this, hasError = _a9.hasError, thrownError = _a9.thrownError, _value = _a9._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
init_process_shim();
var dateTimestampProvider = {
  now: /* @__PURE__ */ __name(function() {
    return (dateTimestampProvider.delegate || Date).now();
  }, "now"),
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  __name(ReplaySubject2, "ReplaySubject");
  ReplaySubject2.prototype.next = function(value) {
    var _a9 = this, isStopped = _a9.isStopped, _buffer = _a9._buffer, _infiniteTimeWindow = _a9._infiniteTimeWindow, _timestampProvider = _a9._timestampProvider, _windowTime = _a9._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a9 = this, _infiniteTimeWindow = _a9._infiniteTimeWindow, _buffer = _a9._buffer;
    var copy2 = _buffer.slice();
    for (var i = 0; i < copy2.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy2[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a9 = this, _bufferSize = _a9._bufferSize, _timestampProvider = _a9._timestampProvider, _buffer = _a9._buffer, _infiniteTimeWindow = _a9._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now2 = _timestampProvider.now();
      var last3 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now2; i += 2) {
        last3 = i;
      }
      last3 && _buffer.splice(0, last3 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
init_process_shim();
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  __name(Action2, "Action");
  Action2.prototype.schedule = function(state, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return this;
  };
  return Action2;
}(Subscription);

// node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
init_process_shim();
var intervalProvider = {
  setInterval: /* @__PURE__ */ __name(function(handler, timeout) {
    var args2 = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args2[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args2)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args2)));
  }, "setInterval"),
  clearInterval: /* @__PURE__ */ __name(function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  }, "clearInterval"),
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  __name(AsyncAction2, "AsyncAction");
  AsyncAction2.prototype.schedule = function(state, delay) {
    var _a9;
    if (delay === void 0) {
      delay = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id2 = this.id;
    var scheduler = this.scheduler;
    if (id2 != null) {
      this.id = this.recycleAsyncId(scheduler, id2, delay);
    }
    this.pending = true;
    this.delay = delay;
    this.id = (_a9 = this.id) !== null && _a9 !== void 0 ? _a9 : this.requestAsyncId(scheduler, this.id, delay);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id2, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (delay != null && this.delay === delay && this.pending === false) {
      return id2;
    }
    if (id2 != null) {
      intervalProvider.clearInterval(id2);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a9 = this, id2 = _a9.id, scheduler = _a9.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id2 != null) {
        this.id = this.recycleAsyncId(scheduler, id2, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/Scheduler.js
init_process_shim();
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now2) {
    if (now2 === void 0) {
      now2 = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now2;
  }
  __name(Scheduler2, "Scheduler");
  Scheduler2.prototype.schedule = function(work, delay, state) {
    if (delay === void 0) {
      delay = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now2) {
    if (now2 === void 0) {
      now2 = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now2) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  __name(AsyncScheduler2, "AsyncScheduler");
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/async.js
init_process_shim();
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;

// node_modules/rxjs/dist/esm5/internal/observable/of.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/util/args.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
init_process_shim();
function isScheduler(value) {
  return value && isFunction(value.schedule);
}
__name(isScheduler, "isScheduler");

// node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
__name(last, "last");
function popResultSelector(args2) {
  return isFunction(last(args2)) ? args2.pop() : void 0;
}
__name(popResultSelector, "popResultSelector");
function popScheduler(args2) {
  return isScheduler(last(args2)) ? args2.pop() : void 0;
}
__name(popScheduler, "popScheduler");

// node_modules/rxjs/dist/esm5/internal/observable/from.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
init_process_shim();
var isArrayLike = /* @__PURE__ */ __name(function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
}, "isArrayLike");

// node_modules/rxjs/dist/esm5/internal/util/isPromise.js
init_process_shim();
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}
__name(isPromise, "isPromise");

// node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
init_process_shim();
function isInteropObservable(input) {
  return isFunction(input[observable]);
}
__name(isInteropObservable, "isInteropObservable");

// node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
init_process_shim();
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
__name(isAsyncIterable, "isAsyncIterable");

// node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
init_process_shim();
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
__name(createInvalidObservableTypeError, "createInvalidObservableTypeError");

// node_modules/rxjs/dist/esm5/internal/util/isIterable.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
init_process_shim();
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
__name(getSymbolIterator, "getSymbolIterator");
var iterator = getSymbolIterator();

// node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}
__name(isIterable, "isIterable");

// node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
init_process_shim();
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, /* @__PURE__ */ __name(function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a9, value, done;
    return __generator(this, function(_b2) {
      switch (_b2.label) {
        case 0:
          reader = readableStream.getReader();
          _b2.label = 1;
        case 1:
          _b2.trys.push([1, , 9, 10]);
          _b2.label = 2;
        case 2:
          if (false) return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a9 = _b2.sent(), value = _a9.value, done = _a9.done;
          if (!done) return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b2.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b2.sent()];
        case 7:
          _b2.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  }, "readableStreamLikeToAsyncGenerator_1"));
}
__name(readableStreamLikeToAsyncGenerator, "readableStreamLikeToAsyncGenerator");
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
__name(isReadableStreamLike, "isReadableStreamLike");

// node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
__name(innerFrom, "innerFrom");
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
__name(fromInteropObservable, "fromInteropObservable");
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
__name(fromArrayLike, "fromArrayLike");
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err2) {
      return subscriber.error(err2);
    }).then(null, reportUnhandledError);
  });
}
__name(fromPromise, "fromPromise");
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a9;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a9 = iterable_1.return)) _a9.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
__name(fromIterable, "fromIterable");
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process2(asyncIterable, subscriber).catch(function(err2) {
      return subscriber.error(err2);
    });
  });
}
__name(fromAsyncIterable, "fromAsyncIterable");
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
__name(fromReadableStreamLike, "fromReadableStreamLike");
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a9;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b2) {
      switch (_b2.label) {
        case 0:
          _b2.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b2.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b2.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b2.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b2.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b2.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a9 = asyncIterable_1.return))) return [3, 8];
          return [4, _a9.call(asyncIterable_1)];
        case 7:
          _b2.sent();
          _b2.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
__name(process2, "process");

// node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
init_process_shim();
function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
  if (delay === void 0) {
    delay = 0;
  }
  if (repeat === void 0) {
    repeat = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay));
    } else {
      this.unsubscribe();
    }
  }, delay);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}
__name(executeSchedule, "executeSchedule");

// node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay);
    }, function(err2) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err2);
      }, delay);
    }));
  });
}
__name(observeOn, "observeOn");

// node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
init_process_shim();
function subscribeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay));
  });
}
__name(subscribeOn, "subscribeOn");

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
__name(scheduleObservable, "scheduleObservable");

// node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
init_process_shim();
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
__name(schedulePromise, "schedulePromise");

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
init_process_shim();
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
__name(scheduleArray, "scheduleArray");

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
init_process_shim();
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator3;
    executeSchedule(subscriber, scheduler, function() {
      iterator3 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a9;
        var value;
        var done;
        try {
          _a9 = iterator3.next(), value = _a9.value, done = _a9.done;
        } catch (err2) {
          subscriber.error(err2);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator3 === null || iterator3 === void 0 ? void 0 : iterator3.return) && iterator3.return();
    };
  });
}
__name(scheduleIterable, "scheduleIterable");

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
init_process_shim();
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator3 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator3.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
__name(scheduleAsyncIterable, "scheduleAsyncIterable");

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
init_process_shim();
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}
__name(scheduleReadableStreamLike, "scheduleReadableStreamLike");

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}
__name(scheduled, "scheduled");

// node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}
__name(from, "from");

// node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args2);
  return from(args2, scheduler);
}
__name(of, "of");

// node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
init_process_shim();
var EmptyError = createErrorClass(function(_super) {
  return /* @__PURE__ */ __name(function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  }, "EmptyErrorImpl");
});

// node_modules/rxjs/dist/esm5/internal/firstValueFrom.js
init_process_shim();
function firstValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var subscriber = new SafeSubscriber({
      next: /* @__PURE__ */ __name(function(value) {
        resolve(value);
        subscriber.unsubscribe();
      }, "next"),
      error: reject,
      complete: /* @__PURE__ */ __name(function() {
        if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }, "complete")
    });
    source.subscribe(subscriber);
  });
}
__name(firstValueFrom, "firstValueFrom");

// node_modules/rxjs/dist/esm5/internal/util/isDate.js
init_process_shim();
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}
__name(isValidDate, "isValidDate");

// node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/operators/map.js
init_process_shim();
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}
__name(map, "map");

// node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
var isArray = Array.isArray;
function callOrApply(fn, args2) {
  return isArray(args2) ? fn.apply(void 0, __spreadArray([], __read(args2))) : fn(args2);
}
__name(callOrApply, "callOrApply");
function mapOneOrManyArgs(fn) {
  return map(function(args2) {
    return callOrApply(fn, args2);
  });
}
__name(mapOneOrManyArgs, "mapOneOrManyArgs");

// node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
init_process_shim();

// node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
init_process_shim();
var isArray2 = Array.isArray;
var getPrototypeOf = Object.getPrototypeOf;
var objectProto = Object.prototype;
var getKeys = Object.keys;
function argsArgArrayOrObject(args2) {
  if (args2.length === 1) {
    var first_1 = args2[0];
    if (isArray2(first_1)) {
      return { args: first_1, keys: null };
    }
    if (isPOJO(first_1)) {
      var keys3 = getKeys(first_1);
      return {
        args: keys3.map(function(key) {
          return first_1[key];
        }),
        keys: keys3
      };
    }
  }
  return { args: args2, keys: null };
}
__name(argsArgArrayOrObject, "argsArgArrayOrObject");
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}
__name(isPOJO, "isPOJO");

// node_modules/rxjs/dist/esm5/internal/util/createObject.js
init_process_shim();
function createObject(keys3, values) {
  return keys3.reduce(function(result, key, i) {
    return result[key] = values[i], result;
  }, {});
}
__name(createObject, "createObject");

// node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
function combineLatest() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args2);
  var resultSelector = popResultSelector(args2);
  var _a9 = argsArgArrayOrObject(args2), observables = _a9.args, keys3 = _a9.keys;
  if (observables.length === 0) {
    return from([], scheduler);
  }
  var result = new Observable(combineLatestInit(observables, scheduler, keys3 ? function(values) {
    return createObject(keys3, values);
  } : identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
__name(combineLatest, "combineLatest");
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity;
  }
  return function(subscriber) {
    maybeSchedule(scheduler, function() {
      var length2 = observables.length;
      var values = new Array(length2);
      var active = length2;
      var remainingFirstValues = length2;
      var _loop_1 = /* @__PURE__ */ __name(function(i2) {
        maybeSchedule(scheduler, function() {
          var source = from(observables[i2], scheduler);
          var hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, function(value) {
            values[i2] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      }, "_loop_1");
      for (var i = 0; i < length2; i++) {
        _loop_1(i);
      }
    }, subscriber);
  };
}
__name(combineLatestInit, "combineLatestInit");
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}
__name(maybeSchedule, "maybeSchedule");

// node_modules/rxjs/dist/esm5/internal/observable/timer.js
init_process_shim();
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}
__name(timer, "timer");

// node_modules/rxjs/dist/esm5/internal/operators/catchError.js
init_process_shim();
function catchError(selector) {
  return operate(function(source, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err2) {
      handledResult = innerFrom(selector(err2, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}
__name(catchError, "catchError");

// node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js
init_process_shim();
function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return function(source, subscriber) {
    var hasState = hasSeed;
    var state = seed;
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var i = index++;
      state = hasState ? accumulator(state, value, i) : (hasState = true, value);
      emitOnNext && subscriber.next(state);
    }, emitBeforeComplete && function() {
      hasState && subscriber.next(state);
      subscriber.complete();
    }));
  };
}
__name(scanInternals, "scanInternals");

// node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js
init_process_shim();
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate(function(source, subscriber) {
    var previousKey;
    var first = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first || !comparator(previousKey, currentKey)) {
        first = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
__name(distinctUntilChanged, "distinctUntilChanged");
function defaultCompare(a, b) {
  return a === b;
}
__name(defaultCompare, "defaultCompare");

// node_modules/rxjs/dist/esm5/internal/operators/scan.js
init_process_shim();
function scan(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
}
__name(scan, "scan");

// node_modules/rxjs/dist/esm5/internal/operators/share.js
init_process_shim();
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a9 = options.connector, connector = _a9 === void 0 ? function() {
    return new Subject();
  } : _a9, _b2 = options.resetOnError, resetOnError = _b2 === void 0 ? true : _b2, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = /* @__PURE__ */ __name(function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    }, "cancelReset");
    var reset = /* @__PURE__ */ __name(function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    }, "reset");
    var resetAndUnsubscribe = /* @__PURE__ */ __name(function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    }, "resetAndUnsubscribe");
    return operate(function(source, subscriber) {
      refCount++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount--;
        if (refCount === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount > 0) {
        connection = new SafeSubscriber({
          next: /* @__PURE__ */ __name(function(value) {
            return dest.next(value);
          }, "next"),
          error: /* @__PURE__ */ __name(function(err2) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err2);
            dest.error(err2);
          }, "error"),
          complete: /* @__PURE__ */ __name(function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }, "complete")
        });
        innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
__name(share, "share");
function handleReset(reset, on) {
  var args2 = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args2[_i - 2] = arguments[_i];
  }
  if (on === true) {
    reset();
    return;
  }
  if (on === false) {
    return;
  }
  var onSubscriber = new SafeSubscriber({
    next: /* @__PURE__ */ __name(function() {
      onSubscriber.unsubscribe();
      reset();
    }, "next")
  });
  return innerFrom(on.apply(void 0, __spreadArray([], __read(args2)))).subscribe(onSubscriber);
}
__name(handleReset, "handleReset");

// node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js
init_process_shim();
function shareReplay(configOrBufferSize, windowTime, scheduler) {
  var _a9, _b2, _c;
  var bufferSize;
  var refCount = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    _a9 = configOrBufferSize.bufferSize, bufferSize = _a9 === void 0 ? Infinity : _a9, _b2 = configOrBufferSize.windowTime, windowTime = _b2 === void 0 ? Infinity : _b2, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share({
    connector: /* @__PURE__ */ __name(function() {
      return new ReplaySubject(bufferSize, windowTime, scheduler);
    }, "connector"),
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount
  });
}
__name(shareReplay, "shareReplay");

// node_modules/rxjs/dist/esm5/internal/operators/switchMap.js
init_process_shim();
function switchMap(project, resultSelector) {
  return operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = /* @__PURE__ */ __name(function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    }, "checkComplete");
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}
__name(switchMap, "switchMap");

// node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js
init_process_shim();
function takeUntil(notifier) {
  return operate(function(source, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}
__name(takeUntil, "takeUntil");

// src/intl.ts
init_process_shim();

// src/generated/messages.js
init_process_shim();

// node_modules/@messageformat/runtime/esm/cardinals.js
init_process_shim();

// node_modules/make-plural/cardinals.mjs
init_process_shim();
var d = /* @__PURE__ */ __name((n) => {
  const s = String(n).split("."), v0 = !s[1];
  return n == 1 && v0 ? "one" : "other";
}, "d");
var en = d;

// node_modules/@messageformat/runtime/esm/runtime.js
init_process_shim();
function _nf(lc) {
  return _nf[lc] || (_nf[lc] = new Intl.NumberFormat(lc));
}
__name(_nf, "_nf");
function number(lc, value, offset) {
  return _nf(lc).format(value - offset);
}
__name(number, "number");
function plural(value, offset, lcfunc, data, isOrdinal) {
  if ({}.hasOwnProperty.call(data, value))
    return data[value];
  if (offset)
    value -= offset;
  var key = lcfunc(value, isOrdinal);
  return key in data ? data[key] : data.other;
}
__name(plural, "plural");
function select(value, data) {
  return {}.hasOwnProperty.call(data, value) ? data[value] : data.other;
}
__name(select, "select");

// src/generated/messages.js
var messages_default = {
  en: {
    home: {
      commandName: /* @__PURE__ */ __name(() => "Show Home tab", "commandName"),
      welcome: /* @__PURE__ */ __name(() => "\u{1F44B} screen.garden lets you sync, share, and work with others right in your vault, ", "welcome"),
      welcomeCursors: /* @__PURE__ */ __name(() => "cursors and all.", "welcomeCursors"),
      startPrefix: /* @__PURE__ */ __name(() => "To get started you\u2019ll need to add a ", "startPrefix"),
      collection: /* @__PURE__ */ __name(() => "collection", "collection"),
      startSuffix: /* @__PURE__ */ __name(() => ", a folder to sync. It can be your entire vault or just a folder somewhere inside it.", "startSuffix"),
      addCollection: /* @__PURE__ */ __name(() => "Add collection", "addCollection"),
      collectionsAvailable1: /* @__PURE__ */ __name((d2) => "Good news: it looks like you already have " + plural(d2.collections, 0, en, { one: "a collection", other: "collections" }) + " available from your " + plural(d2.teams, 0, en, { one: "team", other: "teams" }) + ". To sync and collaborate with your team, choose ", "collectionsAvailable1"),
      collectionsAvailable2: /* @__PURE__ */ __name(() => " below and connect an existing collection.", "collectionsAvailable2"),
      collectionsHeader: /* @__PURE__ */ __name(() => "Collections", "collectionsHeader"),
      collectionCard: {
        activeCollaborators: /* @__PURE__ */ __name(() => "Active Notes", "activeCollaborators"),
        editing: /* @__PURE__ */ __name((d2) => d2.name + " (Editing)", "editing"),
        viewing: /* @__PURE__ */ __name((d2) => d2.name + " (Viewing)", "viewing"),
        anonymous: /* @__PURE__ */ __name(() => "No Name Set", "anonymous"),
        editLabel: /* @__PURE__ */ __name((d2) => "Edit " + d2.name + "\u2019s settings on the web", "editLabel"),
        vault: /* @__PURE__ */ __name(() => "Vault", "vault")
      },
      reauthExplanation: /* @__PURE__ */ __name(() => "Your screen.garden session on this device has expired. Please log in again to continue syncing your changes to the cloud. Any changes made in this state will not be lost.", "reauthExplanation"),
      reauthNotice: /* @__PURE__ */ __name(() => "Please log in to screen.garden in settings to continue.", "reauthNotice"),
      hasRootVault: /* @__PURE__ */ __name((d2) => "Your entire vault is being synced to your \u201C" + d2.collection_name + "\u201D collection.", "hasRootVault"),
      hasRootVaultLearnMore: /* @__PURE__ */ __name(() => "Learn more about full-vault sync.", "hasRootVaultLearnMore"),
      updateRequired: {
        pre: /* @__PURE__ */ __name(() => "Your plugin is out of date; please ", "pre"),
        link: /* @__PURE__ */ __name(() => "update the screen.garden plugin", "link"),
        post: /* @__PURE__ */ __name(() => " in Obsidian settings to continue syncing with your team. Your local changes are always saved.", "post")
      },
      newVersionAvailable: {
        pre: /* @__PURE__ */ __name(() => "A new version of the screen.garden plugin is available: ", "pre"),
        link: /* @__PURE__ */ __name(() => "update in Obsidian settings.", "link"),
        summary: /* @__PURE__ */ __name(() => "Release notes", "summary")
      }
    },
    settingsTab: {
      homeSettingName: /* @__PURE__ */ __name(() => "Home", "homeSettingName"),
      homeSettingDesc: /* @__PURE__ */ __name(() => 'You can always get to the screen.garden Home tab using the "Show Home tab" command.', "homeSettingDesc"),
      showHomeTab: /* @__PURE__ */ __name(() => "Show Home tab", "showHomeTab"),
      accountSettingName: /* @__PURE__ */ __name(() => "Account", "accountSettingName"),
      accountSettingsDesc: /* @__PURE__ */ __name(() => "You are not currently logged into a screen.garden account. screen.garden requires an account to enable realtime, secure collaboration.", "accountSettingsDesc"),
      loginButton: /* @__PURE__ */ __name(() => "Log into screen.garden", "loginButton"),
      createAccountButton: /* @__PURE__ */ __name(() => "Create an account", "createAccountButton"),
      loggedIn: /* @__PURE__ */ __name((d2) => "You are currently logged into your screen.garden account" + select(d2.email, { undefined: ".", other: ": " + d2.email }), "loggedIn"),
      logOutButton: /* @__PURE__ */ __name(() => "Log out", "logOutButton"),
      manageAccountButton: /* @__PURE__ */ __name(() => "Manage account", "manageAccountButton"),
      toggleDebugCommand: /* @__PURE__ */ __name(() => "Toggle debug logging", "toggleDebugCommand"),
      debugToggledNotice: /* @__PURE__ */ __name((d2) => "Debug logging " + d2.state, "debugToggledNotice"),
      authError: /* @__PURE__ */ __name(() => "Error during screen.garden authentication. Please try again.", "authError"),
      loginDetails1: /* @__PURE__ */ __name(() => "Finish connecting to screen.garden in your browser. If a browser did not open,", "loginDetails1"),
      loginDetails2: /* @__PURE__ */ __name(() => "click here.", "loginDetails2"),
      loginDetailsRaw: /* @__PURE__ */ __name((d2) => 'Finish connecting to screen.garden in your browser. If a browser did not open, <a href="' + d2.url + `" target=_'blank'>click here</a>`, "loginDetailsRaw"),
      recentlyLoggedOutWarning: /* @__PURE__ */ __name(() => 'Logging out to log in with a different screen.garden account? Please select the "Reset" from the Troubleshooting section below first to ensure a clean switch.', "recentlyLoggedOutWarning"),
      fullVault: {
        header: /* @__PURE__ */ __name(() => "Full-Vault Sync", "header"),
        desc1: /* @__PURE__ */ __name(() => "You are syncing your entire vault with a single screen.garden collection. You can ", "desc1"),
        desc2: /* @__PURE__ */ __name(() => "read more about this setup", "desc2"),
        desc3: /* @__PURE__ */ __name(() => " in our FAQ.", "desc3"),
        unmountName: /* @__PURE__ */ __name(() => "Disconnect your vault", "unmountName"),
        unmountDesc: /* @__PURE__ */ __name(() => "Disconnect your vault from your screen.garden collection. This will stop sync but no files will be lost. Use this option if you\u2019d like to instead connect folders within your vault to different collections.", "unmountDesc"),
        button: /* @__PURE__ */ __name(() => "Disconnect", "button")
      },
      ui: {
        header: /* @__PURE__ */ __name(() => "UI", "header"),
        folderBorders: {
          name: /* @__PURE__ */ __name(() => "Show collection lines", "name"),
          desc: /* @__PURE__ */ __name(() => "Change the color of the folder indentation lines in the File Explorer for your collections.", "desc")
        },
        folderIcons: {
          name: /* @__PURE__ */ __name(() => "Show folder icons", "name"),
          desc: /* @__PURE__ */ __name(() => "Show icons next to collection folders in the File Explorer.", "desc")
        },
        statusIcon: {
          name: /* @__PURE__ */ __name(() => "Show status item", "name"),
          desc: /* @__PURE__ */ __name(() => "Show an item in the status bar on desktop to indicate when you\u2019re connected to screen.garden servers.", "desc")
        }
      },
      reauth: {
        headerDesc: /* @__PURE__ */ __name(() => "Your screen.garden session has expired. Please log in again to continue using screen.garden.", "headerDesc"),
        button: /* @__PURE__ */ __name(() => "Reauthenticate", "button")
      },
      debug: {
        header: /* @__PURE__ */ __name(() => "Troubleshooting", "header"),
        reset: {
          buttonText: /* @__PURE__ */ __name(() => "Reset", "buttonText"),
          name: /* @__PURE__ */ __name(() => "Reset local storage", "name"),
          desc: /* @__PURE__ */ __name(() => "Resets all screen.garden-related local storage, unmounting collections and untracking notes.", "desc"),
          notice: /* @__PURE__ */ __name(() => "screen.garden local storage reset.", "notice")
        }
      }
    },
    mountModal: {
      contextMenuItem: /* @__PURE__ */ __name(() => "Sync in screen.garden", "contextMenuItem"),
      title: /* @__PURE__ */ __name(() => "Add collection", "title"),
      loadTeamsError: /* @__PURE__ */ __name(() => "No teams loaded; please sign into screen.garden and try again.", "loadTeamsError"),
      nextButton: /* @__PURE__ */ __name(() => "Next", "nextButton"),
      createButton: /* @__PURE__ */ __name(() => "Create", "createButton"),
      connectButton: /* @__PURE__ */ __name(() => "Connect", "connectButton"),
      createErrorNotice: /* @__PURE__ */ __name(() => "Error creating your new collection. Please check dev logs.", "createErrorNotice"),
      successNotice: /* @__PURE__ */ __name(() => "Success! Now syncing, changes will be merged without conflict.", "successNotice"),
      noNestingNotice: /* @__PURE__ */ __name(() => "Cannot put a collection inside another collection.", "noNestingNotice"),
      noPrivacyNotice: /* @__PURE__ */ __name(() => "You must set a collection\u2019s privacy level when creating a new collection.", "noPrivacyNotice"),
      s: {
        team: /* @__PURE__ */ __name(() => "Collections belong to screen.garden teams. Please choose or create a team for this collection.", "team"),
        target1: /* @__PURE__ */ __name(() => "Create a new collection in your ", "target1"),
        target2: /* @__PURE__ */ __name(() => " team or connect an existing collection?", "target2"),
        summary: {
          creating: /* @__PURE__ */ __name(() => "You\u2019re creating ", "creating"),
          "new": /* @__PURE__ */ __name((d2) => ", a new" + d2.affix, "new"),
          private: /* @__PURE__ */ __name(() => "private", "private"),
          team: /* @__PURE__ */ __name(() => "team", "team"),
          collection: /* @__PURE__ */ __name(() => " collection in ", "collection"),
          privacyQuestion: /* @__PURE__ */ __name(() => ". Who should have access to it?", "privacyQuestion"),
          whereQuestion: /* @__PURE__ */ __name(() => ". Where in your vault should it live?", "whereQuestion")
        },
        existing1: /* @__PURE__ */ __name(() => "You\u2019re connecting ", "existing1"),
        existing2: /* @__PURE__ */ __name(() => " in your ", "existing2"),
        existing3: /* @__PURE__ */ __name(() => " team. Where in your vault should it live?", "existing3"),
        noExistingWarning: /* @__PURE__ */ __name(() => "Your folder must be empty to connect it to an existing collection. Please create a new collection or choose an empty folder.", "noExistingWarning")
      },
      t: {
        newTitle: /* @__PURE__ */ __name(() => "New collection", "newTitle"),
        newDesc: /* @__PURE__ */ __name(() => "Create a new collection. Requires internet connection.", "newDesc"),
        existingTitle: /* @__PURE__ */ __name(() => "Connect existing", "existingTitle"),
        existingDesc: /* @__PURE__ */ __name(() => "Sync a collection your team already owns to a folder in your vault.", "existingDesc"),
        chooseDefault: /* @__PURE__ */ __name(() => "Choose a collection\u2026", "chooseDefault")
      },
      privacy: {
        warning1: /* @__PURE__ */ __name(() => "The team owner can always ", "warning1"),
        see: /* @__PURE__ */ __name(() => "see", "see"),
        warning2: /* @__PURE__ */ __name(() => " all collection names for administrative purposes, but may only access collections with permission.", "warning2"),
        team: {
          title: /* @__PURE__ */ __name(() => "Team", "title"),
          description: /* @__PURE__ */ __name((d2) => "Everyone in " + d2.team + " may access this collection.", "description")
        },
        people: {
          title: /* @__PURE__ */ __name(() => "People and groups", "title"),
          description: /* @__PURE__ */ __name(() => "Only you + selected people and groups may access collection.", "description")
        },
        me: {
          title: /* @__PURE__ */ __name(() => "Just me", "title"),
          description: /* @__PURE__ */ __name(() => "Only you may access this collection.", "description")
        },
        add: /* @__PURE__ */ __name(() => "Add", "add"),
        remove: /* @__PURE__ */ __name(() => "Remove", "remove"),
        searchPlaceholder: /* @__PURE__ */ __name(() => "Add users and groups\u2026", "searchPlaceholder"),
        you: /* @__PURE__ */ __name(() => "This is you", "you"),
        member: /* @__PURE__ */ __name(() => "Team member", "member")
      },
      w: {
        vaultTitle: /* @__PURE__ */ __name(() => "Entire vault", "vaultTitle"),
        vaultDesc: /* @__PURE__ */ __name(() => "Sync your entire vault with a single collection in screen.garden.", "vaultDesc"),
        folderTitle: /* @__PURE__ */ __name(() => "A folder", "folderTitle"),
        folderDesc: /* @__PURE__ */ __name(() => "Sync a folder somewhere in your vault with screen.garden.", "folderDesc"),
        folderPrefix: /* @__PURE__ */ __name(() => "Your collection will be synced to ", "folderPrefix"),
        folderSuggestNewPlaceholder: /* @__PURE__ */ __name(() => "An unsynced folder", "folderSuggestNewPlaceholder"),
        folderSuggestExistingPlaceholder: /* @__PURE__ */ __name(() => "An empty, unsynced folder", "folderSuggestExistingPlaceholder"),
        vaultNotAvailableWarning: /* @__PURE__ */ __name(() => "Your vault must be empty to connect it to an existing collection. Please choose an empty folder or create a new collection.", "vaultNotAvailableWarning"),
        externalProviderInfo: /* @__PURE__ */ __name((d2) => "Heads up! You currently have " + d2.providers + " enabled. screen.garden attempts to prevent double-syncs; this is a failsafe, and for best results please manually ensure folders managed by screen.garden are ignored by other sync systems.", "externalProviderInfo")
      }
    },
    unmountModal: {
      contextMenuItem: /* @__PURE__ */ __name(() => "Disconnect from screen.garden", "contextMenuItem"),
      title: /* @__PURE__ */ __name((d2) => 'Disconnect "' + d2.path + '" from screen.garden?', "title"),
      explanation: /* @__PURE__ */ __name(() => "Removing a folder from screen.garden will stop any changes to notes in that folder from syncing with your team.", "explanation"),
      explanation2: /* @__PURE__ */ __name(() => "No notes will be deleted from Obsidian.", "explanation2"),
      cancel: /* @__PURE__ */ __name(() => "Cancel", "cancel"),
      remove: /* @__PURE__ */ __name(() => "Remove", "remove"),
      successNotice: /* @__PURE__ */ __name((d2) => "Disconnected " + d2.path + " from screen.garden", "successNotice")
    },
    addPasswordModal: {
      title: /* @__PURE__ */ __name((d2) => 'Add password to "' + d2.name + '"', "title"),
      lengthInfo: /* @__PURE__ */ __name(() => "Passwords must be at least 8 characters and less than 72 characters long.", "lengthInfo"),
      lengthValidation: /* @__PURE__ */ __name(() => "Passwords must be between 8 and 72 characters long.", "lengthValidation"),
      errorNotice: /* @__PURE__ */ __name(() => "Could not create password. Please try on the web.", "errorNotice"),
      label: /* @__PURE__ */ __name(() => "Label", "label"),
      labelPlaceholder: /* @__PURE__ */ __name(() => "Who/what is this password for?", "labelPlaceholder"),
      password: /* @__PURE__ */ __name(() => "Password", "password"),
      addPassword: /* @__PURE__ */ __name(() => "Add Password", "addPassword")
    },
    folderSuggest: {
      upDownInstruction: /* @__PURE__ */ __name(() => "to navigate", "upDownInstruction"),
      enterInstruction: /* @__PURE__ */ __name(() => "to choose folder", "enterInstruction"),
      escInstruction: /* @__PURE__ */ __name(() => "to dismiss", "escInstruction")
    },
    suggest: {
      upDownInstruction: /* @__PURE__ */ __name(() => "to navigate", "upDownInstruction"),
      enterInstruction: /* @__PURE__ */ __name(() => "to choose folder", "enterInstruction"),
      escInstruction: /* @__PURE__ */ __name(() => "to dismiss", "escInstruction")
    },
    note: {
      commandError: /* @__PURE__ */ __name(() => "Error getting note data", "commandError"),
      urlCopied: /* @__PURE__ */ __name(() => "URL copied to your clipboard.", "urlCopied"),
      copyCurrentURLCommand: /* @__PURE__ */ __name(() => "Copy note\u2019s team-only web URL", "copyCurrentURLCommand"),
      makeCurrentNotePublicCommand: {
        title: /* @__PURE__ */ __name(() => "Share read-only note publicly", "title"),
        success: /* @__PURE__ */ __name((d2) => '"' + d2.name + '" now public; read-only URL copied.', "success")
      },
      makeCurrentNotePasswordCommand: {
        title: /* @__PURE__ */ __name(() => "Share read-only note with password\u2026", "title"),
        success: /* @__PURE__ */ __name((d2) => '"' + d2.name + '" now viewable with password; read-only URL copied.', "success"),
        add: /* @__PURE__ */ __name((d2) => 'Add a password to "' + d2.name + '"\u2026', "add"),
        noLoadError: /* @__PURE__ */ __name(() => "Could not load passwords.", "noLoadError")
      },
      accessError: /* @__PURE__ */ __name(() => "Error changing access level. Please try on web.", "accessError"),
      renamedRemotely: /* @__PURE__ */ __name((d2) => "Due to a conflict, " + d2.old + " was renamed to " + d2["new"], "renamedRemotely")
    },
    plurals: {
      two: /* @__PURE__ */ __name((d2) => d2.val1 + " and " + d2.val2, "two"),
      serial: /* @__PURE__ */ __name((d2) => d2.joined + ", and " + d2.last, "serial")
    },
    statusBarItem: {
      connected: /* @__PURE__ */ __name(() => "Connected to screen.garden", "connected"),
      connectedWithContention: /* @__PURE__ */ __name(() => "Connected to screen.garden\nPrioritizing active notes", "connectedWithContention"),
      disconnected: /* @__PURE__ */ __name(() => "Working offline; changes will sync when reconnected", "disconnected"),
      needsReauth: /* @__PURE__ */ __name(() => "Please log in to continue using screen.garden", "needsReauth"),
      newVersionAvailable: /* @__PURE__ */ __name(() => "A new version of the screen.garden plugin is available", "newVersionAvailable")
    },
    viewAction: {
      connected: /* @__PURE__ */ __name(() => "Connected to screen.garden\nClick for options", "connected"),
      disconnected: /* @__PURE__ */ __name(() => "Working offline\nChanges will sync when reconnected\nClick for options", "disconnected"),
      menu: {
        collection: /* @__PURE__ */ __name((d2) => "Collection: " + d2.collection, "collection"),
        team: /* @__PURE__ */ __name((d2) => "Team: " + d2.team, "team"),
        web: /* @__PURE__ */ __name(() => "Open on web", "web"),
        collaboratorCount: /* @__PURE__ */ __name((d2) => d2.count + " " + plural(d2.count, 0, en, { one: "active collaborator", other: "active collaborators" }), "collaboratorCount"),
        collaboratorLabel: /* @__PURE__ */ __name(() => "Jump to collaborator\u2026", "collaboratorLabel"),
        copyURL: /* @__PURE__ */ __name(() => "Copy web URL", "copyURL")
      }
    },
    fileExplorer: {
      withTeam: /* @__PURE__ */ __name((d2) => "Synced with " + d2.collection + "\n" + plural(d2.pending, 0, en, { "0": "", other: number("en", d2.pending, 0) + " pending\n" }) + d2.team + "\u2019s screen.garden", "withTeam"),
      withoutTeam: /* @__PURE__ */ __name((d2) => "Synced with " + d2.collection + "\n" + plural(d2.pending, 0, en, { "0": "", other: number("en", d2.pending, 0) + " pending\n" }) + "screen.garden", "withoutTeam")
    },
    socket: {
      connectCommand: /* @__PURE__ */ __name(() => "Go online", "connectCommand"),
      disconnectCommand: /* @__PURE__ */ __name(() => "Go offline", "disconnectCommand"),
      clientUpdateRequired: /* @__PURE__ */ __name(() => "Your screen.garden plugin must be updated to continue syncing with your team. Please update in Obsidian settings.", "clientUpdateRequired")
    },
    sync: {
      fileSizeNotice: /* @__PURE__ */ __name((d2) => d2.path + " is more than 200 MB and will not sync to screen.garden", "fileSizeNotice")
    }
  }
};

// src/intl.ts
var intl = messages_default.en;

// src/services/settings/SettingsTab.ts
var log = (0, import_debug2.default)("screen.garden:settings:tab");
var _SettingsTab = class _SettingsTab extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.loginDetails = null;
    this.recentlyLoggedOut = false;
    this.rootCollection = null;
    log("initializing");
    this.subscription = combineLatest([
      this.plugin.account.observable,
      from(this.plugin.settings.observable).pipe(
        map((settings) => {
          var _a9;
          return (_a9 = settings == null ? void 0 : settings.needsReauth) != null ? _a9 : false;
        }),
        distinctUntilChanged()
      ),
      from(this.plugin.collections.collectionsSettingsObservable).pipe(
        map((cs) => {
          var _a9;
          return (_a9 = cs.find((c) => c.mount_path === "/")) != null ? _a9 : null;
        })
      )
    ]).subscribe(([_account, needsReauth, rootCollection]) => {
      this.rootCollection = rootCollection;
      this.display(needsReauth);
    });
    this.plugin.register(this.subscription.unsubscribe);
  }
  display(needsReauth = null) {
    var _a9;
    const config2 = this.plugin.settings.config;
    const account = this.plugin.account.get();
    const teams = this.plugin.teams.get();
    const team = teams ? (_a9 = [...teams].sort((a, b) => b.seat_count - a.seat_count).first()) != null ? _a9 : null : null;
    log("rendering");
    const { containerEl: container } = this;
    container.empty();
    new import_obsidian3.Setting(container).setName(intl.settingsTab.homeSettingName()).setDesc(intl.settingsTab.homeSettingDesc()).addButton(
      (button) => button.setButtonText(intl.settingsTab.showHomeTab()).onClick(() => {
        this.plugin.views.revealView("screengarden:views:home" /* Home */);
      })
    );
    const showReauth = needsReauth != null ? needsReauth : (config2 == null ? void 0 : config2.needsReauth) == true;
    if (showReauth) {
      this.addReauthState(container);
    } else if ((config2 == null ? void 0 : config2.token) == null) {
      this.addLoggedOutState(container);
    } else {
      this.addLoggedInState(container, { account, team });
    }
    new import_obsidian3.Setting(container).setName(intl.settingsTab.debug.header()).setHeading();
    new import_obsidian3.Setting(container).setName(intl.settingsTab.debug.reset.name()).setDesc(intl.settingsTab.debug.reset.desc()).addButton(
      (button) => button.setButtonText(intl.settingsTab.debug.reset.buttonText()).setWarning().onClick(async () => {
        await this.plugin.account.logout();
        await this.plugin.db.reset();
        new import_obsidian3.Notice(intl.settingsTab.debug.reset.notice());
        this.display();
      })
    );
  }
  addReauthState(container) {
    new import_obsidian3.Setting(container).setName(intl.settingsTab.accountSettingName()).setDesc(intl.settingsTab.reauth.headerDesc());
    new import_obsidian3.Setting(container).addButton(
      (button) => button.setButtonText(intl.settingsTab.reauth.button()).setCta().onClick(() => {
        this.plugin.account.startAuth(
          "login",
          this.showLoginDetails.bind(this)
        );
      })
    );
    this.loginDetails = container.createEl("p");
    this.loginDetails.classList.add("text-center");
    this.loginDetails.hidden = true;
  }
  addLoggedOutState(container) {
    new import_obsidian3.Setting(container).setName(intl.settingsTab.accountSettingName()).setDesc(intl.settingsTab.accountSettingsDesc());
    const buttonsSetting = new import_obsidian3.Setting(container);
    if (this.recentlyLoggedOut) {
      buttonsSetting.setDesc(intl.settingsTab.recentlyLoggedOutWarning());
    }
    buttonsSetting.addButton(
      (button) => button.setButtonText(intl.settingsTab.loginButton()).onClick(() => {
        this.plugin.account.startAuth(
          "login",
          this.showLoginDetails.bind(this)
        );
      })
    ).addButton(
      (button) => button.setButtonText(intl.settingsTab.createAccountButton()).setCta().onClick(() => {
        this.plugin.account.startAuth(
          "register",
          this.showLoginDetails.bind(this)
        );
      })
    );
    this.loginDetails = container.createEl("p");
    this.loginDetails.classList.add("text-center");
    this.loginDetails.hidden = true;
  }
  showLoginDetails(url) {
    if (!this.loginDetails) return;
    this.loginDetails.hidden = false;
    this.loginDetails.innerHTML = intl.settingsTab.loginDetailsRaw({ url });
  }
  addLoggedInState(container, {
    account,
    team
  }) {
    new import_obsidian3.Setting(container).setName(intl.settingsTab.accountSettingName()).setDesc(intl.settingsTab.loggedIn({ email: account == null ? void 0 : account.email }));
    new import_obsidian3.Setting(container).addButton(
      (button) => button.setButtonText(intl.settingsTab.logOutButton()).onClick(async () => {
        await this.plugin.account.logout();
        this.recentlyLoggedOut = true;
        this.display();
      })
    ).addButton(
      (button) => button.setButtonText(intl.settingsTab.manageAccountButton()).setCta().onClick(() => {
        window.open(
          `${BASE_HTTP_URL}/t/${team == null ? void 0 : team.short_id}/settings/account`,
          "_external"
        );
      })
    );
    if (this.rootCollection) {
      const header = new import_obsidian3.Setting(container).setName(intl.settingsTab.fullVault.header()).setHeading();
      header.descEl.createEl("p", {}, (el) => {
        el.innerHTML = `${intl.settingsTab.fullVault.desc1()}<a href="https://screen.garden/faq#full-vault-sync">${intl.settingsTab.fullVault.desc2()}</a>${intl.settingsTab.fullVault.desc3()}`;
      });
      new import_obsidian3.Setting(container).setName(intl.settingsTab.fullVault.unmountName()).setDesc(intl.settingsTab.fullVault.unmountDesc()).addButton((button) => {
        button.setButtonText(intl.settingsTab.fullVault.button()).setWarning().onClick(() => {
          if (!this.rootCollection) return;
          this.plugin.collections.unmount(
            this.rootCollection.collection_id
          );
        });
      });
    }
    new import_obsidian3.Setting(container).setName(intl.settingsTab.ui.header()).setHeading();
    new import_obsidian3.Setting(container).setName(intl.settingsTab.ui.folderBorders.name()).setDesc(intl.settingsTab.ui.folderBorders.desc()).addToggle((cb) => {
      var _a9, _b2;
      cb.setValue((_b2 = (_a9 = this.plugin.settings.config) == null ? void 0 : _a9.showFolderLines) != null ? _b2 : false);
      cb.onChange((value) => {
        this.plugin.settings.updateConfig({ showFolderLines: value });
      });
    });
    new import_obsidian3.Setting(container).setName(intl.settingsTab.ui.folderIcons.name()).setDesc(intl.settingsTab.ui.folderIcons.desc()).addToggle((cb) => {
      var _a9, _b2;
      cb.setValue((_b2 = (_a9 = this.plugin.settings.config) == null ? void 0 : _a9.showFolderIcons) != null ? _b2 : false);
      cb.onChange((value) => {
        this.plugin.settings.updateConfig({ showFolderIcons: value });
      });
    });
    new import_obsidian3.Setting(container).setName(intl.settingsTab.ui.statusIcon.name()).setDesc(intl.settingsTab.ui.statusIcon.desc()).addToggle((cb) => {
      var _a9, _b2;
      cb.setValue((_b2 = (_a9 = this.plugin.settings.config) == null ? void 0 : _a9.showStatusIcon) != null ? _b2 : false);
      cb.onChange((value) => {
        this.plugin.settings.updateConfig({ showStatusIcon: value });
      });
    });
  }
};
__name(_SettingsTab, "SettingsTab");
var SettingsTab = _SettingsTab;

// node_modules/axios/index.js
init_process_shim();

// node_modules/axios/lib/axios.js
init_process_shim();

// node_modules/axios/lib/utils.js
init_process_shim();

// node_modules/axios/lib/helpers/bind.js
init_process_shim();
function bind2(fn, thisArg) {
  return /* @__PURE__ */ __name(function wrap() {
    return fn.apply(thisArg, arguments);
  }, "wrap");
}
__name(bind2, "bind");

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf: getPrototypeOf2 } = Object;
var { iterator: iterator2, toStringTag } = Symbol;
var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = /* @__PURE__ */ __name((type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
}, "kindOfTest");
var typeOfTest = /* @__PURE__ */ __name((type) => (thing) => typeof thing === type, "typeOfTest");
var { isArray: isArray3 } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction2(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
__name(isBuffer, "isBuffer");
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
__name(isArrayBufferView, "isArrayBufferView");
var isString = typeOfTest("string");
var isFunction2 = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = /* @__PURE__ */ __name((thing) => thing !== null && typeof thing === "object", "isObject");
var isBoolean = /* @__PURE__ */ __name((thing) => thing === true || thing === false, "isBoolean");
var isPlainObject = /* @__PURE__ */ __name((val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf2(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(toStringTag in val) && !(iterator2 in val);
}, "isPlainObject");
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = /* @__PURE__ */ __name((val) => isObject(val) && isFunction2(val.pipe), "isStream");
var isFormData = /* @__PURE__ */ __name((thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction2(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction2(thing.toString) && thing.toString() === "[object FormData]"));
}, "isFormData");
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim = /* @__PURE__ */ __name((str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), "trim");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray3(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys3 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys3.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys3[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
__name(forEach, "forEach");
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys3 = Object.keys(obj);
  let i = keys3.length;
  let _key;
  while (i-- > 0) {
    _key = keys3[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
__name(findKey, "findKey");
var _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = /* @__PURE__ */ __name((context2) => !isUndefined(context2) && context2 !== _global, "isContextDefined");
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = /* @__PURE__ */ __name((val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray3(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  }, "assignValue");
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
__name(merge, "merge");
var extend = /* @__PURE__ */ __name((a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction2(val)) {
      a[key] = bind2(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
}, "extend");
var stripBOM = /* @__PURE__ */ __name((content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}, "stripBOM");
var inherits = /* @__PURE__ */ __name((constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
}, "inherits");
var toFlatObject = /* @__PURE__ */ __name((sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf2(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
}, "toFlatObject");
var endsWith = /* @__PURE__ */ __name((str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}, "endsWith");
var toArray = /* @__PURE__ */ __name((thing) => {
  if (!thing) return null;
  if (isArray3(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}, "toArray");
var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf2(Uint8Array));
var forEachEntry = /* @__PURE__ */ __name((obj, fn) => {
  const generator = obj && obj[iterator2];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
}, "forEachEntry");
var matchAll = /* @__PURE__ */ __name((regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
}, "matchAll");
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = /* @__PURE__ */ __name((str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    /* @__PURE__ */ __name(function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }, "replacer")
  );
}, "toCamelCase");
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty12 }) => (obj, prop) => hasOwnProperty12.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = /* @__PURE__ */ __name((obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
}, "reduceDescriptors");
var freezeMethods = /* @__PURE__ */ __name((obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction2(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction2(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
}, "freezeMethods");
var toObjectSet = /* @__PURE__ */ __name((arrayOrString, delimiter) => {
  const obj = {};
  const define2 = /* @__PURE__ */ __name((arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  }, "define");
  isArray3(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
}, "toObjectSet");
var noop2 = /* @__PURE__ */ __name(() => {
}, "noop");
var toFiniteNumber = /* @__PURE__ */ __name((value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
}, "toFiniteNumber");
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction2(thing.append) && thing[toStringTag] === "FormData" && thing[iterator2]);
}
__name(isSpecCompliantForm, "isSpecCompliantForm");
var toJSONObject = /* @__PURE__ */ __name((obj) => {
  const stack = new Array(10);
  const visit = /* @__PURE__ */ __name((source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray3(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  }, "visit");
  return visit(obj, 0);
}, "toJSONObject");
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = /* @__PURE__ */ __name((thing) => thing && (isObject(thing) || isFunction2(thing)) && isFunction2(thing.then) && isFunction2(thing.catch), "isThenable");
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction2(_global.postMessage)
);
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof import_browser.default !== "undefined" && import_browser.default.nextTick || _setImmediate;
var isIterable2 = /* @__PURE__ */ __name((thing) => thing != null && isFunction2(thing[iterator2]), "isIterable");
var utils_default = {
  isArray: isArray3,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction2,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop2,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable: isIterable2
};

// node_modules/axios/lib/core/Axios.js
init_process_shim();

// node_modules/axios/lib/helpers/buildURL.js
init_process_shim();

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
init_process_shim();

// node_modules/axios/lib/helpers/toFormData.js
init_process_shim();

// node_modules/axios/lib/core/AxiosError.js
init_process_shim();
function AxiosError(message, code, config2, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config2 && (this.config = config2);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
__name(AxiosError, "AxiosError");
utils_default.inherits(AxiosError, Error, {
  toJSON: /* @__PURE__ */ __name(function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }, "toJSON")
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config2, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, /* @__PURE__ */ __name(function filter2(obj) {
    return obj !== Error.prototype;
  }, "filter"), (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config2, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
init_process_shim();
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
__name(isVisitable, "isVisitable");
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
__name(removeBrackets, "removeBrackets");
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(/* @__PURE__ */ __name(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }, "each")).join(dots ? "." : "");
}
__name(renderKey, "renderKey");
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
__name(isFlatArray, "isFlatArray");
var predicates = utils_default.toFlatObject(utils_default, {}, null, /* @__PURE__ */ __name(function filter(prop) {
  return /^is[A-Z]/.test(prop);
}, "filter"));
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, /* @__PURE__ */ __name(function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  }, "defined"));
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  __name(convertValue, "convertValue");
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(/* @__PURE__ */ __name(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        }, "each"));
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  __name(defaultVisitor, "defaultVisitor");
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, /* @__PURE__ */ __name(function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    }, "each"));
    stack.pop();
  }
  __name(build, "build");
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
__name(toFormData, "toFormData");
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, /* @__PURE__ */ __name(function replacer(match) {
    return charMap[match];
  }, "replacer"));
}
__name(encode, "encode");
function AxiosURLSearchParams(params2, options) {
  this._pairs = [];
  params2 && toFormData_default(params2, this, options);
}
__name(AxiosURLSearchParams, "AxiosURLSearchParams");
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = /* @__PURE__ */ __name(function append(name, value) {
  this._pairs.push([name, value]);
}, "append");
prototype2.toString = /* @__PURE__ */ __name(function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(/* @__PURE__ */ __name(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "each"), "").join("&");
}, "toString");
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
__name(encode2, "encode");
function buildURL(url, params2, options) {
  if (!params2) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params2, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params2) ? params2.toString() : new AxiosURLSearchParams_default(params2, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
__name(buildURL, "buildURL");

// node_modules/axios/lib/core/InterceptorManager.js
init_process_shim();
var _InterceptorManager = class _InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, /* @__PURE__ */ __name(function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    }, "forEachHandler"));
  }
};
__name(_InterceptorManager, "InterceptorManager");
var InterceptorManager = _InterceptorManager;
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/core/dispatchRequest.js
init_process_shim();

// node_modules/axios/lib/core/transformData.js
init_process_shim();

// node_modules/axios/lib/defaults/index.js
init_process_shim();

// node_modules/axios/lib/defaults/transitional.js
init_process_shim();
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
init_process_shim();

// node_modules/axios/lib/platform/index.js
init_process_shim();

// node_modules/axios/lib/platform/browser/index.js
init_process_shim();

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
init_process_shim();
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
init_process_shim();
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
init_process_shim();
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  navigator: () => _navigator,
  origin: () => origin
});
init_process_shim();
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || void 0;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...browser_default
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
    visitor: /* @__PURE__ */ __name(function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }, "visitor")
  }, options));
}
__name(toURLEncodedForm, "toURLEncodedForm");

// node_modules/axios/lib/helpers/formDataToJSON.js
init_process_shim();
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
__name(parsePropPath, "parsePropPath");
function arrayToObject(arr) {
  const obj = {};
  const keys3 = Object.keys(arr);
  let i;
  const len = keys3.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys3[i];
    obj[key] = arr[key];
  }
  return obj;
}
__name(arrayToObject, "arrayToObject");
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  __name(buildPath, "buildPath");
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
__name(formDataToJSON, "formDataToJSON");
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
__name(stringifySafely, "stringifySafely");
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [/* @__PURE__ */ __name(function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }, "transformRequest")],
  transformResponse: [/* @__PURE__ */ __name(function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }, "transformResponse")],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: /* @__PURE__ */ __name(function validateStatus(status) {
    return status >= 200 && status < 300;
  }, "validateStatus"),
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/core/AxiosHeaders.js
init_process_shim();

// node_modules/axios/lib/helpers/parseHeaders.js
init_process_shim();
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = /* @__PURE__ */ __name((rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(/* @__PURE__ */ __name(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  }, "parser"));
  return parsed;
}, "default");

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
__name(normalizeHeader, "normalizeHeader");
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
__name(normalizeValue, "normalizeValue");
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
__name(parseTokens, "parseTokens");
var isValidHeaderName = /* @__PURE__ */ __name((str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim()), "isValidHeaderName");
function matchHeaderValue(context2, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value)) return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
__name(matchHeaderValue, "matchHeaderValue");
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
__name(formatHeader, "formatHeader");
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: /* @__PURE__ */ __name(function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      }, "value"),
      configurable: true
    });
  });
}
__name(buildAccessors, "buildAccessors");
var _AxiosHeaders = class _AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    __name(setHeader, "setHeader");
    const setHeaders = /* @__PURE__ */ __name((headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite)), "setHeaders");
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils_default.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils_default.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    __name(deleteHeader, "deleteHeader");
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys3 = Object.keys(this);
    let i = keys3.length;
    let deleted = false;
    while (i--) {
      const key = keys3[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    __name(defineAccessor, "defineAccessor");
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
__name(_AxiosHeaders, "AxiosHeaders");
var AxiosHeaders = _AxiosHeaders;
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: /* @__PURE__ */ __name(() => value, "get"),
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config2 = this || defaults_default;
  const context2 = response || config2;
  const headers = AxiosHeaders_default.from(context2.headers);
  let data = context2.data;
  utils_default.forEach(fns, /* @__PURE__ */ __name(function transform(fn) {
    data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
  }, "transform"));
  headers.normalize();
  return data;
}
__name(transformData, "transformData");

// node_modules/axios/lib/cancel/isCancel.js
init_process_shim();
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
__name(isCancel, "isCancel");

// node_modules/axios/lib/cancel/CanceledError.js
init_process_shim();
function CanceledError(message, config2, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config2, request);
  this.name = "CanceledError";
}
__name(CanceledError, "CanceledError");
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/adapters/adapters.js
init_process_shim();

// node_modules/axios/lib/adapters/xhr.js
init_process_shim();

// node_modules/axios/lib/core/settle.js
init_process_shim();
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
__name(settle, "settle");

// node_modules/axios/lib/helpers/parseProtocol.js
init_process_shim();
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
__name(parseProtocol, "parseProtocol");

// node_modules/axios/lib/helpers/progressEventReducer.js
init_process_shim();

// node_modules/axios/lib/helpers/speedometer.js
init_process_shim();
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return /* @__PURE__ */ __name(function push(chunkLength) {
    const now2 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now2;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now2;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now2 - firstSampleTS < min2) {
      return;
    }
    const passed = startedAt && now2 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  }, "push");
}
__name(speedometer, "speedometer");
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/throttle.js
init_process_shim();
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer2;
  const invoke = /* @__PURE__ */ __name((args2, now2 = Date.now()) => {
    timestamp = now2;
    lastArgs = null;
    if (timer2) {
      clearTimeout(timer2);
      timer2 = null;
    }
    fn.apply(null, args2);
  }, "invoke");
  const throttled = /* @__PURE__ */ __name((...args2) => {
    const now2 = Date.now();
    const passed = now2 - timestamp;
    if (passed >= threshold) {
      invoke(args2, now2);
    } else {
      lastArgs = args2;
      if (!timer2) {
        timer2 = setTimeout(() => {
          timer2 = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  }, "throttled");
  const flush = /* @__PURE__ */ __name(() => lastArgs && invoke(lastArgs), "flush");
  return [throttled, flush];
}
__name(throttle, "throttle");
var throttle_default = throttle;

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = /* @__PURE__ */ __name((listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
}, "progressEventReducer");
var progressEventDecorator = /* @__PURE__ */ __name((total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
}, "progressEventDecorator");
var asyncDecorator = /* @__PURE__ */ __name((fn) => (...args2) => utils_default.asap(() => fn(...args2)), "asyncDecorator");

// node_modules/axios/lib/helpers/resolveConfig.js
init_process_shim();

// node_modules/axios/lib/helpers/isURLSameOrigin.js
init_process_shim();
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform_default.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform_default.origin),
  platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
) : () => true;

// node_modules/axios/lib/helpers/cookies.js
init_process_shim();
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path) && cookie.push("path=" + path);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/axios/lib/core/buildFullPath.js
init_process_shim();

// node_modules/axios/lib/helpers/isAbsoluteURL.js
init_process_shim();
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
__name(isAbsoluteURL, "isAbsoluteURL");

// node_modules/axios/lib/helpers/combineURLs.js
init_process_shim();
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
__name(combineURLs, "combineURLs");

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
__name(buildFullPath, "buildFullPath");

// node_modules/axios/lib/core/mergeConfig.js
init_process_shim();
var headersToObject = /* @__PURE__ */ __name((thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing, "headersToObject");
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  __name(getMergedValue, "getMergedValue");
  function mergeDeepProperties(a, b, prop, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, prop, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, prop, caseless);
    }
  }
  __name(mergeDeepProperties, "mergeDeepProperties");
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  __name(valueFromConfig2, "valueFromConfig2");
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  __name(defaultToConfig2, "defaultToConfig2");
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  __name(mergeDirectKeys, "mergeDirectKeys");
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: /* @__PURE__ */ __name((a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true), "headers")
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), /* @__PURE__ */ __name(function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  }, "computeConfigValue"));
  return config3;
}
__name(mergeConfig, "mergeConfig");

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = /* @__PURE__ */ __name((config2) => {
  const newConfig = mergeConfig({}, config2);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config2.params, config2.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
}, "default");

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config2) {
  return new Promise(/* @__PURE__ */ __name(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config2);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    __name(done, "done");
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config2,
        request
      };
      settle(/* @__PURE__ */ __name(function _resolve(value) {
        resolve(value);
        done();
      }, "_resolve"), /* @__PURE__ */ __name(function _reject(err2) {
        reject(err2);
        done();
      }, "_reject"), response);
      request = null;
    }
    __name(onloadend, "onloadend");
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = /* @__PURE__ */ __name(function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      }, "handleLoad");
    }
    request.onabort = /* @__PURE__ */ __name(function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config2, request));
      request = null;
    }, "handleAbort");
    request.onerror = /* @__PURE__ */ __name(function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config2, request));
      request = null;
    }, "handleError");
    request.ontimeout = /* @__PURE__ */ __name(function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config2,
        request
      ));
      request = null;
    }, "handleTimeout");
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), /* @__PURE__ */ __name(function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      }, "setRequestHeader"));
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = /* @__PURE__ */ __name((cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config2, request) : cancel);
        request.abort();
        request = null;
      }, "onCanceled");
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config2));
      return;
    }
    request.send(requestData || null);
  }, "dispatchXhrRequest"));
};

// node_modules/axios/lib/adapters/fetch.js
init_process_shim();

// node_modules/axios/lib/helpers/composeSignals.js
init_process_shim();
var composeSignals = /* @__PURE__ */ __name((signals, timeout) => {
  const { length: length2 } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length2) {
    let controller = new AbortController();
    let aborted;
    const onabort = /* @__PURE__ */ __name(function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err2 = reason instanceof Error ? reason : this.reason;
        controller.abort(err2 instanceof AxiosError_default ? err2 : new CanceledError_default(err2 instanceof Error ? err2.message : err2));
      }
    }, "onabort");
    let timer2 = timeout && setTimeout(() => {
      timer2 = null;
      onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = /* @__PURE__ */ __name(() => {
      if (signals) {
        timer2 && clearTimeout(timer2);
        timer2 = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    }, "unsubscribe");
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
}, "composeSignals");
var composeSignals_default = composeSignals;

// node_modules/axios/lib/helpers/trackStream.js
init_process_shim();
var streamChunk = /* @__PURE__ */ __name(function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
}, "streamChunk");
var readBytes = /* @__PURE__ */ __name(async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
}, "readBytes");
var readStream = /* @__PURE__ */ __name(async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
}, "readStream");
var trackStream = /* @__PURE__ */ __name((stream, chunkSize, onProgress, onFinish) => {
  const iterator3 = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = /* @__PURE__ */ __name((e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  }, "_onFinish");
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator3.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err2) {
        _onFinish(err2);
        throw err2;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator3.return();
    }
  }, {
    highWaterMark: 2
  });
}, "trackStream");

// node_modules/axios/lib/adapters/fetch.js
var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
var test = /* @__PURE__ */ __name((fn, ...args2) => {
  try {
    return !!fn(...args2);
  } catch (e) {
    return false;
  }
}, "test");
var supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform_default.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var supportsResponseStream = isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
var resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils_default.isFunction(res[type]) ? (res2) => res2[type]() : (_, config2) => {
      throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config2);
    });
  });
})(new Response());
var getBodyLength = /* @__PURE__ */ __name(async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils_default.isBlob(body)) {
    return body.size;
  }
  if (utils_default.isSpecCompliantForm(body)) {
    const _request = new Request(platform_default.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils_default.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils_default.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
}, "getBodyLength");
var resolveBodyLength = /* @__PURE__ */ __name(async (headers, body) => {
  const length2 = utils_default.toFiniteNumber(headers.getContentLength());
  return length2 == null ? getBodyLength(body) : length2;
}, "resolveBodyLength");
var fetch_default = isFetchSupported && (async (config2) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig_default(config2);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils_default.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config2);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders_default.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config: config2,
        request
      });
    });
  } catch (err2) {
    unsubscribe && unsubscribe();
    if (err2 && err2.name === "TypeError" && /Load failed|fetch/i.test(err2.message)) {
      throw Object.assign(
        new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config2, request),
        {
          cause: err2.cause || err2
        }
      );
    }
    throw AxiosError_default.from(err2, err2 && err2.code, config2, request);
  }
});

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default,
  fetch: fetch_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = /* @__PURE__ */ __name((reason) => `- ${reason}`, "renderReason");
var isResolvedHandle = /* @__PURE__ */ __name((adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false, "isResolvedHandle");
var adapters_default = {
  getAdapter: /* @__PURE__ */ __name((adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length: length2 } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length2; i++) {
      nameOrAdapter = adapters[i];
      let id2;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id2}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id2 || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  }, "getAdapter"),
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError_default(null, config2);
  }
}
__name(throwIfCancellationRequested, "throwIfCancellationRequested");
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders_default.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config2.adapter || defaults_default.adapter);
  return adapter(config2).then(/* @__PURE__ */ __name(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, "onAdapterResolution"), /* @__PURE__ */ __name(function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  }, "onAdapterRejection"));
}
__name(dispatchRequest, "dispatchRequest");

// node_modules/axios/lib/helpers/validator.js
init_process_shim();

// node_modules/axios/lib/env/data.js
init_process_shim();
var VERSION = "1.9.0";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators[type] = /* @__PURE__ */ __name(function validator(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  }, "validator");
});
var deprecatedWarnings = {};
validators.transitional = /* @__PURE__ */ __name(function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  __name(formatMessage, "formatMessage");
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
}, "transitional");
validators.spelling = /* @__PURE__ */ __name(function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
}, "spelling");
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys3 = Object.keys(options);
  let i = keys3.length;
  while (i-- > 0) {
    const opt = keys3[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
__name(assertOptions, "assertOptions");
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var _Axios = class _Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config2) {
    try {
      return await this._request(configOrUrl, config2);
    } catch (err2) {
      if (err2 instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err2.stack) {
            err2.stack = stack;
          } else if (stack && !String(err2.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err2.stack += "\n" + stack;
          }
        } catch (e) {
        }
      }
      throw err2;
    }
  }
  _request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    if (config2.allowAbsoluteUrls !== void 0) {
    } else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config2.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config2.allowAbsoluteUrls = true;
    }
    validator_default.assertOptions(config2, {
      baseUrl: validators2.spelling("baseURL"),
      withXsrfToken: validators2.spelling("withXSRFToken")
    }, true);
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config2.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(/* @__PURE__ */ __name(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    }, "unshiftRequestInterceptors"));
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(/* @__PURE__ */ __name(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    }, "pushResponseInterceptors"));
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config2);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url, config2.allowAbsoluteUrls);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
};
__name(_Axios, "Axios");
var Axios = _Axios;
utils_default.forEach(["delete", "get", "head", "options"], /* @__PURE__ */ __name(function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config2) {
    return this.request(mergeConfig(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
}, "forEachMethodNoData"));
utils_default.forEach(["post", "put", "patch"], /* @__PURE__ */ __name(function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return /* @__PURE__ */ __name(function httpMethod(url, data, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    }, "httpMethod");
  }
  __name(generateHTTPMethod, "generateHTTPMethod");
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
}, "forEachMethodWithData"));
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
init_process_shim();
var _CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(/* @__PURE__ */ __name(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    }, "promiseExecutor"));
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = /* @__PURE__ */ __name(function reject() {
        token.unsubscribe(_resolve);
      }, "reject");
      return promise;
    };
    executor(/* @__PURE__ */ __name(function cancel(message, config2, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config2, request);
      resolvePromise(token.reason);
    }, "cancel"));
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = /* @__PURE__ */ __name((err2) => {
      controller.abort(err2);
    }, "abort");
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(/* @__PURE__ */ __name(function executor(c) {
      cancel = c;
    }, "executor"));
    return {
      token,
      cancel
    };
  }
};
__name(_CancelToken, "CancelToken");
var CancelToken = _CancelToken;
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
init_process_shim();
function spread(callback) {
  return /* @__PURE__ */ __name(function wrap(arr) {
    return callback.apply(null, arr);
  }, "wrap");
}
__name(spread, "spread");

// node_modules/axios/lib/helpers/isAxiosError.js
init_process_shim();
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}
__name(isAxiosError, "isAxiosError");

// node_modules/axios/lib/helpers/HttpStatusCode.js
init_process_shim();
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context2 = new Axios_default(defaultConfig);
  const instance = bind2(Axios_default.prototype.request, context2);
  utils_default.extend(instance, Axios_default.prototype, context2, { allOwnKeys: true });
  utils_default.extend(instance, context2, null, { allOwnKeys: true });
  instance.create = /* @__PURE__ */ __name(function create7(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  }, "create");
  return instance;
}
__name(createInstance, "createInstance");
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = /* @__PURE__ */ __name(function all(promises) {
  return Promise.all(promises);
}, "all");
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// node_modules/compare-versions/lib/esm/index.js
init_process_shim();

// node_modules/compare-versions/lib/esm/compareVersions.js
init_process_shim();

// node_modules/compare-versions/lib/esm/utils.js
init_process_shim();
var semver = /^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;
var validateAndParse = /* @__PURE__ */ __name((version) => {
  if (typeof version !== "string") {
    throw new TypeError("Invalid argument expected string");
  }
  const match = version.match(semver);
  if (!match) {
    throw new Error(`Invalid argument not valid semver ('${version}' received)`);
  }
  match.shift();
  return match;
}, "validateAndParse");
var isWildcard = /* @__PURE__ */ __name((s) => s === "*" || s === "x" || s === "X", "isWildcard");
var tryParse = /* @__PURE__ */ __name((v) => {
  const n = parseInt(v, 10);
  return isNaN(n) ? v : n;
}, "tryParse");
var forceType = /* @__PURE__ */ __name((a, b) => typeof a !== typeof b ? [String(a), String(b)] : [a, b], "forceType");
var compareStrings = /* @__PURE__ */ __name((a, b) => {
  if (isWildcard(a) || isWildcard(b))
    return 0;
  const [ap, bp] = forceType(tryParse(a), tryParse(b));
  if (ap > bp)
    return 1;
  if (ap < bp)
    return -1;
  return 0;
}, "compareStrings");
var compareSegments = /* @__PURE__ */ __name((a, b) => {
  for (let i = 0; i < Math.max(a.length, b.length); i++) {
    const r = compareStrings(a[i] || "0", b[i] || "0");
    if (r !== 0)
      return r;
  }
  return 0;
}, "compareSegments");

// node_modules/compare-versions/lib/esm/compareVersions.js
var compareVersions = /* @__PURE__ */ __name((v1, v2) => {
  const n1 = validateAndParse(v1);
  const n2 = validateAndParse(v2);
  const p1 = n1.pop();
  const p2 = n2.pop();
  const r = compareSegments(n1, n2);
  if (r !== 0)
    return r;
  if (p1 && p2) {
    return compareSegments(p1.split("."), p2.split("."));
  } else if (p1 || p2) {
    return p1 ? -1 : 1;
  }
  return 0;
}, "compareVersions");

// src/services/settings/SettingsService.ts
var import_debug3 = __toESM(require_browser2());

// node_modules/dexie/import-wrapper.mjs
init_process_shim();
var import_dexie = __toESM(require_dexie(), 1);
var DexieSymbol = Symbol.for("Dexie");
var Dexie = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = import_dexie.default);
if (import_dexie.default.semVer !== Dexie.semVer) {
  throw new Error(`Two different versions of Dexie loaded in the same app: ${import_dexie.default.semVer} and ${Dexie.semVer}`);
}
var {
  liveQuery,
  mergeRanges,
  rangesOverlap,
  RangeSet,
  cmp,
  Entity,
  PropModification,
  replacePrefix,
  add,
  remove
} = Dexie;
var import_wrapper_default = Dexie;

// src/services/settings/SettingsService.ts
var import_obsidian4 = require("obsidian");
var SETTINGS_ID = "settings";
var TABLE = "id,token";
var DEFAULT_SETTINGS = {
  id: SETTINGS_ID,
  token: null,
  needsReauth: false,
  showFolderLines: true,
  showFolderIcons: true,
  showStatusIcon: true
};
var log2 = (0, import_debug3.default)("screen.garden:settings");
var _SettingsService = class _SettingsService extends Service {
  constructor(plugin) {
    super(plugin);
    this.updateAvailableSubject = new BehaviorSubject(null);
    this.config = null;
    this.observable = liveQuery(
      () => this.db.settings.get(SETTINGS_ID)
    );
    this.tokenObservable = from(this.observable).pipe(
      map((settings) => {
        var _a9;
        return (_a9 = settings == null ? void 0 : settings.token) != null ? _a9 : null;
      }),
      distinctUntilChanged()
    );
    this.updateAvailableObservable = this.updateAvailableSubject.asObservable();
    this.subscribe((config2) => {
      if (config2 == null) return;
      log2("config updated: %o", config2);
      this.config = config2;
    });
  }
  async onload() {
    if (!await this.db.settings.get(SETTINGS_ID)) {
      log2("settings missing, saving defaults");
      await this.db.settings.put(DEFAULT_SETTINGS);
    }
    this.plugin.addCommand({
      id: "toggle-debug-logging",
      name: intl.settingsTab.toggleDebugCommand(),
      callback: /* @__PURE__ */ __name(() => {
        const v = localStorage.getItem("debug");
        if (v) {
          localStorage.removeItem("debug");
          new import_obsidian4.Notice(intl.settingsTab.debugToggledNotice({ state: "off" }));
        } else {
          localStorage.setItem("debug", "screen.garden:*");
          new import_obsidian4.Notice(intl.settingsTab.debugToggledNotice({ state: "on" }));
        }
      }, "callback")
    });
    const subscription = timer(0, 60 * 60 * 1e3).pipe(
      switchMap(() => this.checkForUpdate()),
      catchError((error) => {
        log2("Error checking for updates: %o", error);
        return of(null);
      })
    ).subscribe((updateAvailable) => {
      this.updateAvailableSubject.next(updateAvailable);
    });
    this.register(subscription.unsubscribe);
  }
  async onLayoutReady() {
    this.plugin.addSettingTab(new SettingsTab(this.plugin.app, this.plugin));
  }
  subscribe(cb) {
    const subscription = this.observable.subscribe({
      next(settings) {
        if (settings) cb(settings);
      }
    });
    this.register(() => subscription.unsubscribe());
  }
  async updateConfig(update) {
    if (this.config == null)
      throw new Error("Cannot update config before it is loaded");
    const config2 = {
      ...this.config,
      ...update,
      id: SETTINGS_ID
    };
    await this.plugin.db.settings.put(config2);
    return config2;
  }
  async checkForUpdate() {
    log2("Checking for update\u2026");
    try {
      const response = await axios_default.get(
        "https://api.github.com/repos/screendotgarden/screengarden-obsidian/releases/latest"
      );
      if (!response.data || !response.data.tag_name || !response.data.body) {
        log2("Failed to fetch release data: %d", response.status);
        return null;
      }
      const remoteVersion = response.data.tag_name;
      const currentVersion = this.plugin.manifest.version;
      log2(
        "Version check: current=%s, remote=%s",
        currentVersion,
        remoteVersion
      );
      if (compareVersions(remoteVersion, currentVersion) > 0) {
        return response.data.body;
      } else {
        return null;
      }
    } catch (error) {
      log2("Error fetching remote manifest: %o", error);
      return null;
    }
  }
};
__name(_SettingsService, "SettingsService");
var SettingsService = _SettingsService;

// src/services/networkStatus/index.ts
init_process_shim();

// src/services/networkStatus/NetworkStatusService.ts
init_process_shim();
var import_debug4 = __toESM(require_browser2());
var log3 = (0, import_debug4.default)("screen.garden:network");
var _NetworkStatusService = class _NetworkStatusService extends Service {
  constructor(plugin) {
    super(plugin);
    this.online = true;
    this.observable = new Subject();
    log3("registering event listeners");
    this.plugin.registerDomEvent(window, "online", () => {
      log3("online");
      this.online = true;
      this.observable.next("online");
    });
    this.plugin.registerDomEvent(window, "offline", () => {
      log3("offline");
      this.online = false;
      this.observable.next("offline");
    });
  }
  async onload() {
    this.online = navigator.onLine;
    this.observable.next(this.online ? "online" : "offline");
  }
  async onunload() {
    this.observable.complete();
  }
};
__name(_NetworkStatusService, "NetworkStatusService");
var NetworkStatusService = _NetworkStatusService;

// src/services/account/index.ts
init_process_shim();

// src/services/account/AccountService.ts
init_process_shim();
var import_debug5 = __toESM(require_browser2());

// node_modules/lodash-es/lodash.js
init_process_shim();

// node_modules/lodash-es/isSymbol.js
init_process_shim();

// node_modules/lodash-es/_baseGetTag.js
init_process_shim();

// node_modules/lodash-es/_Symbol.js
init_process_shim();

// node_modules/lodash-es/_root.js
init_process_shim();

// node_modules/lodash-es/_freeGlobal.js
init_process_shim();
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// node_modules/lodash-es/_getRawTag.js
init_process_shim();
var objectProto2 = Object.prototype;
var hasOwnProperty2 = objectProto2.hasOwnProperty;
var nativeObjectToString = objectProto2.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
__name(getRawTag, "getRawTag");
var getRawTag_default = getRawTag;

// node_modules/lodash-es/_objectToString.js
init_process_shim();
var objectProto3 = Object.prototype;
var nativeObjectToString2 = objectProto3.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
__name(objectToString, "objectToString");
var objectToString_default = objectToString;

// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
__name(baseGetTag, "baseGetTag");
var baseGetTag_default = baseGetTag;

// node_modules/lodash-es/isObjectLike.js
init_process_shim();
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
__name(isObjectLike, "isObjectLike");
var isObjectLike_default = isObjectLike;

// node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
__name(isSymbol, "isSymbol");
var isSymbol_default = isSymbol;

// node_modules/lodash-es/_baseToString.js
init_process_shim();

// node_modules/lodash-es/_arrayMap.js
init_process_shim();
function arrayMap(array, iteratee) {
  var index = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
  while (++index < length2) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
__name(arrayMap, "arrayMap");
var arrayMap_default = arrayMap;

// node_modules/lodash-es/isArray.js
init_process_shim();
var isArray4 = Array.isArray;
var isArray_default = isArray4;

// node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
__name(baseToString, "baseToString");
var baseToString_default = baseToString;

// node_modules/lodash-es/toNumber.js
init_process_shim();

// node_modules/lodash-es/_baseTrim.js
init_process_shim();

// node_modules/lodash-es/_trimmedEndIndex.js
init_process_shim();
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
__name(trimmedEndIndex, "trimmedEndIndex");
var trimmedEndIndex_default = trimmedEndIndex;

// node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex_default(string) + 1).replace(reTrimStart, "") : string;
}
__name(baseTrim, "baseTrim");
var baseTrim_default = baseTrim;

// node_modules/lodash-es/isObject.js
init_process_shim();
function isObject2(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
__name(isObject2, "isObject");
var isObject_default = isObject2;

// node_modules/lodash-es/toNumber.js
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN;
  }
  if (isObject_default(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject_default(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim_default(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
__name(toNumber, "toNumber");
var toNumber_default = toNumber;

// node_modules/lodash-es/identity.js
init_process_shim();
function identity2(value) {
  return value;
}
__name(identity2, "identity");
var identity_default = identity2;

// node_modules/lodash-es/_WeakMap.js
init_process_shim();

// node_modules/lodash-es/_getNative.js
init_process_shim();

// node_modules/lodash-es/_baseIsNative.js
init_process_shim();

// node_modules/lodash-es/isFunction.js
init_process_shim();
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction3(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
__name(isFunction3, "isFunction");
var isFunction_default = isFunction3;

// node_modules/lodash-es/_isMasked.js
init_process_shim();

// node_modules/lodash-es/_coreJsData.js
init_process_shim();
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
__name(isMasked, "isMasked");
var isMasked_default = isMasked;

// node_modules/lodash-es/_toSource.js
init_process_shim();
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
__name(toSource, "toSource");
var toSource_default = toSource;

// node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto4 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
__name(baseIsNative, "baseIsNative");
var baseIsNative_default = baseIsNative;

// node_modules/lodash-es/_getValue.js
init_process_shim();
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
__name(getValue, "getValue");
var getValue_default = getValue;

// node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
__name(getNative, "getNative");
var getNative_default = getNative;

// node_modules/lodash-es/_WeakMap.js
var WeakMap2 = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap2;

// node_modules/lodash-es/_apply.js
init_process_shim();
function apply(func, thisArg, args2) {
  switch (args2.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args2[0]);
    case 2:
      return func.call(thisArg, args2[0], args2[1]);
    case 3:
      return func.call(thisArg, args2[0], args2[1], args2[2]);
  }
  return func.apply(thisArg, args2);
}
__name(apply, "apply");
var apply_default = apply;

// node_modules/lodash-es/noop.js
init_process_shim();
function noop3() {
}
__name(noop3, "noop");
var noop_default = noop3;

// node_modules/lodash-es/_shortOut.js
init_process_shim();
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
__name(shortOut, "shortOut");
var shortOut_default = shortOut;

// node_modules/lodash-es/_setToString.js
init_process_shim();

// node_modules/lodash-es/_baseSetToString.js
init_process_shim();

// node_modules/lodash-es/constant.js
init_process_shim();
function constant(value) {
  return function() {
    return value;
  };
}
__name(constant, "constant");
var constant_default = constant;

// node_modules/lodash-es/_defineProperty.js
init_process_shim();
var defineProperty = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty_default = defineProperty;

// node_modules/lodash-es/_baseSetToString.js
var baseSetToString = !defineProperty_default ? identity_default : function(func, string) {
  return defineProperty_default(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_default(string),
    "writable": true
  });
};
var baseSetToString_default = baseSetToString;

// node_modules/lodash-es/_setToString.js
var setToString = shortOut_default(baseSetToString_default);
var setToString_default = setToString;

// node_modules/lodash-es/_arrayIncludes.js
init_process_shim();

// node_modules/lodash-es/_baseIndexOf.js
init_process_shim();

// node_modules/lodash-es/_baseFindIndex.js
init_process_shim();
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length2 = array.length, index = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index-- : ++index < length2) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}
__name(baseFindIndex, "baseFindIndex");
var baseFindIndex_default = baseFindIndex;

// node_modules/lodash-es/_baseIsNaN.js
init_process_shim();
function baseIsNaN(value) {
  return value !== value;
}
__name(baseIsNaN, "baseIsNaN");
var baseIsNaN_default = baseIsNaN;

// node_modules/lodash-es/_strictIndexOf.js
init_process_shim();
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1, length2 = array.length;
  while (++index < length2) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}
__name(strictIndexOf, "strictIndexOf");
var strictIndexOf_default = strictIndexOf;

// node_modules/lodash-es/_baseIndexOf.js
function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf_default(array, value, fromIndex) : baseFindIndex_default(array, baseIsNaN_default, fromIndex);
}
__name(baseIndexOf, "baseIndexOf");
var baseIndexOf_default = baseIndexOf;

// node_modules/lodash-es/_arrayIncludes.js
function arrayIncludes(array, value) {
  var length2 = array == null ? 0 : array.length;
  return !!length2 && baseIndexOf_default(array, value, 0) > -1;
}
__name(arrayIncludes, "arrayIncludes");
var arrayIncludes_default = arrayIncludes;

// node_modules/lodash-es/_isIndex.js
init_process_shim();
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length2) {
  var type = typeof value;
  length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
  return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
}
__name(isIndex, "isIndex");
var isIndex_default = isIndex;

// node_modules/lodash-es/_baseAssignValue.js
init_process_shim();
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
__name(baseAssignValue, "baseAssignValue");
var baseAssignValue_default = baseAssignValue;

// node_modules/lodash-es/eq.js
init_process_shim();
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
__name(eq, "eq");
var eq_default = eq;

// node_modules/lodash-es/_baseRest.js
init_process_shim();

// node_modules/lodash-es/_overRest.js
init_process_shim();
var nativeMax = Math.max;
function overRest(func, start, transform) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args2 = arguments, index = -1, length2 = nativeMax(args2.length - start, 0), array = Array(length2);
    while (++index < length2) {
      array[index] = args2[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args2[index];
    }
    otherArgs[start] = transform(array);
    return apply_default(func, this, otherArgs);
  };
}
__name(overRest, "overRest");
var overRest_default = overRest;

// node_modules/lodash-es/_baseRest.js
function baseRest(func, start) {
  return setToString_default(overRest_default(func, start, identity_default), func + "");
}
__name(baseRest, "baseRest");
var baseRest_default = baseRest;

// node_modules/lodash-es/_isIterateeCall.js
init_process_shim();

// node_modules/lodash-es/isArrayLike.js
init_process_shim();

// node_modules/lodash-es/isLength.js
init_process_shim();
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
__name(isLength, "isLength");
var isLength_default = isLength;

// node_modules/lodash-es/isArrayLike.js
function isArrayLike2(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
__name(isArrayLike2, "isArrayLike");
var isArrayLike_default = isArrayLike2;

// node_modules/lodash-es/_isIterateeCall.js
function isIterateeCall(value, index, object) {
  if (!isObject_default(object)) {
    return false;
  }
  var type = typeof index;
  if (type == "number" ? isArrayLike_default(object) && isIndex_default(index, object.length) : type == "string" && index in object) {
    return eq_default(object[index], value);
  }
  return false;
}
__name(isIterateeCall, "isIterateeCall");
var isIterateeCall_default = isIterateeCall;

// node_modules/lodash-es/_isPrototype.js
init_process_shim();
var objectProto5 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto5;
  return value === proto;
}
__name(isPrototype, "isPrototype");
var isPrototype_default = isPrototype;

// node_modules/lodash-es/keys.js
init_process_shim();

// node_modules/lodash-es/_arrayLikeKeys.js
init_process_shim();

// node_modules/lodash-es/_baseTimes.js
init_process_shim();
function baseTimes(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
__name(baseTimes, "baseTimes");
var baseTimes_default = baseTimes;

// node_modules/lodash-es/isArguments.js
init_process_shim();

// node_modules/lodash-es/_baseIsArguments.js
init_process_shim();
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
__name(baseIsArguments, "baseIsArguments");
var baseIsArguments_default = baseIsArguments;

// node_modules/lodash-es/isArguments.js
var objectProto6 = Object.prototype;
var hasOwnProperty4 = objectProto6.hasOwnProperty;
var propertyIsEnumerable = objectProto6.propertyIsEnumerable;
var isArguments = baseIsArguments_default(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// node_modules/lodash-es/isBuffer.js
init_process_shim();

// node_modules/lodash-es/stubFalse.js
init_process_shim();
function stubFalse() {
  return false;
}
__name(stubFalse, "stubFalse");
var stubFalse_default = stubFalse;

// node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
var isBuffer2 = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer2;

// node_modules/lodash-es/isTypedArray.js
init_process_shim();

// node_modules/lodash-es/_baseIsTypedArray.js
init_process_shim();
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
__name(baseIsTypedArray, "baseIsTypedArray");
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/lodash-es/_baseUnary.js
init_process_shim();
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
__name(baseUnary, "baseUnary");
var baseUnary_default = baseUnary;

// node_modules/lodash-es/_nodeUtil.js
init_process_shim();
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil_default = nodeUtil;

// node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray2 = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray2;

// node_modules/lodash-es/_arrayLikeKeys.js
var objectProto7 = Object.prototype;
var hasOwnProperty5 = objectProto7.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length2 = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty5.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length2)))) {
      result.push(key);
    }
  }
  return result;
}
__name(arrayLikeKeys, "arrayLikeKeys");
var arrayLikeKeys_default = arrayLikeKeys;

// node_modules/lodash-es/_baseKeys.js
init_process_shim();

// node_modules/lodash-es/_nativeKeys.js
init_process_shim();

// node_modules/lodash-es/_overArg.js
init_process_shim();
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
__name(overArg, "overArg");
var overArg_default = overArg;

// node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/lodash-es/_baseKeys.js
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty6.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
__name(baseKeys, "baseKeys");
var baseKeys_default = baseKeys;

// node_modules/lodash-es/keys.js
function keys(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
__name(keys, "keys");
var keys_default = keys;

// node_modules/lodash-es/get.js
init_process_shim();

// node_modules/lodash-es/_baseGet.js
init_process_shim();

// node_modules/lodash-es/_castPath.js
init_process_shim();

// node_modules/lodash-es/_isKey.js
init_process_shim();
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
__name(isKey, "isKey");
var isKey_default = isKey;

// node_modules/lodash-es/_stringToPath.js
init_process_shim();

// node_modules/lodash-es/_memoizeCapped.js
init_process_shim();

// node_modules/lodash-es/memoize.js
init_process_shim();

// node_modules/lodash-es/_MapCache.js
init_process_shim();

// node_modules/lodash-es/_mapCacheClear.js
init_process_shim();

// node_modules/lodash-es/_Hash.js
init_process_shim();

// node_modules/lodash-es/_hashClear.js
init_process_shim();

// node_modules/lodash-es/_nativeCreate.js
init_process_shim();
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
__name(hashClear, "hashClear");
var hashClear_default = hashClear;

// node_modules/lodash-es/_hashDelete.js
init_process_shim();
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
__name(hashDelete, "hashDelete");
var hashDelete_default = hashDelete;

// node_modules/lodash-es/_hashGet.js
init_process_shim();
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto9 = Object.prototype;
var hasOwnProperty7 = objectProto9.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty7.call(data, key) ? data[key] : void 0;
}
__name(hashGet, "hashGet");
var hashGet_default = hashGet;

// node_modules/lodash-es/_hashHas.js
init_process_shim();
var objectProto10 = Object.prototype;
var hasOwnProperty8 = objectProto10.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty8.call(data, key);
}
__name(hashHas, "hashHas");
var hashHas_default = hashHas;

// node_modules/lodash-es/_hashSet.js
init_process_shim();
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
__name(hashSet, "hashSet");
var hashSet_default = hashSet;

// node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length2) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
__name(Hash, "Hash");
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// node_modules/lodash-es/_ListCache.js
init_process_shim();

// node_modules/lodash-es/_listCacheClear.js
init_process_shim();
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
__name(listCacheClear, "listCacheClear");
var listCacheClear_default = listCacheClear;

// node_modules/lodash-es/_listCacheDelete.js
init_process_shim();

// node_modules/lodash-es/_assocIndexOf.js
init_process_shim();
function assocIndexOf(array, key) {
  var length2 = array.length;
  while (length2--) {
    if (eq_default(array[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
__name(assocIndexOf, "assocIndexOf");
var assocIndexOf_default = assocIndexOf;

// node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
__name(listCacheDelete, "listCacheDelete");
var listCacheDelete_default = listCacheDelete;

// node_modules/lodash-es/_listCacheGet.js
init_process_shim();
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  return index < 0 ? void 0 : data[index][1];
}
__name(listCacheGet, "listCacheGet");
var listCacheGet_default = listCacheGet;

// node_modules/lodash-es/_listCacheHas.js
init_process_shim();
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
__name(listCacheHas, "listCacheHas");
var listCacheHas_default = listCacheHas;

// node_modules/lodash-es/_listCacheSet.js
init_process_shim();
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
__name(listCacheSet, "listCacheSet");
var listCacheSet_default = listCacheSet;

// node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length2) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
__name(ListCache, "ListCache");
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// node_modules/lodash-es/_Map.js
init_process_shim();
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
__name(mapCacheClear, "mapCacheClear");
var mapCacheClear_default = mapCacheClear;

// node_modules/lodash-es/_mapCacheDelete.js
init_process_shim();

// node_modules/lodash-es/_getMapData.js
init_process_shim();

// node_modules/lodash-es/_isKeyable.js
init_process_shim();
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
__name(isKeyable, "isKeyable");
var isKeyable_default = isKeyable;

// node_modules/lodash-es/_getMapData.js
function getMapData(map3, key) {
  var data = map3.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
__name(getMapData, "getMapData");
var getMapData_default = getMapData;

// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
__name(mapCacheDelete, "mapCacheDelete");
var mapCacheDelete_default = mapCacheDelete;

// node_modules/lodash-es/_mapCacheGet.js
init_process_shim();
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
__name(mapCacheGet, "mapCacheGet");
var mapCacheGet_default = mapCacheGet;

// node_modules/lodash-es/_mapCacheHas.js
init_process_shim();
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
__name(mapCacheHas, "mapCacheHas");
var mapCacheHas_default = mapCacheHas;

// node_modules/lodash-es/_mapCacheSet.js
init_process_shim();
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
__name(mapCacheSet, "mapCacheSet");
var mapCacheSet_default = mapCacheSet;

// node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length2) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
__name(MapCache, "MapCache");
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = /* @__PURE__ */ __name(function() {
    var args2 = arguments, key = resolver ? resolver.apply(this, args2) : args2[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args2);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  }, "memoized");
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
__name(memoize, "memoize");
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_default(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
__name(memoizeCapped, "memoizeCapped");
var memoizeCapped_default = memoizeCapped;

// node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number2, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
  });
  return result;
});
var stringToPath_default = stringToPath;

// node_modules/lodash-es/toString.js
init_process_shim();
function toString3(value) {
  return value == null ? "" : baseToString_default(value);
}
__name(toString3, "toString");
var toString_default = toString3;

// node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
__name(castPath, "castPath");
var castPath_default = castPath;

// node_modules/lodash-es/_toKey.js
init_process_shim();
var INFINITY2 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
}
__name(toKey, "toKey");
var toKey_default = toKey;

// node_modules/lodash-es/_baseGet.js
function baseGet(object, path) {
  path = castPath_default(path, object);
  var index = 0, length2 = path.length;
  while (object != null && index < length2) {
    object = object[toKey_default(path[index++])];
  }
  return index && index == length2 ? object : void 0;
}
__name(baseGet, "baseGet");
var baseGet_default = baseGet;

// node_modules/lodash-es/get.js
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet_default(object, path);
  return result === void 0 ? defaultValue : result;
}
__name(get, "get");
var get_default = get;

// node_modules/lodash-es/_baseFlatten.js
init_process_shim();

// node_modules/lodash-es/_arrayPush.js
init_process_shim();
function arrayPush(array, values) {
  var index = -1, length2 = values.length, offset = array.length;
  while (++index < length2) {
    array[offset + index] = values[index];
  }
  return array;
}
__name(arrayPush, "arrayPush");
var arrayPush_default = arrayPush;

// node_modules/lodash-es/_isFlattenable.js
init_process_shim();
var spreadableSymbol = Symbol_default ? Symbol_default.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray_default(value) || isArguments_default(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
__name(isFlattenable, "isFlattenable");
var isFlattenable_default = isFlattenable;

// node_modules/lodash-es/_baseFlatten.js
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1, length2 = array.length;
  predicate || (predicate = isFlattenable_default);
  result || (result = []);
  while (++index < length2) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush_default(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
__name(baseFlatten, "baseFlatten");
var baseFlatten_default = baseFlatten;

// node_modules/lodash-es/_Stack.js
init_process_shim();

// node_modules/lodash-es/_stackClear.js
init_process_shim();
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
__name(stackClear, "stackClear");
var stackClear_default = stackClear;

// node_modules/lodash-es/_stackDelete.js
init_process_shim();
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
__name(stackDelete, "stackDelete");
var stackDelete_default = stackDelete;

// node_modules/lodash-es/_stackGet.js
init_process_shim();
function stackGet(key) {
  return this.__data__.get(key);
}
__name(stackGet, "stackGet");
var stackGet_default = stackGet;

// node_modules/lodash-es/_stackHas.js
init_process_shim();
function stackHas(key) {
  return this.__data__.has(key);
}
__name(stackHas, "stackHas");
var stackHas_default = stackHas;

// node_modules/lodash-es/_stackSet.js
init_process_shim();
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs = data.__data__;
    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
__name(stackSet, "stackSet");
var stackSet_default = stackSet;

// node_modules/lodash-es/_Stack.js
function Stack(entries) {
  var data = this.__data__ = new ListCache_default(entries);
  this.size = data.size;
}
__name(Stack, "Stack");
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// node_modules/lodash-es/_getSymbols.js
init_process_shim();

// node_modules/lodash-es/_arrayFilter.js
init_process_shim();
function arrayFilter(array, predicate) {
  var index = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length2) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
__name(arrayFilter, "arrayFilter");
var arrayFilter_default = arrayFilter;

// node_modules/lodash-es/stubArray.js
init_process_shim();
function stubArray() {
  return [];
}
__name(stubArray, "stubArray");
var stubArray_default = stubArray;

// node_modules/lodash-es/_getSymbols.js
var objectProto11 = Object.prototype;
var propertyIsEnumerable2 = objectProto11.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable2.call(object, symbol);
  });
};
var getSymbols_default = getSymbols;

// node_modules/lodash-es/_getAllKeys.js
init_process_shim();

// node_modules/lodash-es/_baseGetAllKeys.js
init_process_shim();
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_default(object) ? result : arrayPush_default(result, symbolsFunc(object));
}
__name(baseGetAllKeys, "baseGetAllKeys");
var baseGetAllKeys_default = baseGetAllKeys;

// node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object) {
  return baseGetAllKeys_default(object, keys_default, getSymbols_default);
}
__name(getAllKeys, "getAllKeys");
var getAllKeys_default = getAllKeys;

// node_modules/lodash-es/_getTag.js
init_process_shim();

// node_modules/lodash-es/_DataView.js
init_process_shim();
var DataView2 = getNative_default(root_default, "DataView");
var DataView_default = DataView2;

// node_modules/lodash-es/_Promise.js
init_process_shim();
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// node_modules/lodash-es/_Set.js
init_process_shim();
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag2 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = /* @__PURE__ */ __name(function(value) {
    var result = baseGetTag_default(value), Ctor = result == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result;
  }, "getTag");
}
var getTag_default = getTag;

// node_modules/lodash-es/_Uint8Array.js
init_process_shim();
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;

// node_modules/lodash-es/_baseIteratee.js
init_process_shim();

// node_modules/lodash-es/_baseMatches.js
init_process_shim();

// node_modules/lodash-es/_baseIsMatch.js
init_process_shim();

// node_modules/lodash-es/_baseIsEqual.js
init_process_shim();

// node_modules/lodash-es/_baseIsEqualDeep.js
init_process_shim();

// node_modules/lodash-es/_equalArrays.js
init_process_shim();

// node_modules/lodash-es/_SetCache.js
init_process_shim();

// node_modules/lodash-es/_setCacheAdd.js
init_process_shim();
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED3);
  return this;
}
__name(setCacheAdd, "setCacheAdd");
var setCacheAdd_default = setCacheAdd;

// node_modules/lodash-es/_setCacheHas.js
init_process_shim();
function setCacheHas(value) {
  return this.__data__.has(value);
}
__name(setCacheHas, "setCacheHas");
var setCacheHas_default = setCacheHas;

// node_modules/lodash-es/_SetCache.js
function SetCache(values) {
  var index = -1, length2 = values == null ? 0 : values.length;
  this.__data__ = new MapCache_default();
  while (++index < length2) {
    this.add(values[index]);
  }
}
__name(SetCache, "SetCache");
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;

// node_modules/lodash-es/_arraySome.js
init_process_shim();
function arraySome(array, predicate) {
  var index = -1, length2 = array == null ? 0 : array.length;
  while (++index < length2) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
__name(arraySome, "arraySome");
var arraySome_default = arraySome;

// node_modules/lodash-es/_cacheHas.js
init_process_shim();
function cacheHas(cache, key) {
  return cache.has(key);
}
__name(cacheHas, "cacheHas");
var cacheHas_default = cacheHas;

// node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index < arrLength) {
    var arrValue = array[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other, function(othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
__name(equalArrays, "equalArrays");
var equalArrays_default = equalArrays;

// node_modules/lodash-es/_equalByTag.js
init_process_shim();

// node_modules/lodash-es/_mapToArray.js
init_process_shim();
function mapToArray(map3) {
  var index = -1, result = Array(map3.size);
  map3.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}
__name(mapToArray, "mapToArray");
var mapToArray_default = mapToArray;

// node_modules/lodash-es/_setToArray.js
init_process_shim();
function setToArray(set) {
  var index = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
__name(setToArray, "setToArray");
var setToArray_default = setToArray;

// node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var errorTag2 = "[object Error]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag3:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag2:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
        return false;
      }
      return true;
    case boolTag2:
    case dateTag2:
    case numberTag2:
      return eq_default(+object, +other);
    case errorTag2:
      return object.name == other.name && object.message == other.message;
    case regexpTag2:
    case stringTag2:
      return object == other + "";
    case mapTag3:
      var convert = mapToArray_default;
    case setTag3:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
      convert || (convert = setToArray_default);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG2;
      stack.set(object, other);
      var result = equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag2:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
__name(equalByTag, "equalByTag");
var equalByTag_default = equalByTag;

// node_modules/lodash-es/_equalObjects.js
init_process_shim();
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto12 = Object.prototype;
var hasOwnProperty9 = objectProto12.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty9.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
__name(equalObjects, "equalObjects");
var equalObjects_default = equalObjects;

// node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var objectTag3 = "[object Object]";
var objectProto13 = Object.prototype;
var hasOwnProperty10 = objectProto13.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag2 : getTag_default(object), othTag = othIsArr ? arrayTag2 : getTag_default(other);
  objTag = objTag == argsTag3 ? objectTag3 : objTag;
  othTag = othTag == argsTag3 ? objectTag3 : othTag;
  var objIsObj = objTag == objectTag3, othIsObj = othTag == objectTag3, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_default(object)) {
    if (!isBuffer_default(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack_default());
    return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
    var objIsWrapped = objIsObj && hasOwnProperty10.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty10.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack_default());
  return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
}
__name(baseIsEqualDeep, "baseIsEqualDeep");
var baseIsEqualDeep_default = baseIsEqualDeep;

// node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
}
__name(baseIsEqual, "baseIsEqual");
var baseIsEqual_default = baseIsEqual;

// node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG5 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length, length2 = index, noCustomizer = !customizer;
  if (object == null) {
    return !length2;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length2) {
    data = matchData[index];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack_default();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
__name(baseIsMatch, "baseIsMatch");
var baseIsMatch_default = baseIsMatch;

// node_modules/lodash-es/_getMatchData.js
init_process_shim();

// node_modules/lodash-es/_isStrictComparable.js
init_process_shim();
function isStrictComparable(value) {
  return value === value && !isObject_default(value);
}
__name(isStrictComparable, "isStrictComparable");
var isStrictComparable_default = isStrictComparable;

// node_modules/lodash-es/_getMatchData.js
function getMatchData(object) {
  var result = keys_default(object), length2 = result.length;
  while (length2--) {
    var key = result[length2], value = object[key];
    result[length2] = [key, value, isStrictComparable_default(value)];
  }
  return result;
}
__name(getMatchData, "getMatchData");
var getMatchData_default = getMatchData;

// node_modules/lodash-es/_matchesStrictComparable.js
init_process_shim();
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
__name(matchesStrictComparable, "matchesStrictComparable");
var matchesStrictComparable_default = matchesStrictComparable;

// node_modules/lodash-es/_baseMatches.js
function baseMatches(source) {
  var matchData = getMatchData_default(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch_default(object, source, matchData);
  };
}
__name(baseMatches, "baseMatches");
var baseMatches_default = baseMatches;

// node_modules/lodash-es/_baseMatchesProperty.js
init_process_shim();

// node_modules/lodash-es/hasIn.js
init_process_shim();

// node_modules/lodash-es/_baseHasIn.js
init_process_shim();
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
__name(baseHasIn, "baseHasIn");
var baseHasIn_default = baseHasIn;

// node_modules/lodash-es/_hasPath.js
init_process_shim();
function hasPath(object, path, hasFunc) {
  path = castPath_default(path, object);
  var index = -1, length2 = path.length, result = false;
  while (++index < length2) {
    var key = toKey_default(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length2) {
    return result;
  }
  length2 = object == null ? 0 : object.length;
  return !!length2 && isLength_default(length2) && isIndex_default(key, length2) && (isArray_default(object) || isArguments_default(object));
}
__name(hasPath, "hasPath");
var hasPath_default = hasPath;

// node_modules/lodash-es/hasIn.js
function hasIn(object, path) {
  return object != null && hasPath_default(object, path, baseHasIn_default);
}
__name(hasIn, "hasIn");
var hasIn_default = hasIn;

// node_modules/lodash-es/_baseMatchesProperty.js
var COMPARE_PARTIAL_FLAG6 = 1;
var COMPARE_UNORDERED_FLAG4 = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey_default(path) && isStrictComparable_default(srcValue)) {
    return matchesStrictComparable_default(toKey_default(path), srcValue);
  }
  return function(object) {
    var objValue = get_default(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
  };
}
__name(baseMatchesProperty, "baseMatchesProperty");
var baseMatchesProperty_default = baseMatchesProperty;

// node_modules/lodash-es/property.js
init_process_shim();

// node_modules/lodash-es/_baseProperty.js
init_process_shim();
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
__name(baseProperty, "baseProperty");
var baseProperty_default = baseProperty;

// node_modules/lodash-es/_basePropertyDeep.js
init_process_shim();
function basePropertyDeep(path) {
  return function(object) {
    return baseGet_default(object, path);
  };
}
__name(basePropertyDeep, "basePropertyDeep");
var basePropertyDeep_default = basePropertyDeep;

// node_modules/lodash-es/property.js
function property(path) {
  return isKey_default(path) ? baseProperty_default(toKey_default(path)) : basePropertyDeep_default(path);
}
__name(property, "property");
var property_default = property;

// node_modules/lodash-es/_baseIteratee.js
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity_default;
  }
  if (typeof value == "object") {
    return isArray_default(value) ? baseMatchesProperty_default(value[0], value[1]) : baseMatches_default(value);
  }
  return property_default(value);
}
__name(baseIteratee, "baseIteratee");
var baseIteratee_default = baseIteratee;

// node_modules/lodash-es/_createAggregator.js
init_process_shim();

// node_modules/lodash-es/_arrayAggregator.js
init_process_shim();
function arrayAggregator(array, setter, iteratee, accumulator) {
  var index = -1, length2 = array == null ? 0 : array.length;
  while (++index < length2) {
    var value = array[index];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}
__name(arrayAggregator, "arrayAggregator");
var arrayAggregator_default = arrayAggregator;

// node_modules/lodash-es/_baseAggregator.js
init_process_shim();

// node_modules/lodash-es/_baseEach.js
init_process_shim();

// node_modules/lodash-es/_baseForOwn.js
init_process_shim();

// node_modules/lodash-es/_baseFor.js
init_process_shim();

// node_modules/lodash-es/_createBaseFor.js
init_process_shim();
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
    while (length2--) {
      var key = props[fromRight ? length2 : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
__name(createBaseFor, "createBaseFor");
var createBaseFor_default = createBaseFor;

// node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object, iteratee) {
  return object && baseFor_default(object, iteratee, keys_default);
}
__name(baseForOwn, "baseForOwn");
var baseForOwn_default = baseForOwn;

// node_modules/lodash-es/_createBaseEach.js
init_process_shim();
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_default(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length2 = collection.length, index = fromRight ? length2 : -1, iterable = Object(collection);
    while (fromRight ? index-- : ++index < length2) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
__name(createBaseEach, "createBaseEach");
var createBaseEach_default = createBaseEach;

// node_modules/lodash-es/_baseEach.js
var baseEach = createBaseEach_default(baseForOwn_default);
var baseEach_default = baseEach;

// node_modules/lodash-es/_baseAggregator.js
function baseAggregator(collection, setter, iteratee, accumulator) {
  baseEach_default(collection, function(value, key, collection2) {
    setter(accumulator, value, iteratee(value), collection2);
  });
  return accumulator;
}
__name(baseAggregator, "baseAggregator");
var baseAggregator_default = baseAggregator;

// node_modules/lodash-es/_createAggregator.js
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray_default(collection) ? arrayAggregator_default : baseAggregator_default, accumulator = initializer ? initializer() : {};
    return func(collection, setter, baseIteratee_default(iteratee, 2), accumulator);
  };
}
__name(createAggregator, "createAggregator");
var createAggregator_default = createAggregator;

// node_modules/lodash-es/debounce.js
init_process_shim();

// node_modules/lodash-es/now.js
init_process_shim();
var now = /* @__PURE__ */ __name(function() {
  return root_default.Date.now();
}, "now");
var now_default = now;

// node_modules/lodash-es/debounce.js
var FUNC_ERROR_TEXT2 = "Expected a function";
var nativeMax2 = Math.max;
var nativeMin = Math.min;
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT2);
  }
  wait = toNumber_default(wait) || 0;
  if (isObject_default(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax2(toNumber_default(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args2 = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args2);
    return result;
  }
  __name(invokeFunc, "invokeFunc");
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  __name(leadingEdge, "leadingEdge");
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  __name(remainingWait, "remainingWait");
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  __name(shouldInvoke, "shouldInvoke");
  function timerExpired() {
    var time = now_default();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  __name(timerExpired, "timerExpired");
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  __name(trailingEdge, "trailingEdge");
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  __name(cancel, "cancel");
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now_default());
  }
  __name(flush, "flush");
  function debounced() {
    var time = now_default(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  __name(debounced, "debounced");
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
__name(debounce, "debounce");
var debounce_default = debounce;

// node_modules/lodash-es/_arrayIncludesWith.js
init_process_shim();
function arrayIncludesWith(array, value, comparator) {
  var index = -1, length2 = array == null ? 0 : array.length;
  while (++index < length2) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}
__name(arrayIncludesWith, "arrayIncludesWith");
var arrayIncludesWith_default = arrayIncludesWith;

// node_modules/lodash-es/_baseMap.js
init_process_shim();
function baseMap(collection, iteratee) {
  var index = -1, result = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value, key, collection2) {
    result[++index] = iteratee(value, key, collection2);
  });
  return result;
}
__name(baseMap, "baseMap");
var baseMap_default = baseMap;

// node_modules/lodash-es/groupBy.js
init_process_shim();
var objectProto14 = Object.prototype;
var hasOwnProperty11 = objectProto14.hasOwnProperty;
var groupBy = createAggregator_default(function(result, value, key) {
  if (hasOwnProperty11.call(result, key)) {
    result[key].push(value);
  } else {
    baseAssignValue_default(result, key, [value]);
  }
});
var groupBy_default = groupBy;

// node_modules/lodash-es/isEqual.js
init_process_shim();
function isEqual(value, other) {
  return baseIsEqual_default(value, other);
}
__name(isEqual, "isEqual");
var isEqual_default = isEqual;

// node_modules/lodash-es/_baseOrderBy.js
init_process_shim();

// node_modules/lodash-es/_baseSortBy.js
init_process_shim();
function baseSortBy(array, comparer) {
  var length2 = array.length;
  array.sort(comparer);
  while (length2--) {
    array[length2] = array[length2].value;
  }
  return array;
}
__name(baseSortBy, "baseSortBy");
var baseSortBy_default = baseSortBy;

// node_modules/lodash-es/_compareMultiple.js
init_process_shim();

// node_modules/lodash-es/_compareAscending.js
init_process_shim();
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol_default(value);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol_default(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
__name(compareAscending, "compareAscending");
var compareAscending_default = compareAscending;

// node_modules/lodash-es/_compareMultiple.js
function compareMultiple(object, other, orders) {
  var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
  while (++index < length2) {
    var result = compareAscending_default(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == "desc" ? -1 : 1);
    }
  }
  return object.index - other.index;
}
__name(compareMultiple, "compareMultiple");
var compareMultiple_default = compareMultiple;

// node_modules/lodash-es/_baseOrderBy.js
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap_default(iteratees, function(iteratee) {
      if (isArray_default(iteratee)) {
        return function(value) {
          return baseGet_default(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        };
      }
      return iteratee;
    });
  } else {
    iteratees = [identity_default];
  }
  var index = -1;
  iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
  var result = baseMap_default(collection, function(value, key, collection2) {
    var criteria = arrayMap_default(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { "criteria": criteria, "index": ++index, "value": value };
  });
  return baseSortBy_default(result, function(object, other) {
    return compareMultiple_default(object, other, orders);
  });
}
__name(baseOrderBy, "baseOrderBy");
var baseOrderBy_default = baseOrderBy;

// node_modules/lodash-es/sortBy.js
init_process_shim();
var sortBy = baseRest_default(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length2 = iteratees.length;
  if (length2 > 1 && isIterateeCall_default(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length2 > 2 && isIterateeCall_default(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy_default(collection, baseFlatten_default(iteratees, 1), []);
});
var sortBy_default = sortBy;

// node_modules/lodash-es/throttle.js
init_process_shim();
var FUNC_ERROR_TEXT3 = "Expected a function";
function throttle2(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT3);
  }
  if (isObject_default(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce_default(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
__name(throttle2, "throttle");
var throttle_default2 = throttle2;

// node_modules/lodash-es/_baseUniq.js
init_process_shim();

// node_modules/lodash-es/_createSet.js
init_process_shim();
var INFINITY3 = 1 / 0;
var createSet = !(Set_default && 1 / setToArray_default(new Set_default([, -0]))[1] == INFINITY3) ? noop_default : function(values) {
  return new Set_default(values);
};
var createSet_default = createSet;

// node_modules/lodash-es/_baseUniq.js
var LARGE_ARRAY_SIZE2 = 200;
function baseUniq(array, iteratee, comparator) {
  var index = -1, includes = arrayIncludes_default, length2 = array.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith_default;
  } else if (length2 >= LARGE_ARRAY_SIZE2) {
    var set = iteratee ? null : createSet_default(array);
    if (set) {
      return setToArray_default(set);
    }
    isCommon = false;
    includes = cacheHas_default;
    seen = new SetCache_default();
  } else {
    seen = iteratee ? [] : result;
  }
  outer:
    while (++index < length2) {
      var value = array[index], computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed);
        }
        result.push(value);
      } else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
  return result;
}
__name(baseUniq, "baseUniq");
var baseUniq_default = baseUniq;

// node_modules/lodash-es/uniqBy.js
init_process_shim();
function uniqBy(array, iteratee) {
  return array && array.length ? baseUniq_default(array, baseIteratee_default(iteratee, 2)) : [];
}
__name(uniqBy, "uniqBy");
var uniqBy_default = uniqBy;

// src/services/account/AccountService.ts
var import_ms = __toESM(require_ms());
var import_obsidian6 = require("obsidian");

// node_modules/phoenix/priv/static/phoenix.mjs
init_process_shim();
var closure = /* @__PURE__ */ __name((value) => {
  if (typeof value === "function") {
    return value;
  } else {
    let closure2 = /* @__PURE__ */ __name(function() {
      return value;
    }, "closure2");
    return closure2;
  }
}, "closure");
var globalSelf = typeof self !== "undefined" ? self : null;
var phxWindow = typeof window !== "undefined" ? window : null;
var global2 = globalSelf || phxWindow || global2;
var DEFAULT_VSN = "2.0.0";
var SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };
var DEFAULT_TIMEOUT = 1e4;
var WS_CLOSE_NORMAL = 1e3;
var CHANNEL_STATES = {
  closed: "closed",
  errored: "errored",
  joined: "joined",
  joining: "joining",
  leaving: "leaving"
};
var CHANNEL_EVENTS = {
  close: "phx_close",
  error: "phx_error",
  join: "phx_join",
  reply: "phx_reply",
  leave: "phx_leave"
};
var TRANSPORTS = {
  longpoll: "longpoll",
  websocket: "websocket"
};
var XHR_STATES = {
  complete: 4
};
var _a;
var Push = (_a = class {
  constructor(channel, event, payload, timeout) {
    this.channel = channel;
    this.event = event;
    this.payload = payload || function() {
      return {};
    };
    this.receivedResp = null;
    this.timeout = timeout;
    this.timeoutTimer = null;
    this.recHooks = [];
    this.sent = false;
  }
  /**
   *
   * @param {number} timeout
   */
  resend(timeout) {
    this.timeout = timeout;
    this.reset();
    this.send();
  }
  /**
   *
   */
  send() {
    if (this.hasReceived("timeout")) {
      return;
    }
    this.startTimeout();
    this.sent = true;
    this.channel.socket.push({
      topic: this.channel.topic,
      event: this.event,
      payload: this.payload(),
      ref: this.ref,
      join_ref: this.channel.joinRef()
    });
  }
  /**
   *
   * @param {*} status
   * @param {*} callback
   */
  receive(status, callback) {
    if (this.hasReceived(status)) {
      callback(this.receivedResp.response);
    }
    this.recHooks.push({ status, callback });
    return this;
  }
  /**
   * @private
   */
  reset() {
    this.cancelRefEvent();
    this.ref = null;
    this.refEvent = null;
    this.receivedResp = null;
    this.sent = false;
  }
  /**
   * @private
   */
  matchReceive({ status, response, _ref }) {
    this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
  }
  /**
   * @private
   */
  cancelRefEvent() {
    if (!this.refEvent) {
      return;
    }
    this.channel.off(this.refEvent);
  }
  /**
   * @private
   */
  cancelTimeout() {
    clearTimeout(this.timeoutTimer);
    this.timeoutTimer = null;
  }
  /**
   * @private
   */
  startTimeout() {
    if (this.timeoutTimer) {
      this.cancelTimeout();
    }
    this.ref = this.channel.socket.makeRef();
    this.refEvent = this.channel.replyEventName(this.ref);
    this.channel.on(this.refEvent, (payload) => {
      this.cancelRefEvent();
      this.cancelTimeout();
      this.receivedResp = payload;
      this.matchReceive(payload);
    });
    this.timeoutTimer = setTimeout(() => {
      this.trigger("timeout", {});
    }, this.timeout);
  }
  /**
   * @private
   */
  hasReceived(status) {
    return this.receivedResp && this.receivedResp.status === status;
  }
  /**
   * @private
   */
  trigger(status, response) {
    this.channel.trigger(this.refEvent, { status, response });
  }
}, __name(_a, "Push"), _a);
var _a2;
var Timer = (_a2 = class {
  constructor(callback, timerCalc) {
    this.callback = callback;
    this.timerCalc = timerCalc;
    this.timer = null;
    this.tries = 0;
  }
  reset() {
    this.tries = 0;
    clearTimeout(this.timer);
  }
  /**
   * Cancels any previous scheduleTimeout and schedules callback
   */
  scheduleTimeout() {
    clearTimeout(this.timer);
    this.timer = setTimeout(() => {
      this.tries = this.tries + 1;
      this.callback();
    }, this.timerCalc(this.tries + 1));
  }
}, __name(_a2, "Timer"), _a2);
var _a3;
var Channel = (_a3 = class {
  constructor(topic, params2, socket) {
    this.state = CHANNEL_STATES.closed;
    this.topic = topic;
    this.params = closure(params2 || {});
    this.socket = socket;
    this.bindings = [];
    this.bindingRef = 0;
    this.timeout = this.socket.timeout;
    this.joinedOnce = false;
    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
    this.pushBuffer = [];
    this.stateChangeRefs = [];
    this.rejoinTimer = new Timer(() => {
      if (this.socket.isConnected()) {
        this.rejoin();
      }
    }, this.socket.rejoinAfterMs);
    this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));
    this.stateChangeRefs.push(
      this.socket.onOpen(() => {
        this.rejoinTimer.reset();
        if (this.isErrored()) {
          this.rejoin();
        }
      })
    );
    this.joinPush.receive("ok", () => {
      this.state = CHANNEL_STATES.joined;
      this.rejoinTimer.reset();
      this.pushBuffer.forEach((pushEvent) => pushEvent.send());
      this.pushBuffer = [];
    });
    this.joinPush.receive("error", () => {
      this.state = CHANNEL_STATES.errored;
      if (this.socket.isConnected()) {
        this.rejoinTimer.scheduleTimeout();
      }
    });
    this.onClose(() => {
      this.rejoinTimer.reset();
      if (this.socket.hasLogger())
        this.socket.log("channel", `close ${this.topic} ${this.joinRef()}`);
      this.state = CHANNEL_STATES.closed;
      this.socket.remove(this);
    });
    this.onError((reason) => {
      if (this.socket.hasLogger())
        this.socket.log("channel", `error ${this.topic}`, reason);
      if (this.isJoining()) {
        this.joinPush.reset();
      }
      this.state = CHANNEL_STATES.errored;
      if (this.socket.isConnected()) {
        this.rejoinTimer.scheduleTimeout();
      }
    });
    this.joinPush.receive("timeout", () => {
      if (this.socket.hasLogger())
        this.socket.log("channel", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);
      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);
      leavePush.send();
      this.state = CHANNEL_STATES.errored;
      this.joinPush.reset();
      if (this.socket.isConnected()) {
        this.rejoinTimer.scheduleTimeout();
      }
    });
    this.on(CHANNEL_EVENTS.reply, (payload, ref) => {
      this.trigger(this.replyEventName(ref), payload);
    });
  }
  /**
   * Join the channel
   * @param {integer} timeout
   * @returns {Push}
   */
  join(timeout = this.timeout) {
    if (this.joinedOnce) {
      throw new Error("tried to join multiple times. 'join' can only be called a single time per channel instance");
    } else {
      this.timeout = timeout;
      this.joinedOnce = true;
      this.rejoin();
      return this.joinPush;
    }
  }
  /**
   * Hook into channel close
   * @param {Function} callback
   */
  onClose(callback) {
    this.on(CHANNEL_EVENTS.close, callback);
  }
  /**
   * Hook into channel errors
   * @param {Function} callback
   */
  onError(callback) {
    return this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));
  }
  /**
   * Subscribes on channel events
   *
   * Subscription returns a ref counter, which can be used later to
   * unsubscribe the exact event listener
   *
   * @example
   * const ref1 = channel.on("event", do_stuff)
   * const ref2 = channel.on("event", do_other_stuff)
   * channel.off("event", ref1)
   * // Since unsubscription, do_stuff won't fire,
   * // while do_other_stuff will keep firing on the "event"
   *
   * @param {string} event
   * @param {Function} callback
   * @returns {integer} ref
   */
  on(event, callback) {
    let ref = this.bindingRef++;
    this.bindings.push({ event, ref, callback });
    return ref;
  }
  /**
   * Unsubscribes off of channel events
   *
   * Use the ref returned from a channel.on() to unsubscribe one
   * handler, or pass nothing for the ref to unsubscribe all
   * handlers for the given event.
   *
   * @example
   * // Unsubscribe the do_stuff handler
   * const ref1 = channel.on("event", do_stuff)
   * channel.off("event", ref1)
   *
   * // Unsubscribe all handlers from event
   * channel.off("event")
   *
   * @param {string} event
   * @param {integer} ref
   */
  off(event, ref) {
    this.bindings = this.bindings.filter((bind3) => {
      return !(bind3.event === event && (typeof ref === "undefined" || ref === bind3.ref));
    });
  }
  /**
   * @private
   */
  canPush() {
    return this.socket.isConnected() && this.isJoined();
  }
  /**
   * Sends a message `event` to phoenix with the payload `payload`.
   * Phoenix receives this in the `handle_in(event, payload, socket)`
   * function. if phoenix replies or it times out (default 10000ms),
   * then optionally the reply can be received.
   *
   * @example
   * channel.push("event")
   *   .receive("ok", payload => console.log("phoenix replied:", payload))
   *   .receive("error", err => console.log("phoenix errored", err))
   *   .receive("timeout", () => console.log("timed out pushing"))
   * @param {string} event
   * @param {Object} payload
   * @param {number} [timeout]
   * @returns {Push}
   */
  push(event, payload, timeout = this.timeout) {
    payload = payload || {};
    if (!this.joinedOnce) {
      throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);
    }
    let pushEvent = new Push(this, event, function() {
      return payload;
    }, timeout);
    if (this.canPush()) {
      pushEvent.send();
    } else {
      pushEvent.startTimeout();
      this.pushBuffer.push(pushEvent);
    }
    return pushEvent;
  }
  /** Leaves the channel
   *
   * Unsubscribes from server events, and
   * instructs channel to terminate on server
   *
   * Triggers onClose() hooks
   *
   * To receive leave acknowledgements, use the `receive`
   * hook to bind to the server ack, ie:
   *
   * @example
   * channel.leave().receive("ok", () => alert("left!") )
   *
   * @param {integer} timeout
   * @returns {Push}
   */
  leave(timeout = this.timeout) {
    this.rejoinTimer.reset();
    this.joinPush.cancelTimeout();
    this.state = CHANNEL_STATES.leaving;
    let onClose = /* @__PURE__ */ __name(() => {
      if (this.socket.hasLogger())
        this.socket.log("channel", `leave ${this.topic}`);
      this.trigger(CHANNEL_EVENTS.close, "leave");
    }, "onClose");
    let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);
    leavePush.receive("ok", () => onClose()).receive("timeout", () => onClose());
    leavePush.send();
    if (!this.canPush()) {
      leavePush.trigger("ok", {});
    }
    return leavePush;
  }
  /**
   * Overridable message hook
   *
   * Receives all events for specialized message handling
   * before dispatching to the channel callbacks.
   *
   * Must return the payload, modified or unmodified
   * @param {string} event
   * @param {Object} payload
   * @param {integer} ref
   * @returns {Object}
   */
  onMessage(_event, payload, _ref) {
    return payload;
  }
  /**
   * @private
   */
  isMember(topic, event, payload, joinRef) {
    if (this.topic !== topic) {
      return false;
    }
    if (joinRef && joinRef !== this.joinRef()) {
      if (this.socket.hasLogger())
        this.socket.log("channel", "dropping outdated message", { topic, event, payload, joinRef });
      return false;
    } else {
      return true;
    }
  }
  /**
   * @private
   */
  joinRef() {
    return this.joinPush.ref;
  }
  /**
   * @private
   */
  rejoin(timeout = this.timeout) {
    if (this.isLeaving()) {
      return;
    }
    this.socket.leaveOpenTopic(this.topic);
    this.state = CHANNEL_STATES.joining;
    this.joinPush.resend(timeout);
  }
  /**
   * @private
   */
  trigger(event, payload, ref, joinRef) {
    let handledPayload = this.onMessage(event, payload, ref, joinRef);
    if (payload && !handledPayload) {
      throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");
    }
    let eventBindings = this.bindings.filter((bind3) => bind3.event === event);
    for (let i = 0; i < eventBindings.length; i++) {
      let bind3 = eventBindings[i];
      bind3.callback(handledPayload, ref, joinRef || this.joinRef());
    }
  }
  /**
   * @private
   */
  replyEventName(ref) {
    return `chan_reply_${ref}`;
  }
  /**
   * @private
   */
  isClosed() {
    return this.state === CHANNEL_STATES.closed;
  }
  /**
   * @private
   */
  isErrored() {
    return this.state === CHANNEL_STATES.errored;
  }
  /**
   * @private
   */
  isJoined() {
    return this.state === CHANNEL_STATES.joined;
  }
  /**
   * @private
   */
  isJoining() {
    return this.state === CHANNEL_STATES.joining;
  }
  /**
   * @private
   */
  isLeaving() {
    return this.state === CHANNEL_STATES.leaving;
  }
}, __name(_a3, "Channel"), _a3);
var _a4;
var Ajax = (_a4 = class {
  static request(method, endPoint, accept, body, timeout, ontimeout, callback) {
    if (global2.XDomainRequest) {
      let req = new global2.XDomainRequest();
      return this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);
    } else {
      let req = new global2.XMLHttpRequest();
      return this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);
    }
  }
  static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {
    req.timeout = timeout;
    req.open(method, endPoint);
    req.onload = () => {
      let response = this.parseJSON(req.responseText);
      callback && callback(response);
    };
    if (ontimeout) {
      req.ontimeout = ontimeout;
    }
    req.onprogress = () => {
    };
    req.send(body);
    return req;
  }
  static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {
    req.open(method, endPoint, true);
    req.timeout = timeout;
    req.setRequestHeader("Content-Type", accept);
    req.onerror = () => callback && callback(null);
    req.onreadystatechange = () => {
      if (req.readyState === XHR_STATES.complete && callback) {
        let response = this.parseJSON(req.responseText);
        callback(response);
      }
    };
    if (ontimeout) {
      req.ontimeout = ontimeout;
    }
    req.send(body);
    return req;
  }
  static parseJSON(resp) {
    if (!resp || resp === "") {
      return null;
    }
    try {
      return JSON.parse(resp);
    } catch (e) {
      console && console.log("failed to parse JSON response", resp);
      return null;
    }
  }
  static serialize(obj, parentKey) {
    let queryStr = [];
    for (var key in obj) {
      if (!Object.prototype.hasOwnProperty.call(obj, key)) {
        continue;
      }
      let paramKey = parentKey ? `${parentKey}[${key}]` : key;
      let paramVal = obj[key];
      if (typeof paramVal === "object") {
        queryStr.push(this.serialize(paramVal, paramKey));
      } else {
        queryStr.push(encodeURIComponent(paramKey) + "=" + encodeURIComponent(paramVal));
      }
    }
    return queryStr.join("&");
  }
  static appendParams(url, params2) {
    if (Object.keys(params2).length === 0) {
      return url;
    }
    let prefix = url.match(/\?/) ? "&" : "?";
    return `${url}${prefix}${this.serialize(params2)}`;
  }
}, __name(_a4, "Ajax"), _a4);
var arrayBufferToBase64 = /* @__PURE__ */ __name((buffer) => {
  let binary = "";
  let bytes = new Uint8Array(buffer);
  let len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}, "arrayBufferToBase64");
var _a5;
var LongPoll = (_a5 = class {
  constructor(endPoint) {
    this.endPoint = null;
    this.token = null;
    this.skipHeartbeat = true;
    this.reqs = /* @__PURE__ */ new Set();
    this.awaitingBatchAck = false;
    this.currentBatch = null;
    this.currentBatchTimer = null;
    this.batchBuffer = [];
    this.onopen = function() {
    };
    this.onerror = function() {
    };
    this.onmessage = function() {
    };
    this.onclose = function() {
    };
    this.pollEndpoint = this.normalizeEndpoint(endPoint);
    this.readyState = SOCKET_STATES.connecting;
    setTimeout(() => this.poll(), 0);
  }
  normalizeEndpoint(endPoint) {
    return endPoint.replace("ws://", "http://").replace("wss://", "https://").replace(new RegExp("(.*)/" + TRANSPORTS.websocket), "$1/" + TRANSPORTS.longpoll);
  }
  endpointURL() {
    return Ajax.appendParams(this.pollEndpoint, { token: this.token });
  }
  closeAndRetry(code, reason, wasClean) {
    this.close(code, reason, wasClean);
    this.readyState = SOCKET_STATES.connecting;
  }
  ontimeout() {
    this.onerror("timeout");
    this.closeAndRetry(1005, "timeout", false);
  }
  isActive() {
    return this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting;
  }
  poll() {
    this.ajax("GET", "application/json", null, () => this.ontimeout(), (resp) => {
      if (resp) {
        var { status, token, messages } = resp;
        this.token = token;
      } else {
        status = 0;
      }
      switch (status) {
        case 200:
          messages.forEach((msg) => {
            setTimeout(() => this.onmessage({ data: msg }), 0);
          });
          this.poll();
          break;
        case 204:
          this.poll();
          break;
        case 410:
          this.readyState = SOCKET_STATES.open;
          this.onopen({});
          this.poll();
          break;
        case 403:
          this.onerror(403);
          this.close(1008, "forbidden", false);
          break;
        case 0:
        case 500:
          this.onerror(500);
          this.closeAndRetry(1011, "internal server error", 500);
          break;
        default:
          throw new Error(`unhandled poll status ${status}`);
      }
    });
  }
  // we collect all pushes within the current event loop by
  // setTimeout 0, which optimizes back-to-back procedural
  // pushes against an empty buffer
  send(body) {
    if (typeof body !== "string") {
      body = arrayBufferToBase64(body);
    }
    if (this.currentBatch) {
      this.currentBatch.push(body);
    } else if (this.awaitingBatchAck) {
      this.batchBuffer.push(body);
    } else {
      this.currentBatch = [body];
      this.currentBatchTimer = setTimeout(() => {
        this.batchSend(this.currentBatch);
        this.currentBatch = null;
      }, 0);
    }
  }
  batchSend(messages) {
    this.awaitingBatchAck = true;
    this.ajax("POST", "application/x-ndjson", messages.join("\n"), () => this.onerror("timeout"), (resp) => {
      this.awaitingBatchAck = false;
      if (!resp || resp.status !== 200) {
        this.onerror(resp && resp.status);
        this.closeAndRetry(1011, "internal server error", false);
      } else if (this.batchBuffer.length > 0) {
        this.batchSend(this.batchBuffer);
        this.batchBuffer = [];
      }
    });
  }
  close(code, reason, wasClean) {
    for (let req of this.reqs) {
      req.abort();
    }
    this.readyState = SOCKET_STATES.closed;
    let opts = Object.assign({ code: 1e3, reason: void 0, wasClean: true }, { code, reason, wasClean });
    this.batchBuffer = [];
    clearTimeout(this.currentBatchTimer);
    this.currentBatchTimer = null;
    if (typeof CloseEvent !== "undefined") {
      this.onclose(new CloseEvent("close", opts));
    } else {
      this.onclose(opts);
    }
  }
  ajax(method, contentType, body, onCallerTimeout, callback) {
    let req;
    let ontimeout = /* @__PURE__ */ __name(() => {
      this.reqs.delete(req);
      onCallerTimeout();
    }, "ontimeout");
    req = Ajax.request(method, this.endpointURL(), contentType, body, this.timeout, ontimeout, (resp) => {
      this.reqs.delete(req);
      if (this.isActive()) {
        callback(resp);
      }
    });
    this.reqs.add(req);
  }
}, __name(_a5, "LongPoll"), _a5);
var _a6;
var Presence = (_a6 = class {
  constructor(channel, opts = {}) {
    let events = opts.events || { state: "presence_state", diff: "presence_diff" };
    this.state = {};
    this.pendingDiffs = [];
    this.channel = channel;
    this.joinRef = null;
    this.caller = {
      onJoin: /* @__PURE__ */ __name(function() {
      }, "onJoin"),
      onLeave: /* @__PURE__ */ __name(function() {
      }, "onLeave"),
      onSync: /* @__PURE__ */ __name(function() {
      }, "onSync")
    };
    this.channel.on(events.state, (newState) => {
      let { onJoin, onLeave, onSync } = this.caller;
      this.joinRef = this.channel.joinRef();
      this.state = Presence.syncState(this.state, newState, onJoin, onLeave);
      this.pendingDiffs.forEach((diff) => {
        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);
      });
      this.pendingDiffs = [];
      onSync();
    });
    this.channel.on(events.diff, (diff) => {
      let { onJoin, onLeave, onSync } = this.caller;
      if (this.inPendingSyncState()) {
        this.pendingDiffs.push(diff);
      } else {
        this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);
        onSync();
      }
    });
  }
  onJoin(callback) {
    this.caller.onJoin = callback;
  }
  onLeave(callback) {
    this.caller.onLeave = callback;
  }
  onSync(callback) {
    this.caller.onSync = callback;
  }
  list(by) {
    return Presence.list(this.state, by);
  }
  inPendingSyncState() {
    return !this.joinRef || this.joinRef !== this.channel.joinRef();
  }
  // lower-level public static API
  /**
   * Used to sync the list of presences on the server
   * with the client's state. An optional `onJoin` and `onLeave` callback can
   * be provided to react to changes in the client's local presences across
   * disconnects and reconnects with the server.
   *
   * @returns {Presence}
   */
  static syncState(currentState, newState, onJoin, onLeave) {
    let state = this.clone(currentState);
    let joins = {};
    let leaves = {};
    this.map(state, (key, presence) => {
      if (!newState[key]) {
        leaves[key] = presence;
      }
    });
    this.map(newState, (key, newPresence) => {
      let currentPresence = state[key];
      if (currentPresence) {
        let newRefs = newPresence.metas.map((m) => m.phx_ref);
        let curRefs = currentPresence.metas.map((m) => m.phx_ref);
        let joinedMetas = newPresence.metas.filter((m) => curRefs.indexOf(m.phx_ref) < 0);
        let leftMetas = currentPresence.metas.filter((m) => newRefs.indexOf(m.phx_ref) < 0);
        if (joinedMetas.length > 0) {
          joins[key] = newPresence;
          joins[key].metas = joinedMetas;
        }
        if (leftMetas.length > 0) {
          leaves[key] = this.clone(currentPresence);
          leaves[key].metas = leftMetas;
        }
      } else {
        joins[key] = newPresence;
      }
    });
    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);
  }
  /**
   *
   * Used to sync a diff of presence join and leave
   * events from the server, as they happen. Like `syncState`, `syncDiff`
   * accepts optional `onJoin` and `onLeave` callbacks to react to a user
   * joining or leaving from a device.
   *
   * @returns {Presence}
   */
  static syncDiff(state, diff, onJoin, onLeave) {
    let { joins, leaves } = this.clone(diff);
    if (!onJoin) {
      onJoin = /* @__PURE__ */ __name(function() {
      }, "onJoin");
    }
    if (!onLeave) {
      onLeave = /* @__PURE__ */ __name(function() {
      }, "onLeave");
    }
    this.map(joins, (key, newPresence) => {
      let currentPresence = state[key];
      state[key] = this.clone(newPresence);
      if (currentPresence) {
        let joinedRefs = state[key].metas.map((m) => m.phx_ref);
        let curMetas = currentPresence.metas.filter((m) => joinedRefs.indexOf(m.phx_ref) < 0);
        state[key].metas.unshift(...curMetas);
      }
      onJoin(key, currentPresence, newPresence);
    });
    this.map(leaves, (key, leftPresence) => {
      let currentPresence = state[key];
      if (!currentPresence) {
        return;
      }
      let refsToRemove = leftPresence.metas.map((m) => m.phx_ref);
      currentPresence.metas = currentPresence.metas.filter((p) => {
        return refsToRemove.indexOf(p.phx_ref) < 0;
      });
      onLeave(key, currentPresence, leftPresence);
      if (currentPresence.metas.length === 0) {
        delete state[key];
      }
    });
    return state;
  }
  /**
   * Returns the array of presences, with selected metadata.
   *
   * @param {Object} presences
   * @param {Function} chooser
   *
   * @returns {Presence}
   */
  static list(presences, chooser) {
    if (!chooser) {
      chooser = /* @__PURE__ */ __name(function(key, pres) {
        return pres;
      }, "chooser");
    }
    return this.map(presences, (key, presence) => {
      return chooser(key, presence);
    });
  }
  // private
  static map(obj, func) {
    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));
  }
  static clone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
}, __name(_a6, "Presence"), _a6);
var serializer_default = {
  HEADER_LENGTH: 1,
  META_LENGTH: 4,
  KINDS: { push: 0, reply: 1, broadcast: 2 },
  encode(msg, callback) {
    if (msg.payload.constructor === ArrayBuffer) {
      return callback(this.binaryEncode(msg));
    } else {
      let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
      return callback(JSON.stringify(payload));
    }
  },
  decode(rawPayload, callback) {
    if (rawPayload.constructor === ArrayBuffer) {
      return callback(this.binaryDecode(rawPayload));
    } else {
      let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);
      return callback({ join_ref, ref, topic, event, payload });
    }
  },
  // private
  binaryEncode(message) {
    let { join_ref, ref, event, topic, payload } = message;
    let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;
    let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
    let view = new DataView(header);
    let offset = 0;
    view.setUint8(offset++, this.KINDS.push);
    view.setUint8(offset++, join_ref.length);
    view.setUint8(offset++, ref.length);
    view.setUint8(offset++, topic.length);
    view.setUint8(offset++, event.length);
    Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
    Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
    Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));
    Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));
    var combined = new Uint8Array(header.byteLength + payload.byteLength);
    combined.set(new Uint8Array(header), 0);
    combined.set(new Uint8Array(payload), header.byteLength);
    return combined.buffer;
  },
  binaryDecode(buffer) {
    let view = new DataView(buffer);
    let kind = view.getUint8(0);
    let decoder = new TextDecoder();
    switch (kind) {
      case this.KINDS.push:
        return this.decodePush(buffer, view, decoder);
      case this.KINDS.reply:
        return this.decodeReply(buffer, view, decoder);
      case this.KINDS.broadcast:
        return this.decodeBroadcast(buffer, view, decoder);
    }
  },
  decodePush(buffer, view, decoder) {
    let joinRefSize = view.getUint8(1);
    let topicSize = view.getUint8(2);
    let eventSize = view.getUint8(3);
    let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;
    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
    offset = offset + joinRefSize;
    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
    offset = offset + topicSize;
    let event = decoder.decode(buffer.slice(offset, offset + eventSize));
    offset = offset + eventSize;
    let data = buffer.slice(offset, buffer.byteLength);
    return { join_ref: joinRef, ref: null, topic, event, payload: data };
  },
  decodeReply(buffer, view, decoder) {
    let joinRefSize = view.getUint8(1);
    let refSize = view.getUint8(2);
    let topicSize = view.getUint8(3);
    let eventSize = view.getUint8(4);
    let offset = this.HEADER_LENGTH + this.META_LENGTH;
    let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
    offset = offset + joinRefSize;
    let ref = decoder.decode(buffer.slice(offset, offset + refSize));
    offset = offset + refSize;
    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
    offset = offset + topicSize;
    let event = decoder.decode(buffer.slice(offset, offset + eventSize));
    offset = offset + eventSize;
    let data = buffer.slice(offset, buffer.byteLength);
    let payload = { status: event, response: data };
    return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };
  },
  decodeBroadcast(buffer, view, decoder) {
    let topicSize = view.getUint8(1);
    let eventSize = view.getUint8(2);
    let offset = this.HEADER_LENGTH + 2;
    let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
    offset = offset + topicSize;
    let event = decoder.decode(buffer.slice(offset, offset + eventSize));
    offset = offset + eventSize;
    let data = buffer.slice(offset, buffer.byteLength);
    return { join_ref: null, ref: null, topic, event, payload: data };
  }
};
var _a7;
var Socket = (_a7 = class {
  constructor(endPoint, opts = {}) {
    this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };
    this.channels = [];
    this.sendBuffer = [];
    this.ref = 0;
    this.timeout = opts.timeout || DEFAULT_TIMEOUT;
    this.transport = opts.transport || global2.WebSocket || LongPoll;
    this.primaryPassedHealthCheck = false;
    this.longPollFallbackMs = opts.longPollFallbackMs;
    this.fallbackTimer = null;
    this.sessionStore = opts.sessionStorage || global2 && global2.sessionStorage;
    this.establishedConnections = 0;
    this.defaultEncoder = serializer_default.encode.bind(serializer_default);
    this.defaultDecoder = serializer_default.decode.bind(serializer_default);
    this.closeWasClean = false;
    this.disconnecting = false;
    this.binaryType = opts.binaryType || "arraybuffer";
    this.connectClock = 1;
    if (this.transport !== LongPoll) {
      this.encode = opts.encode || this.defaultEncoder;
      this.decode = opts.decode || this.defaultDecoder;
    } else {
      this.encode = this.defaultEncoder;
      this.decode = this.defaultDecoder;
    }
    let awaitingConnectionOnPageShow = null;
    if (phxWindow && phxWindow.addEventListener) {
      phxWindow.addEventListener("pagehide", (_e) => {
        if (this.conn) {
          this.disconnect();
          awaitingConnectionOnPageShow = this.connectClock;
        }
      });
      phxWindow.addEventListener("pageshow", (_e) => {
        if (awaitingConnectionOnPageShow === this.connectClock) {
          awaitingConnectionOnPageShow = null;
          this.connect();
        }
      });
    }
    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;
    this.rejoinAfterMs = (tries) => {
      if (opts.rejoinAfterMs) {
        return opts.rejoinAfterMs(tries);
      } else {
        return [1e3, 2e3, 5e3][tries - 1] || 1e4;
      }
    };
    this.reconnectAfterMs = (tries) => {
      if (opts.reconnectAfterMs) {
        return opts.reconnectAfterMs(tries);
      } else {
        return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;
      }
    };
    this.logger = opts.logger || null;
    if (!this.logger && opts.debug) {
      this.logger = (kind, msg, data) => {
        console.log(`${kind}: ${msg}`, data);
      };
    }
    this.longpollerTimeout = opts.longpollerTimeout || 2e4;
    this.params = closure(opts.params || {});
    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
    this.vsn = opts.vsn || DEFAULT_VSN;
    this.heartbeatTimeoutTimer = null;
    this.heartbeatTimer = null;
    this.pendingHeartbeatRef = null;
    this.reconnectTimer = new Timer(() => {
      this.teardown(() => this.connect());
    }, this.reconnectAfterMs);
  }
  /**
   * Returns the LongPoll transport reference
   */
  getLongPollTransport() {
    return LongPoll;
  }
  /**
   * Disconnects and replaces the active transport
   *
   * @param {Function} newTransport - The new transport class to instantiate
   *
   */
  replaceTransport(newTransport) {
    this.connectClock++;
    this.closeWasClean = true;
    clearTimeout(this.fallbackTimer);
    this.reconnectTimer.reset();
    if (this.conn) {
      this.conn.close();
      this.conn = null;
    }
    this.transport = newTransport;
  }
  /**
   * Returns the socket protocol
   *
   * @returns {string}
   */
  protocol() {
    return location.protocol.match(/^https/) ? "wss" : "ws";
  }
  /**
   * The fully qualified socket url
   *
   * @returns {string}
   */
  endPointURL() {
    let uri = Ajax.appendParams(
      Ajax.appendParams(this.endPoint, this.params()),
      { vsn: this.vsn }
    );
    if (uri.charAt(0) !== "/") {
      return uri;
    }
    if (uri.charAt(1) === "/") {
      return `${this.protocol()}:${uri}`;
    }
    return `${this.protocol()}://${location.host}${uri}`;
  }
  /**
   * Disconnects the socket
   *
   * See https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes for valid status codes.
   *
   * @param {Function} callback - Optional callback which is called after socket is disconnected.
   * @param {integer} code - A status code for disconnection (Optional).
   * @param {string} reason - A textual description of the reason to disconnect. (Optional)
   */
  disconnect(callback, code, reason) {
    this.connectClock++;
    this.disconnecting = true;
    this.closeWasClean = true;
    clearTimeout(this.fallbackTimer);
    this.reconnectTimer.reset();
    this.teardown(() => {
      this.disconnecting = false;
      callback && callback();
    }, code, reason);
  }
  /**
   *
   * @param {Object} params - The params to send when connecting, for example `{user_id: userToken}`
   *
   * Passing params to connect is deprecated; pass them in the Socket constructor instead:
   * `new Socket("/socket", {params: {user_id: userToken}})`.
   */
  connect(params2) {
    if (params2) {
      console && console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor");
      this.params = closure(params2);
    }
    if (this.conn && !this.disconnecting) {
      return;
    }
    if (this.longPollFallbackMs && this.transport !== LongPoll) {
      this.connectWithFallback(LongPoll, this.longPollFallbackMs);
    } else {
      this.transportConnect();
    }
  }
  /**
   * Logs the message. Override `this.logger` for specialized logging. noops by default
   * @param {string} kind
   * @param {string} msg
   * @param {Object} data
   */
  log(kind, msg, data) {
    this.logger && this.logger(kind, msg, data);
  }
  /**
   * Returns true if a logger has been set on this socket.
   */
  hasLogger() {
    return this.logger !== null;
  }
  /**
   * Registers callbacks for connection open events
   *
   * @example socket.onOpen(function(){ console.info("the socket was opened") })
   *
   * @param {Function} callback
   */
  onOpen(callback) {
    let ref = this.makeRef();
    this.stateChangeCallbacks.open.push([ref, callback]);
    return ref;
  }
  /**
   * Registers callbacks for connection close events
   * @param {Function} callback
   */
  onClose(callback) {
    let ref = this.makeRef();
    this.stateChangeCallbacks.close.push([ref, callback]);
    return ref;
  }
  /**
   * Registers callbacks for connection error events
   *
   * @example socket.onError(function(error){ alert("An error occurred") })
   *
   * @param {Function} callback
   */
  onError(callback) {
    let ref = this.makeRef();
    this.stateChangeCallbacks.error.push([ref, callback]);
    return ref;
  }
  /**
   * Registers callbacks for connection message events
   * @param {Function} callback
   */
  onMessage(callback) {
    let ref = this.makeRef();
    this.stateChangeCallbacks.message.push([ref, callback]);
    return ref;
  }
  /**
   * Pings the server and invokes the callback with the RTT in milliseconds
   * @param {Function} callback
   *
   * Returns true if the ping was pushed or false if unable to be pushed.
   */
  ping(callback) {
    if (!this.isConnected()) {
      return false;
    }
    let ref = this.makeRef();
    let startTime = Date.now();
    this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref });
    let onMsgRef = this.onMessage((msg) => {
      if (msg.ref === ref) {
        this.off([onMsgRef]);
        callback(Date.now() - startTime);
      }
    });
    return true;
  }
  /**
   * @private
   */
  transportConnect() {
    this.connectClock++;
    this.closeWasClean = false;
    this.conn = new this.transport(this.endPointURL());
    this.conn.binaryType = this.binaryType;
    this.conn.timeout = this.longpollerTimeout;
    this.conn.onopen = () => this.onConnOpen();
    this.conn.onerror = (error) => this.onConnError(error);
    this.conn.onmessage = (event) => this.onConnMessage(event);
    this.conn.onclose = (event) => this.onConnClose(event);
  }
  getSession(key) {
    return this.sessionStore && this.sessionStore.getItem(key);
  }
  storeSession(key, val) {
    this.sessionStore && this.sessionStore.setItem(key, val);
  }
  connectWithFallback(fallbackTransport, fallbackThreshold = 2500) {
    clearTimeout(this.fallbackTimer);
    let established = false;
    let primaryTransport = true;
    let openRef, errorRef;
    let fallback = /* @__PURE__ */ __name((reason) => {
      this.log("transport", `falling back to ${fallbackTransport.name}...`, reason);
      this.off([openRef, errorRef]);
      primaryTransport = false;
      this.replaceTransport(fallbackTransport);
      this.transportConnect();
    }, "fallback");
    if (this.getSession(`phx:fallback:${fallbackTransport.name}`)) {
      return fallback("memorized");
    }
    this.fallbackTimer = setTimeout(fallback, fallbackThreshold);
    errorRef = this.onError((reason) => {
      this.log("transport", "error", reason);
      if (primaryTransport && !established) {
        clearTimeout(this.fallbackTimer);
        fallback(reason);
      }
    });
    this.onOpen(() => {
      established = true;
      if (!primaryTransport) {
        if (!this.primaryPassedHealthCheck) {
          this.storeSession(`phx:fallback:${fallbackTransport.name}`, "true");
        }
        return this.log("transport", `established ${fallbackTransport.name} fallback`);
      }
      clearTimeout(this.fallbackTimer);
      this.fallbackTimer = setTimeout(fallback, fallbackThreshold);
      this.ping((rtt) => {
        this.log("transport", "connected to primary after", rtt);
        this.primaryPassedHealthCheck = true;
        clearTimeout(this.fallbackTimer);
      });
    });
    this.transportConnect();
  }
  clearHeartbeats() {
    clearTimeout(this.heartbeatTimer);
    clearTimeout(this.heartbeatTimeoutTimer);
  }
  onConnOpen() {
    if (this.hasLogger())
      this.log("transport", `${this.transport.name} connected to ${this.endPointURL()}`);
    this.closeWasClean = false;
    this.disconnecting = false;
    this.establishedConnections++;
    this.flushSendBuffer();
    this.reconnectTimer.reset();
    this.resetHeartbeat();
    this.stateChangeCallbacks.open.forEach(([, callback]) => callback());
  }
  /**
   * @private
   */
  heartbeatTimeout() {
    if (this.pendingHeartbeatRef) {
      this.pendingHeartbeatRef = null;
      if (this.hasLogger()) {
        this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
      }
      this.triggerChanError();
      this.closeWasClean = false;
      this.teardown(() => this.reconnectTimer.scheduleTimeout(), WS_CLOSE_NORMAL, "heartbeat timeout");
    }
  }
  resetHeartbeat() {
    if (this.conn && this.conn.skipHeartbeat) {
      return;
    }
    this.pendingHeartbeatRef = null;
    this.clearHeartbeats();
    this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
  }
  teardown(callback, code, reason) {
    if (!this.conn) {
      return callback && callback();
    }
    let connectClock = this.connectClock;
    this.waitForBufferDone(() => {
      if (connectClock !== this.connectClock) {
        return;
      }
      if (this.conn) {
        if (code) {
          this.conn.close(code, reason || "");
        } else {
          this.conn.close();
        }
      }
      this.waitForSocketClosed(() => {
        if (connectClock !== this.connectClock) {
          return;
        }
        if (this.conn) {
          this.conn.onopen = function() {
          };
          this.conn.onerror = function() {
          };
          this.conn.onmessage = function() {
          };
          this.conn.onclose = function() {
          };
          this.conn = null;
        }
        callback && callback();
      });
    });
  }
  waitForBufferDone(callback, tries = 1) {
    if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {
      callback();
      return;
    }
    setTimeout(() => {
      this.waitForBufferDone(callback, tries + 1);
    }, 150 * tries);
  }
  waitForSocketClosed(callback, tries = 1) {
    if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {
      callback();
      return;
    }
    setTimeout(() => {
      this.waitForSocketClosed(callback, tries + 1);
    }, 150 * tries);
  }
  onConnClose(event) {
    let closeCode = event && event.code;
    if (this.hasLogger())
      this.log("transport", "close", event);
    this.triggerChanError();
    this.clearHeartbeats();
    if (!this.closeWasClean && closeCode !== 1e3) {
      this.reconnectTimer.scheduleTimeout();
    }
    this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));
  }
  /**
   * @private
   */
  onConnError(error) {
    if (this.hasLogger())
      this.log("transport", error);
    let transportBefore = this.transport;
    let establishedBefore = this.establishedConnections;
    this.stateChangeCallbacks.error.forEach(([, callback]) => {
      callback(error, transportBefore, establishedBefore);
    });
    if (transportBefore === this.transport || establishedBefore > 0) {
      this.triggerChanError();
    }
  }
  /**
   * @private
   */
  triggerChanError() {
    this.channels.forEach((channel) => {
      if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {
        channel.trigger(CHANNEL_EVENTS.error);
      }
    });
  }
  /**
   * @returns {string}
   */
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case SOCKET_STATES.connecting:
        return "connecting";
      case SOCKET_STATES.open:
        return "open";
      case SOCKET_STATES.closing:
        return "closing";
      default:
        return "closed";
    }
  }
  /**
   * @returns {boolean}
   */
  isConnected() {
    return this.connectionState() === "open";
  }
  /**
   * @private
   *
   * @param {Channel}
   */
  remove(channel) {
    this.off(channel.stateChangeRefs);
    this.channels = this.channels.filter((c) => c !== channel);
  }
  /**
   * Removes `onOpen`, `onClose`, `onError,` and `onMessage` registrations.
   *
   * @param {refs} - list of refs returned by calls to
   *                 `onOpen`, `onClose`, `onError,` and `onMessage`
   */
  off(refs) {
    for (let key in this.stateChangeCallbacks) {
      this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {
        return refs.indexOf(ref) === -1;
      });
    }
  }
  /**
   * Initiates a new channel for the given topic
   *
   * @param {string} topic
   * @param {Object} chanParams - Parameters for the channel
   * @returns {Channel}
   */
  channel(topic, chanParams = {}) {
    let chan = new Channel(topic, chanParams, this);
    this.channels.push(chan);
    return chan;
  }
  /**
   * @param {Object} data
   */
  push(data) {
    if (this.hasLogger()) {
      let { topic, event, payload, ref, join_ref } = data;
      this.log("push", `${topic} ${event} (${join_ref}, ${ref})`, payload);
    }
    if (this.isConnected()) {
      this.encode(data, (result) => this.conn.send(result));
    } else {
      this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));
    }
  }
  /**
   * Return the next message ref, accounting for overflows
   * @returns {string}
   */
  makeRef() {
    let newRef = this.ref + 1;
    if (newRef === this.ref) {
      this.ref = 0;
    } else {
      this.ref = newRef;
    }
    return this.ref.toString();
  }
  sendHeartbeat() {
    if (this.pendingHeartbeatRef && !this.isConnected()) {
      return;
    }
    this.pendingHeartbeatRef = this.makeRef();
    this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef });
    this.heartbeatTimeoutTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);
  }
  flushSendBuffer() {
    if (this.isConnected() && this.sendBuffer.length > 0) {
      this.sendBuffer.forEach((callback) => callback());
      this.sendBuffer = [];
    }
  }
  onConnMessage(rawMessage) {
    this.decode(rawMessage.data, (msg) => {
      let { topic, event, payload, ref, join_ref } = msg;
      if (ref && ref === this.pendingHeartbeatRef) {
        this.clearHeartbeats();
        this.pendingHeartbeatRef = null;
        this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
      }
      if (this.hasLogger())
        this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
      for (let i = 0; i < this.channels.length; i++) {
        const channel = this.channels[i];
        if (!channel.isMember(topic, event, payload, join_ref)) {
          continue;
        }
        channel.trigger(event, payload, ref, join_ref);
      }
      for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {
        let [, callback] = this.stateChangeCallbacks.message[i];
        callback(msg);
      }
    });
  }
  leaveOpenTopic(topic) {
    let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));
    if (dupChannel) {
      if (this.hasLogger())
        this.log("transport", `leaving duplicate topic "${topic}"`);
      dupChannel.leave();
    }
  }
}, __name(_a7, "Socket"), _a7);

// src/util/urls.ts
init_process_shim();
var import_obsidian5 = require("obsidian");
function noteURL(team, collection, note) {
  return `${BASE_HTTP_URL}/t/${team.short_id}/c/${collection.short_id}/n/${note.id}`;
}
__name(noteURL, "noteURL");
function copyNoteURLToClipboard(team, collection, note, notifiying = true) {
  const url = noteURL(team, collection, note);
  navigator.clipboard.writeText(url);
  if (notifiying) {
    new import_obsidian5.Notice(intl.note.urlCopied());
  }
}
__name(copyNoteURLToClipboard, "copyNoteURLToClipboard");
function openURLExternally(app, url) {
  const plugin = app.internalPlugins.plugins.webviewer;
  if (plugin && plugin.enabled && typeof plugin.instance.openUrlExternally === "function") {
    plugin.instance.openUrlExternally(url);
  } else {
    window.open(url, "_external");
  }
}
__name(openURLExternally, "openURLExternally");

// node_modules/uuid/dist/esm-browser/index.js
init_process_shim();

// node_modules/uuid/dist/esm-browser/stringify.js
init_process_shim();
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
__name(unsafeStringify, "unsafeStringify");

// node_modules/uuid/dist/esm-browser/rng.js
init_process_shim();
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}
__name(rng, "rng");

// node_modules/uuid/dist/esm-browser/v4.js
init_process_shim();

// node_modules/uuid/dist/esm-browser/native.js
init_process_shim();
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  var _a9, _b2, _c;
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = (_c = (_b2 = options.random) != null ? _b2 : (_a9 = options.rng) == null ? void 0 : _a9.call(options)) != null ? _c : rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
__name(v4, "v4");
var v4_default = v4;

// src/services/account/AccountService.ts
var TABLE2 = ",id,email,name";
var ACCOUNT_ID = "screen.garden:account";
var CACHED_APP_TOKEN = "screengarden:obsidian:app-auth-token";
var log4 = (0, import_debug5.default)("screen.garden:account");
var _AccountService = class _AccountService extends Service {
  constructor(plugin) {
    super(plugin);
    this._account = null;
    this.notifiedToSignIn = false;
    this.handleAppAuthenticated = /* @__PURE__ */ __name(async ({ token }) => {
      if (!token) return;
      log4("authenticated, setting token");
      await this.plugin.settings.updateConfig({ token, needsReauth: false });
      this.endAuth();
    }, "handleAppAuthenticated");
    this.observable = liveQuery(
      () => this.db.account.get(ACCOUNT_ID)
    );
    this.subscription = this.observable.subscribe((account) => {
      if (account != null) {
        this._account = account;
      } else {
        this._account = null;
        if (!this.notifiedToSignIn) {
          this.notifiedToSignIn = true;
          new import_obsidian6.Notice(intl.home.reauthNotice());
        }
      }
    });
    const poll = timer(0, (0, import_ms.default)("1 hour"));
    this.pollSubscription = combineLatest([
      poll,
      this.plugin.networkStatus.observable,
      this.plugin.api.observable
    ]).subscribe({
      next: /* @__PURE__ */ __name(async ([, networkStatus, api]) => {
        if (api == null) {
          log4("clearing stored account");
          await this.db.account.delete(ACCOUNT_ID);
          return;
        }
        if (networkStatus === "online" && api != null) {
          log4("fetching account");
          try {
            const { data: fetchedAccount } = await api.get("/me");
            if (!isEqual_default(fetchedAccount, this._account)) {
              await this.db.account.put(fetchedAccount, ACCOUNT_ID);
            }
          } catch (error) {
            if (this._account && "status" in error && error.status === 401) {
              this.flagNeedsReauth();
            } else {
              log4("failed to fetch account", error);
            }
          }
        }
      }, "next")
    });
  }
  get() {
    return this._account;
  }
  async onunload() {
    this.subscription.unsubscribe();
    this.pollSubscription.unsubscribe();
  }
  // Get or mint and cache a token to identify this obsidian client during an auth poll.
  // Storing it locally handles the case where someone begins browser auth and restarts Obsidian in the meantime.
  getClientToken() {
    const cachedToken = window.localStorage.getItem(CACHED_APP_TOKEN);
    if (cachedToken) return cachedToken;
    const newToken = v4_default();
    window.localStorage.setItem(CACHED_APP_TOKEN, newToken);
    return newToken;
  }
  async startAuth(entrypoint, withURL) {
    this.endAuth();
    log4("starting auth");
    const token = this.getClientToken();
    this.authSocket = new Socket(`${BASE_WS_URL}/auth/socket`, {
      params: {
        token,
        app: "obsidian"
      }
    });
    const authURL = this.authURL(entrypoint, token);
    openURLExternally(this.plugin.app, authURL);
    withURL(authURL);
    await new Promise((resolve) => {
      var _a9, _b2;
      (_a9 = this.authSocket) == null ? void 0 : _a9.onOpen(resolve);
      (_b2 = this.authSocket) == null ? void 0 : _b2.connect();
    });
    this.authChannel = this.authSocket.channel(`app_auth:${token}`);
    this.authChannel.join().receive("ok", () => {
      var _a9;
      log4(`app_auth:${token} joined`);
      (_a9 = this.authChannel) == null ? void 0 : _a9.on("authenticated", this.handleAppAuthenticated);
    }).receive("error", (msg) => {
      log4(`app_auth:${token} rejected`, msg);
      new import_obsidian6.Notice(intl.settingsTab.authError());
      this.endAuth();
    });
  }
  endAuth() {
    var _a9, _b2;
    log4("ending auth");
    (_a9 = this.authChannel) == null ? void 0 : _a9.leave();
    this.authChannel = null;
    (_b2 = this.authSocket) == null ? void 0 : _b2.disconnect();
    this.authSocket = null;
  }
  authURL(entrypoint, token) {
    return entrypoint === "login" ? `${BASE_HTTP_URL}/users/log_in?app=obsidian&token=${token}` : `${BASE_HTTP_URL}/users/register?app=obsidian&token=${token}`;
  }
  async logout() {
    await this.plugin.settings.updateConfig({
      token: null,
      needsReauth: false
    });
    await this.db.account.delete(ACCOUNT_ID);
  }
  async flagNeedsReauth() {
    var _a9, _b2;
    const neededReauth = (_b2 = (_a9 = this.plugin.settings.config) == null ? void 0 : _a9.needsReauth) != null ? _b2 : false;
    if (!neededReauth) {
      await this.plugin.settings.updateConfig({ needsReauth: true });
      new import_obsidian6.Notice(intl.home.reauthNotice());
    }
  }
};
__name(_AccountService, "AccountService");
var AccountService = _AccountService;

// src/services/api/index.ts
init_process_shim();

// src/services/api/ApiService.ts
init_process_shim();
var import_debug6 = __toESM(require_browser2());
var log5 = (0, import_debug6.default)("screen.garden:api");
var _ApiService = class _ApiService extends Service {
  constructor(plugin) {
    super(plugin);
    this.client = null;
    log5("initializing");
    this.observable = new Subject();
    this.tokenSubscription = this.plugin.settings.tokenObservable.subscribe({
      next: /* @__PURE__ */ __name((token) => {
        if (token) {
          log5("new token, updating client");
          this.client = this.create(token);
        } else {
          log5("no token, nulling out client");
          this.client = null;
        }
        this.observable.next(this.client);
      }, "next")
    });
  }
  async onunload() {
    this.tokenSubscription.unsubscribe();
  }
  create(token) {
    return axios_default.create({
      baseURL: `${BASE_HTTP_URL}/api`,
      headers: {
        "X-ScreenGarden-Client": this.plugin.manifest.id,
        "X-ScreenGarden-Client-Version": this.plugin.manifest.version,
        Authorization: token ? `Bearer ${token}` : void 0
      }
    });
  }
};
__name(_ApiService, "ApiService");
var ApiService = _ApiService;

// src/services/collections/index.ts
init_process_shim();

// src/services/collections/CollectionsService.ts
init_process_shim();

// src/services/collections/CollectionHandler.ts
init_process_shim();

// src/services/liveDocuments/LiveDocumentService.ts
init_process_shim();

// src/services/liveDocuments/HandlerPool.ts
init_process_shim();
var import_debug7 = __toESM(require_browser2());

// src/util/OrderedSet.ts
init_process_shim();
var _OrderedSet = class _OrderedSet {
  constructor(iterable) {
    this._set = new Set(iterable);
  }
  push(value) {
    this._set.add(value);
  }
  pop() {
    const v = this._set.values().next().value;
    if (v) {
      this._set.delete(v);
      return v;
    }
    return null;
  }
  get size() {
    return this._set.size;
  }
  clear() {
    this._set.clear();
  }
  delete(value) {
    return this._set.delete(value);
  }
};
__name(_OrderedSet, "OrderedSet");
var OrderedSet = _OrderedSet;

// src/services/liveDocuments/HandlerPool.ts
var log6 = (0, import_debug7.default)("screen.garden:liveDocuments:pool");
function overrides(left, right) {
  return left === "required" || left === "concurrent" && right === "background";
}
__name(overrides, "overrides");
var DEFAULT_CONCURRENT_TIMEOUT = 3e4;
var _HandlerPool = class _HandlerPool {
  constructor(plugin, _poolSize) {
    this.plugin = plugin;
    this._poolSize = _poolSize;
    /**
     * Emits when a handler is created or deleted.
     */
    this.handlerChanges = new Subject();
    this.queueSize$ = new BehaviorSubject({
      concurrent: 0,
      background: 0
    });
    this.openHandlers$ = new BehaviorSubject({
      required: 0,
      concurrent: 0,
      background: 0
    });
    this.poolSize$ = new BehaviorSubject(0);
    // Simplest just to statically create queues per priority.
    this.backgroundQueue = new OrderedSet();
    this.concurrentQueue = new OrderedSet();
    this.handlerSpecs = /* @__PURE__ */ new Map();
    this.timeouts = /* @__PURE__ */ new Map();
    // Map of live document IDs to handlers.
    // Only populated with a handler when it has finished loading its corresponding ydoc.
    this.handlers = /* @__PURE__ */ new Map();
    // A set of live document IDs corresponding to handlers that are starting but not yet ready.
    // Used to prevent handler creation races when documents rapidly change such that handlers
    // are created but not yet ready.
    this.startingHandlerIDs = /* @__PURE__ */ new Set();
    this.stats = combineLatest([
      this.openHandlers$.pipe(
        distinctUntilChanged((a, b) => {
          return a.required === b.required && a.concurrent === b.concurrent && a.background === b.background;
        })
      ),
      this.queueSize$.pipe(
        distinctUntilChanged((a, b) => {
          return a.concurrent === b.concurrent && a.background === b.background;
        })
      ),
      this.poolSize$.pipe(distinctUntilChanged())
    ]).pipe(map(([open, pending, size2]) => ({ open, pending, size: size2 })));
  }
  /**
   * Close all handlers and clear all queues.
   *
   * Does not emit handler or queue change events.
   */
  clear() {
    log6("clear");
    this.backgroundQueue.clear();
    this.concurrentQueue.clear();
    for (const handler of this.handlers.values()) {
      handler.close();
    }
    this.handlers.clear();
    this.startingHandlerIDs.clear();
    this.handlerSpecs.clear();
    for (const timeout of this.timeouts.values()) {
      window.clearTimeout(timeout);
    }
    this.timeouts.clear();
    this.queueSize$.complete();
    this.openHandlers$.complete();
    this.poolSize$.complete();
  }
  /**
   * Requests that a document handler be opened. The handler will be opened according to its priority.
   *
   * Requesting a handler at a higher priority for a document that is already requested will upgrade
   * that document's priority.
   */
  schedule(spec) {
    log6("scheduling", spec);
    const existingSpec = this.handlerSpecs.get(spec.id);
    if (!existingSpec || overrides(spec.priority, existingSpec.priority)) {
      this.handlerSpecs.set(spec.id, spec);
    }
    if (spec.priority === "concurrent" && (this.handlers.has(spec.id) || this.startingHandlerIDs.has(spec.id))) {
      this.touchTimeout(spec.id);
    }
    const handler = this.handlers.get(spec.id);
    if (handler) {
      log6(`handler for ${spec.id} already running`);
      return handler;
    }
    if (this.startingHandlerIDs.has(spec.id)) return null;
    if (spec.priority === "required" || this.handlerCount < this.poolSize) {
      this.clearTimeout(spec.id);
      this.createHandler(spec);
    } else {
      const queue = spec.priority === "background" ? this.backgroundQueue : this.concurrentQueue;
      queue.push(spec.id);
      log6("queued %s", spec.id);
      this.emitQueueSize();
    }
    return null;
  }
  /**
   * Downgrades a handler's priority. If the handler is already at or below the new priority,
   * this is a no-op. If the handler is running and the new priority implies a timeout,
   * the timeout will begin.
   * @param id LiveDocument ID for handler.
   * @param priority New priority for handler.
   */
  downgrade(id2, priority) {
    const runningHandler = this.handlers.get(id2);
    if (runningHandler == null ? void 0 : runningHandler.yDocAcquired) {
      log6("cannot downgrade handler %s, ydoc is locked", id2);
      return;
    }
    log6("downgrading %s to %s", id2, priority);
    const existingSpec = this.handlerSpecs.get(id2);
    if (!existingSpec) return;
    if (overrides(priority, existingSpec.priority)) return;
    this.handlerSpecs.set(id2, { ...existingSpec, priority });
    if (priority === "concurrent" && runningHandler) {
      this.touchTimeout(id2);
    }
    this.emitOpenHandlers();
  }
  /**
   * Returns a handler for a live document ID if it exists.
   * @param id LiveDocument ID for handler.
   * @returns DocumentHandler, if one is running.
   */
  get(id2) {
    var _a9;
    return (_a9 = this.handlers.get(id2)) != null ? _a9 : null;
  }
  /**
   * Deletes the a handler if running and dequeues it if not.
   * Deleting a handler will also cancel any possible idle timeouts for that handler.
   * @param id LiveDocument ID for handler.
   */
  delete(id2) {
    log6("deleting %s", id2);
    this.deleteHandler(id2);
    const existed = this.backgroundQueue.delete(id2) || this.concurrentQueue.delete(id2);
    if (existed) {
      this.emitQueueSize();
    }
  }
  get poolSize() {
    return this._poolSize;
  }
  set poolSize(size2) {
    this._poolSize = size2;
    this.poolSize$.next(size2);
  }
  get handlerCount() {
    return this.handlers.size + this.startingHandlerIDs.size;
  }
  // Get the next live document ID from the queue; prefers concurrent over background.
  pop() {
    if (this.concurrentQueue.size > 0) {
      return this.concurrentQueue.pop();
    } else if (this.backgroundQueue.size > 0) {
      return this.backgroundQueue.pop();
    }
    return null;
  }
  // Get the next live document ID from the queue and, if present, create a handler for it.
  next() {
    if (this.handlerCount >= this.poolSize) return;
    const nextId = this.pop();
    if (!nextId) return;
    this.emitQueueSize();
    const spec = this.handlerSpecs.get(nextId);
    if (!spec) return;
    this.createHandler(spec);
  }
  createHandler({ handlerClass, id: id2, path, collectionId }) {
    log6("starting handler %s", id2);
    this.startingHandlerIDs.add(id2);
    const handler = new handlerClass(
      this.plugin,
      id2,
      collectionId,
      () => {
        log6("finished loading handler %s, publishing availability", id2);
        if (handler) {
          this.handlers.set(id2, handler);
          this.emitOpenHandlers();
          this.startingHandlerIDs.delete(id2);
          this.handlerChanges.next({
            id: id2,
            path: path != null ? path : null,
            deleted: false
          });
        }
      },
      {
        afterSync: /* @__PURE__ */ __name(async () => {
          this.onLifecycleChange(id2);
        }, "afterSync"),
        onUpdate: /* @__PURE__ */ __name(async () => {
          this.onLifecycleChange(id2);
        }, "onUpdate")
      }
    );
    if (!handler) {
      log6("failed to create handler for %s", id2);
      this.startingHandlerIDs.delete(id2);
      return;
    }
  }
  // Delete a handler.
  // NOTE: Will start a new handler if there is demand.
  deleteHandler(id2) {
    const handler = this.handlers.get(id2);
    if (!handler) return;
    const path = handler.path;
    log6("stopping handler", this.handlerSpecs.get(id2));
    handler.close();
    this.handlers.delete(handler.id);
    this.handlerSpecs.delete(id2);
    this.clearTimeout(id2);
    this.handlerChanges.next({ id: id2, path, deleted: true });
    this.emitOpenHandlers();
    this.next();
  }
  onLifecycleChange(id2) {
    const spec = this.handlerSpecs.get(id2);
    if (!spec || spec.priority === "required") return;
    if (spec.priority === "background") {
      this.deleteHandler(id2);
    } else {
      this.touchTimeout(id2);
    }
  }
  touchTimeout(id2) {
    if (!this.handlerSpecs.has(id2)) return;
    if (this.timeouts.has(id2)) {
      window.clearTimeout(this.timeouts.get(id2));
    }
    this.timeouts.set(
      id2,
      window.setTimeout(() => {
        const spec = this.handlerSpecs.get(id2);
        if (!spec || spec.priority !== "concurrent") return;
        log6("timeout for", spec);
        this.deleteHandler(id2);
      }, DEFAULT_CONCURRENT_TIMEOUT)
    );
  }
  clearTimeout(id2) {
    if (!this.timeouts.has(id2)) return;
    window.clearTimeout(this.timeouts.get(id2));
    this.timeouts.delete(id2);
  }
  emitQueueSize() {
    this.queueSize$.next({
      concurrent: this.concurrentQueue.size,
      background: this.backgroundQueue.size
    });
  }
  emitOpenHandlers() {
    const openHandlers = {
      required: 0,
      concurrent: 0,
      background: 0
    };
    for (const id2 of this.handlers.keys()) {
      const spec = this.handlerSpecs.get(id2);
      if (spec == null ? void 0 : spec.priority) {
        openHandlers[spec.priority]++;
      }
    }
    this.openHandlers$.next(openHandlers);
  }
};
__name(_HandlerPool, "HandlerPool");
var HandlerPool = _HandlerPool;

// src/services/liveDocuments/notes/NoteHandler.ts
init_process_shim();

// src/services/liveDocuments/LiveDocumentHandler.ts
init_process_shim();

// node_modules/async-mutex/index.mjs
init_process_shim();
var E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
var E_ALREADY_LOCKED = new Error("mutex already locked");
var E_CANCELED = new Error("request for lock canceled");
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _Semaphore = class _Semaphore {
  constructor(_value, _cancelError = E_CANCELED) {
    this._value = _value;
    this._cancelError = _cancelError;
    this._queue = [];
    this._weightedWaiters = [];
  }
  acquire(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    return new Promise((resolve, reject) => {
      const task = { resolve, reject, weight, priority };
      const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);
      if (i === -1 && weight <= this._value) {
        this._dispatchItem(task);
      } else {
        this._queue.splice(i + 1, 0, task);
      }
    });
  }
  runExclusive(callback_1) {
    return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {
      const [value, release] = yield this.acquire(weight, priority);
      try {
        return yield callback(value);
      } finally {
        release();
      }
    });
  }
  waitForUnlock(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    if (this._couldLockImmediately(weight, priority)) {
      return Promise.resolve();
    } else {
      return new Promise((resolve) => {
        if (!this._weightedWaiters[weight - 1])
          this._weightedWaiters[weight - 1] = [];
        insertSorted(this._weightedWaiters[weight - 1], { resolve, priority });
      });
    }
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(value) {
    this._value = value;
    this._dispatchQueue();
  }
  release(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    this._value += weight;
    this._dispatchQueue();
  }
  cancel() {
    this._queue.forEach((entry) => entry.reject(this._cancelError));
    this._queue = [];
  }
  _dispatchQueue() {
    this._drainUnlockWaiters();
    while (this._queue.length > 0 && this._queue[0].weight <= this._value) {
      this._dispatchItem(this._queue.shift());
      this._drainUnlockWaiters();
    }
  }
  _dispatchItem(item) {
    const previousValue = this._value;
    this._value -= item.weight;
    item.resolve([previousValue, this._newReleaser(item.weight)]);
  }
  _newReleaser(weight) {
    let called = false;
    return () => {
      if (called)
        return;
      called = true;
      this.release(weight);
    };
  }
  _drainUnlockWaiters() {
    if (this._queue.length === 0) {
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        waiters.forEach((waiter) => waiter.resolve());
        this._weightedWaiters[weight - 1] = [];
      }
    } else {
      const queuedPriority = this._queue[0].priority;
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);
        (i === -1 ? waiters : waiters.splice(0, i)).forEach((waiter) => waiter.resolve());
      }
    }
  }
  _couldLockImmediately(weight, priority) {
    return (this._queue.length === 0 || this._queue[0].priority < priority) && weight <= this._value;
  }
};
__name(_Semaphore, "Semaphore");
var Semaphore = _Semaphore;
function insertSorted(a, v) {
  const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);
  a.splice(i + 1, 0, v);
}
__name(insertSorted, "insertSorted");
function findIndexFromEnd(a, predicate) {
  for (let i = a.length - 1; i >= 0; i--) {
    if (predicate(a[i])) {
      return i;
    }
  }
  return -1;
}
__name(findIndexFromEnd, "findIndexFromEnd");
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _Mutex = class _Mutex {
  constructor(cancelError) {
    this._semaphore = new Semaphore(1, cancelError);
  }
  acquire() {
    return __awaiter$1(this, arguments, void 0, function* (priority = 0) {
      const [, releaser] = yield this._semaphore.acquire(1, priority);
      return releaser;
    });
  }
  runExclusive(callback, priority = 0) {
    return this._semaphore.runExclusive(() => callback(), 1, priority);
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock(priority = 0) {
    return this._semaphore.waitForUnlock(1, priority);
  }
  release() {
    if (this._semaphore.isLocked())
      this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
};
__name(_Mutex, "Mutex");
var Mutex = _Mutex;
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {
  return {
    acquire: /* @__PURE__ */ __name((weightOrPriority, priority) => {
      let weight;
      if (isSemaphore(sync)) {
        weight = weightOrPriority;
      } else {
        weight = void 0;
        priority = weightOrPriority;
      }
      if (weight !== void 0 && weight <= 0) {
        throw new Error(`invalid weight ${weight}: must be positive`);
      }
      return new Promise((resolve, reject) => __awaiter2(this, void 0, void 0, function* () {
        let isTimeout = false;
        const handle = setTimeout(() => {
          isTimeout = true;
          reject(timeoutError);
        }, timeout);
        try {
          const ticket = yield isSemaphore(sync) ? sync.acquire(weight, priority) : sync.acquire(priority);
          if (isTimeout) {
            const release = Array.isArray(ticket) ? ticket[1] : ticket;
            release();
          } else {
            clearTimeout(handle);
            resolve(ticket);
          }
        } catch (e) {
          if (!isTimeout) {
            clearTimeout(handle);
            reject(e);
          }
        }
      }));
    }, "acquire"),
    runExclusive(callback, weight, priority) {
      return __awaiter2(this, void 0, void 0, function* () {
        let release = /* @__PURE__ */ __name(() => void 0, "release");
        try {
          const ticket = yield this.acquire(weight, priority);
          if (Array.isArray(ticket)) {
            release = ticket[1];
            return yield callback(ticket[0]);
          } else {
            release = ticket;
            return yield callback();
          }
        } finally {
          release();
        }
      });
    },
    release(weight) {
      sync.release(weight);
    },
    cancel() {
      return sync.cancel();
    },
    waitForUnlock: /* @__PURE__ */ __name((weightOrPriority, priority) => {
      let weight;
      if (isSemaphore(sync)) {
        weight = weightOrPriority;
      } else {
        weight = void 0;
        priority = weightOrPriority;
      }
      if (weight !== void 0 && weight <= 0) {
        throw new Error(`invalid weight ${weight}: must be positive`);
      }
      return new Promise((resolve, reject) => {
        const handle = setTimeout(() => reject(timeoutError), timeout);
        (isSemaphore(sync) ? sync.waitForUnlock(weight, priority) : sync.waitForUnlock(priority)).then(() => {
          clearTimeout(handle);
          resolve();
        });
      });
    }, "waitForUnlock"),
    isLocked: /* @__PURE__ */ __name(() => sync.isLocked(), "isLocked"),
    getValue: /* @__PURE__ */ __name(() => sync.getValue(), "getValue"),
    setValue: /* @__PURE__ */ __name((value) => sync.setValue(value), "setValue")
  };
}
__name(withTimeout, "withTimeout");
function isSemaphore(sync) {
  return sync.getValue !== void 0;
}
__name(isSemaphore, "isSemaphore");
function tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {
  return withTimeout(sync, 0, alreadyAcquiredError);
}
__name(tryAcquire, "tryAcquire");

// src/services/liveDocuments/LiveDocumentHandler.ts
var import_debug8 = __toESM(require_browser2());
var import_obsidian8 = require("obsidian");

// src/util/path.ts
init_process_shim();
var import_obsidian7 = require("obsidian");
var isPathOrFile = /* @__PURE__ */ __name((test2) => typeof test2 === "string" || typeof test2 === "object" && test2 !== null && "path" in test2, "isPathOrFile");
var getPath = /* @__PURE__ */ __name((pathOrFile) => typeof pathOrFile === "string" ? pathOrFile : pathOrFile.path, "getPath");
var getTitle = /* @__PURE__ */ __name((pathOrFile) => {
  if (pathOrFile instanceof import_obsidian7.TAbstractFile) {
    return pathOrFile.name;
  }
  const lastComponent = getPath(pathOrFile).split("/").last();
  if (!lastComponent) return "Untitled";
  const i = lastComponent.lastIndexOf(".");
  if (i < 0) return lastComponent;
  return lastComponent.slice(0, i);
}, "getTitle");
var pathContains = /* @__PURE__ */ __name((path, subpath) => {
  const p = getPath(subpath);
  if (path === "/") {
    return !p.startsWith("..");
  }
  return p.startsWith(`${path}/`) || p === path;
}, "pathContains");

// src/services/liveDocuments/LiveDocumentHandler.ts
var _LiveDocumentHandler = class _LiveDocumentHandler {
  constructor(plugin, id2, collectionId, onLoad, lifecycle, logPrefix) {
    this.plugin = plugin;
    this.id = id2;
    this.collectionId = collectionId;
    this.onLoad = onLoad;
    this.log = (0, import_debug8.default)(`screen.garden:${logPrefix}:${id2}`);
    this.log("init");
    this.lifecycle = {
      ...lifecycle,
      onJoin: /* @__PURE__ */ __name((_dc, joinReply) => {
        if (lifecycle.onJoin) lifecycle.onJoin(_dc, joinReply);
        this.handleDocJoin(joinReply);
      }, "onJoin")
    };
    this.mutex = new Mutex();
    this.setupPathSubscription();
    this.onload();
  }
  setupPathSubscription() {
    const query = liveQuery(() => this.plugin.db.liveDocuments.get(this.id));
    this.pathSubscription = query.subscribe({
      next: /* @__PURE__ */ __name((document2) => {
        if (!document2) return;
        this.path = document2.path;
      }, "next")
    });
  }
  /**
   * Handles document join events, including path changes and promotions.
   * Subclasses can override to handle document-specific join logic.
   */
  handleDocJoin(joinReply) {
    this.plugin.db.pendingLiveDocuments.delete(this.id);
    this.plugin.db.liveDocuments.update(this.id, {
      needs_catchup: 0 /* No */
    });
    if (joinReply && "new_path" in joinReply) {
      this.handlePathChange(joinReply.new_path);
    }
  }
  /**
   * Handles path changes when a document is promoted or renamed.
   */
  handlePathChange(newPath) {
    this.log("path of %s changed on promotion to %s", this.id, newPath);
    const fullPath = this.plugin.collections.addPathPrefixForCollection(
      this.collectionId,
      newPath
    );
    if (!fullPath) return;
    const oldPath = this.path;
    this.path = fullPath;
    this.updatePathInDatabase(this.path);
    this.notifyPathChange(oldPath, this.path);
  }
  updatePathInDatabase(newPath) {
    this.plugin.db.liveDocuments.update(this.id, {
      path: newPath,
      title: getTitle(newPath)
    });
  }
  notifyPathChange(oldPath, newPath) {
    new import_obsidian8.Notice(intl.note.renamedRemotely({ old: oldPath, new: newPath }), 2e3);
  }
  async onload() {
    await this.hydrateYDocFromDisk();
    this.doc = await this.plugin.docs.getOrCreateAndLoad(
      this.id,
      this.getDocContext(),
      this.lifecycle
    );
    await this.onDocumentLoaded();
    this.log("loaded doc %s", this.doc.id);
    this.onLoad();
  }
  async close() {
    var _a9;
    await this.beforeClose();
    (_a9 = this.pathSubscription) == null ? void 0 : _a9.unsubscribe();
    this.plugin.docs.unload(this.doc);
  }
  /**
   * Called before the document is closed.
   * Subclasses can override to clean up their specific resources.
   */
  async beforeClose() {
  }
  async getYDocHandle() {
    try {
      const release = await tryAcquire(this.mutex).acquire();
      return {
        release: /* @__PURE__ */ __name(() => {
          release();
          this.handleHandleRelease();
        }, "release"),
        ydoc: this.doc.ydoc
      };
    } catch (e) {
      return null;
    }
  }
  get yDocAcquired() {
    return this.mutex.isLocked();
  }
  updatePresence(meta) {
    this.doc.channel.pushPresence(meta);
  }
  listPresences() {
    return this.doc.channel.listPresences("userID");
  }
  /**
   * Called when a document handle is released.
   * Subclasses can override to perform type-specific cleanup.
   */
  handleHandleRelease() {
    this.plugin.liveDocuments.downgrade(this.id, "concurrent");
  }
};
__name(_LiveDocumentHandler, "LiveDocumentHandler");
var LiveDocumentHandler = _LiveDocumentHandler;

// node_modules/@dmsnell/diff-match-patch/index.js
init_process_shim();
var diff_match_patch = /* @__PURE__ */ __name(function() {
  this.Diff_Timeout = 1;
  this.Diff_EditCost = 4;
  this.Match_Threshold = 0.5;
  this.Match_Distance = 1e3;
  this.Patch_DeleteThreshold = 0.5;
  this.Patch_Margin = 4;
  this.Match_MaxBits = 32;
}, "diff_match_patch");
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;
diff_match_patch.Diff = function(op, text2) {
  this[0] = op;
  this[1] = text2;
};
diff_match_patch.Diff.prototype.length = 2;
diff_match_patch.Diff.prototype.toString = function() {
  return this[0] + "," + this[1];
};
diff_match_patch.Diff.prototype[Symbol.iterator] = function* () {
  yield this[0];
  yield this[1];
};
diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines, opt_deadline) {
  if (typeof opt_deadline == "undefined") {
    if (this.Diff_Timeout <= 0) {
      opt_deadline = Number.MAX_VALUE;
    } else {
      opt_deadline = (/* @__PURE__ */ new Date()).getTime() + this.Diff_Timeout * 1e3;
    }
  }
  var deadline = opt_deadline;
  if (text1 == null || text2 == null) {
    throw new Error("Null input. (diff_main)");
  }
  if (text1 == text2) {
    if (text1) {
      return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];
    }
    return [];
  }
  if (typeof opt_checklines == "undefined") {
    opt_checklines = true;
  }
  var checklines = opt_checklines;
  var commonlength = this.diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);
  commonlength = this.diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);
  var diffs = this.diff_compute_(text1, text2, checklines, deadline);
  if (commonprefix) {
    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));
  }
  if (commonsuffix) {
    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));
  }
  this.diff_cleanupMerge(diffs);
  return diffs;
};
diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines, deadline) {
  var diffs;
  if (!text1) {
    return [new diff_match_patch.Diff(DIFF_INSERT, text2)];
  }
  if (!text2) {
    return [new diff_match_patch.Diff(DIFF_DELETE, text1)];
  }
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    diffs = [
      new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)),
      new diff_match_patch.Diff(DIFF_EQUAL, shorttext),
      new diff_match_patch.Diff(
        DIFF_INSERT,
        longtext.substring(i + shorttext.length)
      )
    ];
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }
  if (shorttext.length == 1) {
    return [
      new diff_match_patch.Diff(DIFF_DELETE, text1),
      new diff_match_patch.Diff(DIFF_INSERT, text2)
    ];
  }
  var hm = this.diff_halfMatch_(text1, text2);
  if (hm) {
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
    return diffs_a.concat(
      [new diff_match_patch.Diff(DIFF_EQUAL, mid_common)],
      diffs_b
    );
  }
  if (checklines && text1.length > 100 && text2.length > 100) {
    return this.diff_lineMode_(text1, text2, deadline);
  }
  return this.diff_bisect_(text1, text2, deadline);
};
diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
  var a = this.diff_linesToChars_(text1, text2);
  text1 = a.chars1;
  text2 = a.chars2;
  var linearray = a.lineArray;
  var diffs = this.diff_main(text1, text2, false, deadline);
  this.diff_charsToLines_(diffs, linearray);
  this.diff_cleanupSemantic(diffs);
  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ""));
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = "";
  var text_insert = "";
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        if (count_delete >= 1 && count_insert >= 1) {
          diffs.splice(
            pointer - count_delete - count_insert,
            count_delete + count_insert
          );
          pointer = pointer - count_delete - count_insert;
          var subDiff = this.diff_main(text_delete, text_insert, false, deadline);
          for (var j = subDiff.length - 1; j >= 0; j--) {
            diffs.splice(pointer, 0, subDiff[j]);
          }
          pointer = pointer + subDiff.length;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = "";
        text_insert = "";
        break;
    }
    pointer++;
  }
  diffs.pop();
  return diffs;
};
diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta = text1_length - text2_length;
  var front = delta % 2 != 0;
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d2 = 0; d2 < max_d; d2++) {
    if ((/* @__PURE__ */ new Date()).getTime() > deadline) {
      break;
    }
    for (var k1 = -d2 + k1start; k1 <= d2 - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 == -d2 || k1 != d2 && v1[k1_offset - 1] < v1[k1_offset + 1]) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        k1end += 2;
      } else if (y1 > text2_length) {
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
    for (var k2 = -d2 + k2start; k2 <= d2 - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 == -d2 || k2 != d2 && v2[k2_offset - 1] < v2[k2_offset + 1]) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        k2end += 2;
      } else if (y2 > text2_length) {
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          x2 = text1_length - x2;
          if (x1 >= x2) {
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
  }
  return [
    new diff_match_patch.Diff(DIFF_DELETE, text1),
    new diff_match_patch.Diff(DIFF_INSERT, text2)
  ];
};
diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y, deadline) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);
  var diffs = this.diff_main(text1a, text2a, false, deadline);
  var diffsb = this.diff_main(text1b, text2b, false, deadline);
  return diffs.concat(diffsb);
};
diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
  var lineArray = [];
  var lineHash = {};
  lineArray[0] = "";
  function diff_linesToCharsMunge_(text3) {
    var chars = "";
    var lineStart = 0;
    var lineEnd = -1;
    var lineArrayLength = lineArray.length;
    while (lineEnd < text3.length - 1) {
      lineEnd = text3.indexOf("\n", lineStart);
      if (lineEnd == -1) {
        lineEnd = text3.length - 1;
      }
      var line = text3.substring(lineStart, lineEnd + 1);
      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        if (lineArrayLength == maxLines) {
          line = text3.substring(lineStart);
          lineEnd = text3.length;
        }
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
      lineStart = lineEnd + 1;
    }
    return chars;
  }
  __name(diff_linesToCharsMunge_, "diff_linesToCharsMunge_");
  var maxLines = 4e4;
  var chars1 = diff_linesToCharsMunge_(text1);
  maxLines = 65535;
  var chars2 = diff_linesToCharsMunge_(text2);
  return { chars1, chars2, lineArray };
};
diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
  for (var i = 0; i < diffs.length; i++) {
    var chars = diffs[i][1];
    var text2 = [];
    for (var j = 0; j < chars.length; j++) {
      text2[j] = lineArray[chars.charCodeAt(j)];
    }
    diffs[i][1] = text2.join("");
  }
};
diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};
diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
  if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
    return 0;
  }
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};
diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
  var text1_length = text1.length;
  var text2_length = text2.length;
  if (text1_length == 0 || text2_length == 0) {
    return 0;
  }
  if (text1_length > text2_length) {
    text1 = text1.substring(text1_length - text2_length);
  } else if (text1_length < text2_length) {
    text2 = text2.substring(0, text1_length);
  }
  var text_length = Math.min(text1_length, text2_length);
  if (text1 == text2) {
    return text_length;
  }
  var best = 0;
  var length2 = 1;
  while (true) {
    var pattern = text1.substring(text_length - length2);
    var found = text2.indexOf(pattern);
    if (found == -1) {
      return best;
    }
    length2 += found;
    if (found == 0 || text1.substring(text_length - length2) == text2.substring(0, length2)) {
      best = length2;
      length2++;
    }
  }
};
diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
  if (this.Diff_Timeout <= 0) {
    return null;
  }
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;
  }
  var dmp = this;
  function diff_halfMatchI_(longtext2, shorttext2, i) {
    var seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
    var j = -1;
    var best_common = "";
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext2.indexOf(seed, j + 1)) != -1) {
      var prefixLength = dmp.diff_commonPrefix(
        longtext2.substring(i),
        shorttext2.substring(j)
      );
      var suffixLength = dmp.diff_commonSuffix(
        longtext2.substring(0, i),
        shorttext2.substring(0, j)
      );
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
        best_longtext_a = longtext2.substring(0, i - suffixLength);
        best_longtext_b = longtext2.substring(i + prefixLength);
        best_shorttext_a = shorttext2.substring(0, j - suffixLength);
        best_shorttext_b = shorttext2.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext2.length) {
      return [
        best_longtext_a,
        best_longtext_b,
        best_shorttext_a,
        best_shorttext_b,
        best_common
      ];
    } else {
      return null;
    }
  }
  __name(diff_halfMatchI_, "diff_halfMatchI_");
  var hm1 = diff_halfMatchI_(
    longtext,
    shorttext,
    Math.ceil(longtext.length / 4)
  );
  var hm2 = diff_halfMatchI_(
    longtext,
    shorttext,
    Math.ceil(longtext.length / 2)
  );
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};
diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
  var changes = false;
  var equalities = [];
  var equalitiesLength = 0;
  var lastEquality = null;
  var pointer = 0;
  var length_insertions1 = 0;
  var length_deletions1 = 0;
  var length_insertions2 = 0;
  var length_deletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {
      equalities[equalitiesLength++] = pointer;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastEquality = diffs[pointer][1];
    } else {
      if (diffs[pointer][0] == DIFF_INSERT) {
        length_insertions2 += diffs[pointer][1].length;
      } else {
        length_deletions2 += diffs[pointer][1].length;
      }
      if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(
        length_insertions2,
        length_deletions2
      )) {
        diffs.splice(
          equalities[equalitiesLength - 1],
          0,
          new diff_match_patch.Diff(DIFF_DELETE, lastEquality)
        );
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastEquality = null;
        changes = true;
      }
    }
    pointer++;
  }
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
  this.diff_cleanupSemanticLossless(diffs);
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
      var deletion = diffs[pointer - 1][1];
      var insertion = diffs[pointer][1];
      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
          diffs.splice(pointer, 0, new diff_match_patch.Diff(
            DIFF_EQUAL,
            insertion.substring(0, overlap_length1)
          ));
          diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
          pointer++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
          diffs.splice(pointer, 0, new diff_match_patch.Diff(
            DIFF_EQUAL,
            deletion.substring(0, overlap_length2)
          ));
          diffs[pointer - 1][0] = DIFF_INSERT;
          diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer + 1][0] = DIFF_DELETE;
          diffs[pointer + 1][1] = deletion.substring(overlap_length2);
          pointer++;
        }
      }
      pointer++;
    }
    pointer++;
  }
};
diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
  function diff_cleanupSemanticScore_(one, two) {
    if (!one || !two) {
      return 6;
    }
    var char1 = one.charAt(one.length - 1);
    var char2 = two.charAt(0);
    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
    var whitespace1 = nonAlphaNumeric1 && char1.match(diff_match_patch.whitespaceRegex_);
    var whitespace2 = nonAlphaNumeric2 && char2.match(diff_match_patch.whitespaceRegex_);
    var lineBreak1 = whitespace1 && char1.match(diff_match_patch.linebreakRegex_);
    var lineBreak2 = whitespace2 && char2.match(diff_match_patch.linebreakRegex_);
    var blankLine1 = lineBreak1 && one.match(diff_match_patch.blanklineEndRegex_);
    var blankLine2 = lineBreak2 && two.match(diff_match_patch.blanklineStartRegex_);
    if (blankLine1 || blankLine2) {
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      return 3;
    } else if (whitespace1 || whitespace2) {
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      return 1;
    }
    return 0;
  }
  __name(diff_cleanupSemanticScore_, "diff_cleanupSemanticScore_");
  var pointer = 1;
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
      var equality1 = diffs[pointer - 1][1];
      var edit = diffs[pointer][1];
      var equality2 = diffs[pointer + 1][1];
      var commonOffset = this.diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        var commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }
      var bestEquality1 = equality1;
      var bestEdit = edit;
      var bestEquality2 = equality2;
      var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }
      if (diffs[pointer - 1][1] != bestEquality1) {
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
};
diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
diff_match_patch.whitespaceRegex_ = /\s/;
diff_match_patch.linebreakRegex_ = /[\r\n]/;
diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;
diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
  var changes = false;
  var equalities = [];
  var equalitiesLength = 0;
  var lastEquality = null;
  var pointer = 0;
  var pre_ins = false;
  var pre_del = false;
  var post_ins = false;
  var post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {
      if (diffs[pointer][1].length < this.Diff_EditCost && (post_ins || post_del)) {
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastEquality = diffs[pointer][1];
      } else {
        equalitiesLength = 0;
        lastEquality = null;
      }
      post_ins = post_del = false;
    } else {
      if (diffs[pointer][0] == DIFF_DELETE) {
        post_del = true;
      } else {
        post_ins = true;
      }
      if (lastEquality && (pre_ins && pre_del && post_ins && post_del || lastEquality.length < this.Diff_EditCost / 2 && pre_ins + pre_del + post_ins + post_del == 3)) {
        diffs.splice(
          equalities[equalitiesLength - 1],
          0,
          new diff_match_patch.Diff(DIFF_DELETE, lastEquality)
        );
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;
        lastEquality = null;
        if (pre_ins && pre_del) {
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;
          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};
diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ""));
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = "";
  var text_insert = "";
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            commonlength = this.diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, new diff_match_patch.Diff(
                  DIFF_EQUAL,
                  text_insert.substring(0, commonlength)
                ));
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            commonlength = this.diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length - commonlength);
              text_delete = text_delete.substring(0, text_delete.length - commonlength);
            }
          }
          pointer -= count_delete + count_insert;
          diffs.splice(pointer, count_delete + count_insert);
          if (text_delete.length) {
            diffs.splice(
              pointer,
              0,
              new diff_match_patch.Diff(DIFF_DELETE, text_delete)
            );
            pointer++;
          }
          if (text_insert.length) {
            diffs.splice(
              pointer,
              0,
              new diff_match_patch.Diff(DIFF_INSERT, text_insert)
            );
            pointer++;
          }
          pointer++;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = "";
        text_insert = "";
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === "") {
    diffs.pop();
  }
  var changes = false;
  pointer = 1;
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
      if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};
diff_match_patch.prototype.diff_cleanupSplitSurrogates = function(diffs) {
  var lastEnd;
  for (var x = 0; x < diffs.length; x++) {
    var thisDiff = diffs[x];
    var thisTop = thisDiff[1][0];
    var thisEnd = thisDiff[1][thisDiff[1].length - 1];
    if (0 === thisDiff[1].length) {
      diffs.splice(x--, 1);
      continue;
    }
    if (thisEnd && this.isHighSurrogate(thisEnd)) {
      lastEnd = thisEnd;
      thisDiff[1] = thisDiff[1].slice(0, -1);
    }
    if (lastEnd && thisTop && this.isHighSurrogate(lastEnd) && this.isLowSurrogate(thisTop)) {
      thisDiff[1] = lastEnd + thisDiff[1];
    }
    if (0 === thisDiff[1].length) {
      diffs.splice(x--, 1);
      continue;
    }
  }
  return diffs;
};
diff_match_patch.prototype.isHighSurrogate = function(c) {
  var v = c.charCodeAt(0);
  return v >= 55296 && v <= 56319;
};
diff_match_patch.prototype.isLowSurrogate = function(c) {
  var v = c.charCodeAt(0);
  return v >= 56320 && v <= 57343;
};
diff_match_patch.prototype.digit16 = function(c) {
  switch (c) {
    case "0":
      return 0;
    case "1":
      return 1;
    case "2":
      return 2;
    case "3":
      return 3;
    case "4":
      return 4;
    case "5":
      return 5;
    case "6":
      return 6;
    case "7":
      return 7;
    case "8":
      return 8;
    case "9":
      return 9;
    case "A":
    case "a":
      return 10;
    case "B":
    case "b":
      return 11;
    case "C":
    case "c":
      return 12;
    case "D":
    case "d":
      return 13;
    case "E":
    case "e":
      return 14;
    case "F":
    case "f":
      return 15;
    default:
      throw new Error("Invalid hex-code");
  }
};
diff_match_patch.prototype.decodeURI = function(text2) {
  try {
    return decodeURI(text2);
  } catch (e) {
    var i = 0;
    var decoded = "";
    while (i < text2.length) {
      if (text2[i] !== "%") {
        decoded += text2[i++];
        continue;
      }
      var byte1 = (this.digit16(text2[i + 1]) << 4) + this.digit16(text2[i + 2]);
      if ((byte1 & 128) === 0) {
        decoded += String.fromCharCode(byte1);
        i += 3;
        continue;
      }
      if ("%" !== text2[i + 3]) {
        throw new URIError("URI malformed");
      }
      var byte2 = (this.digit16(text2[i + 4]) << 4) + this.digit16(text2[i + 5]);
      if ((byte2 & 192) !== 128) {
        throw new URIError("URI malformed");
      }
      byte2 = byte2 & 63;
      if ((byte1 & 224) === 192) {
        decoded += String.fromCharCode((byte1 & 31) << 6 | byte2);
        i += 6;
        continue;
      }
      if ("%" !== text2[i + 6]) {
        throw new URIError("URI malformed");
      }
      var byte3 = (this.digit16(text2[i + 7]) << 4) + this.digit16(text2[i + 8]);
      if ((byte3 & 192) !== 128) {
        throw new URIError("URI malformed");
      }
      byte3 = byte3 & 63;
      if ((byte1 & 240) === 224) {
        decoded += String.fromCharCode((byte1 & 15) << 12 | byte2 << 6 | byte3);
        i += 9;
        continue;
      }
      if ("%" !== text2[i + 9]) {
        throw new URIError("URI malformed");
      }
      var byte4 = (this.digit16(text2[i + 10]) << 4) + this.digit16(text2[i + 11]);
      if ((byte4 & 192) !== 128) {
        throw new URIError("URI malformed");
      }
      byte4 = byte4 & 63;
      if ((byte1 & 248) === 240) {
        var codePoint = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
        if (codePoint >= 65536 && codePoint <= 1114111) {
          decoded += String.fromCharCode((codePoint & 65535) >>> 10 & 1023 | 55296);
          decoded += String.fromCharCode(56320 | codePoint & 65535 & 1023);
          i += 12;
          continue;
        }
      }
      throw new URIError("URI malformed");
    }
    return decoded;
  }
};
diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
  var chars1 = 0;
  var chars2 = 0;
  var last_chars1 = 0;
  var last_chars2 = 0;
  var x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE) {
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {
      break;
    }
    last_chars1 = chars1;
    last_chars2 = chars2;
  }
  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
    return last_chars2;
  }
  return last_chars2 + (loc - last_chars1);
};
diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
  diffs = this.diff_cleanupSplitSurrogates(diffs);
  var html = [];
  var pattern_amp = /&/g;
  var pattern_lt = /</g;
  var pattern_gt = />/g;
  var pattern_para = /\n/g;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];
    var data = diffs[x][1];
    var text2 = data.replace(pattern_amp, "&amp;").replace(pattern_lt, "&lt;").replace(pattern_gt, "&gt;").replace(pattern_para, "&para;<br>");
    switch (op) {
      case DIFF_INSERT:
        html[x] = '<ins style="background:#e6ffe6;">' + text2 + "</ins>";
        break;
      case DIFF_DELETE:
        html[x] = '<del style="background:#ffe6e6;">' + text2 + "</del>";
        break;
      case DIFF_EQUAL:
        html[x] = "<span>" + text2 + "</span>";
        break;
    }
  }
  return html.join("");
};
diff_match_patch.prototype.diff_text1 = function(diffs) {
  var text2 = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      text2[x] = diffs[x][1];
    }
  }
  return text2.join("");
};
diff_match_patch.prototype.diff_text2 = function(diffs) {
  var text2 = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE) {
      text2[x] = diffs[x][1];
    }
  }
  return text2.join("");
};
diff_match_patch.prototype.diff_levenshtein = function(diffs) {
  var levenshtein = 0;
  var insertions = 0;
  var deletions = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];
    var data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        levenshtein += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
    }
  }
  levenshtein += Math.max(insertions, deletions);
  return levenshtein;
};
diff_match_patch.prototype.diff_toDelta = function(diffs) {
  diffs = this.diff_cleanupSplitSurrogates(diffs);
  var text2 = [];
  for (var x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        text2[x] = "+" + encodeURI(diffs[x][1]);
        break;
      case DIFF_DELETE:
        text2[x] = "-" + diffs[x][1].length;
        break;
      case DIFF_EQUAL:
        text2[x] = "=" + diffs[x][1].length;
        break;
    }
  }
  return text2.join("	").replace(/%20/g, " ");
};
diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
  var diffs = [];
  var diffsLength = 0;
  var pointer = 0;
  var tokens = delta.split(/\t/g);
  for (var x = 0; x < tokens.length; x++) {
    var param = tokens[x].substring(1);
    switch (tokens[x].charAt(0)) {
      case "+":
        try {
          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_INSERT, this.decodeURI(param));
        } catch (ex) {
          throw new Error("Illegal escape in diff_fromDelta: " + param);
        }
        break;
      case "-":
      // Fall through.
      case "=":
        var n = parseInt(param, 10);
        if (isNaN(n) || n < 0) {
          throw new Error("Invalid number in diff_fromDelta: " + param);
        }
        var text2 = text1.substring(pointer, pointer += n);
        if (tokens[x].charAt(0) == "=") {
          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text2);
        } else {
          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text2);
        }
        break;
      default:
        if (tokens[x]) {
          throw new Error("Invalid diff operation in diff_fromDelta: " + tokens[x]);
        }
    }
  }
  if (pointer != text1.length) {
    throw new Error("Delta length (" + pointer + ") does not equal source text length (" + text1.length + ").");
  }
  return diffs;
};
diff_match_patch.prototype.match_main = function(text2, pattern, loc) {
  if (text2 == null || pattern == null || loc == null) {
    throw new Error("Null input. (match_main)");
  }
  loc = Math.max(0, Math.min(loc, text2.length));
  if (text2 == pattern) {
    return 0;
  } else if (!text2.length) {
    return -1;
  } else if (text2.substring(loc, loc + pattern.length) == pattern) {
    return loc;
  } else {
    return this.match_bitap_(text2, pattern, loc);
  }
};
diff_match_patch.prototype.match_bitap_ = function(text2, pattern, loc) {
  if (pattern.length > this.Match_MaxBits) {
    throw new Error("Pattern too long for this browser.");
  }
  var s = this.match_alphabet_(pattern);
  var dmp = this;
  function match_bitapScore_(e, x) {
    var accuracy = e / pattern.length;
    var proximity = Math.abs(loc - x);
    if (!dmp.Match_Distance) {
      return proximity ? 1 : accuracy;
    }
    return accuracy + proximity / dmp.Match_Distance;
  }
  __name(match_bitapScore_, "match_bitapScore_");
  var score_threshold = this.Match_Threshold;
  var best_loc = text2.indexOf(pattern, loc);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
    best_loc = text2.lastIndexOf(pattern, loc + pattern.length);
    if (best_loc != -1) {
      score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
    }
  }
  var matchmask = 1 << pattern.length - 1;
  best_loc = -1;
  var bin_min, bin_mid;
  var bin_max = pattern.length + text2.length;
  var last_rd;
  for (var d2 = 0; d2 < pattern.length; d2++) {
    bin_min = 0;
    bin_mid = bin_max;
    while (bin_min < bin_mid) {
      if (match_bitapScore_(d2, loc + bin_mid) <= score_threshold) {
        bin_min = bin_mid;
      } else {
        bin_max = bin_mid;
      }
      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
    }
    bin_max = bin_mid;
    var start = Math.max(1, loc - bin_mid + 1);
    var finish = Math.min(loc + bin_mid, text2.length) + pattern.length;
    var rd = Array(finish + 2);
    rd[finish + 1] = (1 << d2) - 1;
    for (var j = finish; j >= start; j--) {
      var charMatch = s[text2.charAt(j - 1)];
      if (d2 === 0) {
        rd[j] = (rd[j + 1] << 1 | 1) & charMatch;
      } else {
        rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((last_rd[j + 1] | last_rd[j]) << 1 | 1) | last_rd[j + 1];
      }
      if (rd[j] & matchmask) {
        var score = match_bitapScore_(d2, j - 1);
        if (score <= score_threshold) {
          score_threshold = score;
          best_loc = j - 1;
          if (best_loc > loc) {
            start = Math.max(1, 2 * loc - best_loc);
          } else {
            break;
          }
        }
      }
    }
    if (match_bitapScore_(d2 + 1, loc) > score_threshold) {
      break;
    }
    last_rd = rd;
  }
  return best_loc;
};
diff_match_patch.prototype.match_alphabet_ = function(pattern) {
  var s = {};
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;
  }
  return s;
};
diff_match_patch.prototype.patch_addContext_ = function(patch, text2) {
  if (text2.length == 0) {
    return;
  }
  if (patch.start2 === null) {
    throw Error("patch not initialized");
  }
  var pattern = text2.substring(patch.start2, patch.start2 + patch.length1);
  var padding = 0;
  while (text2.indexOf(pattern) != text2.lastIndexOf(pattern) && pattern.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin) {
    padding += this.Patch_Margin;
    pattern = text2.substring(
      patch.start2 - padding,
      patch.start2 + patch.length1 + padding
    );
  }
  padding += this.Patch_Margin;
  if (patch.start2 - padding > 0 && diff_match_patch.prototype.isLowSurrogate(text2[patch.start2 - padding])) {
    padding++;
  }
  var prefix = text2.substring(patch.start2 - padding, patch.start2);
  if (prefix) {
    patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));
  }
  if (patch.start2 + patch.length1 + padding < text2.length && diff_match_patch.prototype.isHighSurrogate(text2[patch.start2 + patch.length1 + padding])) {
    padding++;
  }
  var suffix = text2.substring(
    patch.start2 + patch.length1,
    patch.start2 + patch.length1 + padding
  );
  if (suffix) {
    patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));
  }
  patch.start1 -= prefix.length;
  patch.start2 -= prefix.length;
  patch.length1 += prefix.length + suffix.length;
  patch.length2 += prefix.length + suffix.length;
};
diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
  var text1, diffs;
  if (typeof a == "string" && typeof opt_b == "string" && typeof opt_c == "undefined") {
    text1 = /** @type {string} */
    a;
    diffs = this.diff_main(
      text1,
      /** @type {string} */
      opt_b,
      true
    );
    if (diffs.length > 2) {
      this.diff_cleanupSemantic(diffs);
      this.diff_cleanupEfficiency(diffs);
    }
  } else if (a && typeof a == "object" && typeof opt_b == "undefined" && typeof opt_c == "undefined") {
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */
    a;
    text1 = this.diff_text1(diffs);
  } else if (typeof a == "string" && opt_b && typeof opt_b == "object" && typeof opt_c == "undefined") {
    text1 = /** @type {string} */
    a;
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */
    opt_b;
  } else if (typeof a == "string" && typeof opt_b == "string" && opt_c && typeof opt_c == "object") {
    text1 = /** @type {string} */
    a;
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */
    opt_c;
  } else {
    throw new Error("Unknown call format to patch_make.");
  }
  if (diffs.length === 0) {
    return [];
  }
  diffs = this.diff_cleanupSplitSurrogates(diffs);
  var patches = [];
  var patch = new diff_match_patch.patch_obj();
  var patchDiffLength = 0;
  var char_count1 = 0;
  var char_count2 = 0;
  var prepatch_text = text1;
  var postpatch_text = text1;
  for (var x = 0; x < diffs.length; x++) {
    var diff_type = diffs[x][0];
    var diff_text = diffs[x][1];
    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
      patch.start1 = char_count1;
      patch.start2 = char_count2;
    }
    switch (diff_type) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = diffs[x];
        patch.length2 += diff_text.length;
        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text + postpatch_text.substring(char_count2);
        break;
      case DIFF_DELETE:
        patch.length1 += diff_text.length;
        patch.diffs[patchDiffLength++] = diffs[x];
        postpatch_text = postpatch_text.substring(0, char_count2) + postpatch_text.substring(char_count2 + diff_text.length);
        break;
      case DIFF_EQUAL:
        if (diff_text.length <= 2 * this.Patch_Margin && patchDiffLength && diffs.length != x + 1) {
          patch.diffs[patchDiffLength++] = diffs[x];
          patch.length1 += diff_text.length;
          patch.length2 += diff_text.length;
        } else if (diff_text.length >= 2 * this.Patch_Margin) {
          if (patchDiffLength) {
            this.patch_addContext_(patch, prepatch_text);
            patches.push(patch);
            patch = new diff_match_patch.patch_obj();
            patchDiffLength = 0;
            prepatch_text = postpatch_text;
            char_count1 = char_count2;
          }
        }
        break;
    }
    if (diff_type !== DIFF_INSERT) {
      char_count1 += diff_text.length;
    }
    if (diff_type !== DIFF_DELETE) {
      char_count2 += diff_text.length;
    }
  }
  if (patchDiffLength) {
    this.patch_addContext_(patch, prepatch_text);
    patches.push(patch);
  }
  return patches;
};
diff_match_patch.prototype.patch_deepCopy = function(patches) {
  var patchesCopy = [];
  for (var x = 0; x < patches.length; x++) {
    var patch = patches[x];
    var patchCopy = new diff_match_patch.patch_obj();
    patchCopy.diffs = [];
    for (var y = 0; y < patch.diffs.length; y++) {
      patchCopy.diffs[y] = new diff_match_patch.Diff(patch.diffs[y][0], patch.diffs[y][1]);
    }
    patchCopy.start1 = patch.start1;
    patchCopy.start2 = patch.start2;
    patchCopy.length1 = patch.length1;
    patchCopy.length2 = patch.length2;
    patchesCopy[x] = patchCopy;
  }
  return patchesCopy;
};
diff_match_patch.prototype.patch_apply = function(patches, text2) {
  if (patches.length == 0) {
    return [text2, []];
  }
  patches = this.patch_deepCopy(patches);
  var nullPadding = this.patch_addPadding(patches);
  text2 = nullPadding + text2 + nullPadding;
  this.patch_splitMax(patches);
  var delta = 0;
  var results = [];
  for (var x = 0; x < patches.length; x++) {
    var expected_loc = patches[x].start2 + delta;
    var text1 = this.diff_text1(patches[x].diffs);
    var start_loc;
    var end_loc = -1;
    if (text1.length > this.Match_MaxBits) {
      start_loc = this.match_main(
        text2,
        text1.substring(0, this.Match_MaxBits),
        expected_loc
      );
      if (start_loc != -1) {
        end_loc = this.match_main(
          text2,
          text1.substring(text1.length - this.Match_MaxBits),
          expected_loc + text1.length - this.Match_MaxBits
        );
        if (end_loc == -1 || start_loc >= end_loc) {
          start_loc = -1;
        }
      }
    } else {
      start_loc = this.match_main(text2, text1, expected_loc);
    }
    if (start_loc == -1) {
      results[x] = false;
      delta -= patches[x].length2 - patches[x].length1;
    } else {
      results[x] = true;
      delta = start_loc - expected_loc;
      var text22;
      if (end_loc == -1) {
        text22 = text2.substring(start_loc, start_loc + text1.length);
      } else {
        text22 = text2.substring(start_loc, end_loc + this.Match_MaxBits);
      }
      if (text1 == text22) {
        text2 = text2.substring(0, start_loc) + this.diff_text2(patches[x].diffs) + text2.substring(start_loc + text1.length);
      } else {
        var diffs = this.diff_main(text1, text22, false);
        if (text1.length > this.Match_MaxBits && this.diff_levenshtein(diffs) / text1.length > this.Patch_DeleteThreshold) {
          results[x] = false;
        } else {
          this.diff_cleanupSemanticLossless(diffs);
          var index1 = 0;
          var index2;
          for (var y = 0; y < patches[x].diffs.length; y++) {
            var mod = patches[x].diffs[y];
            if (mod[0] !== DIFF_EQUAL) {
              index2 = this.diff_xIndex(diffs, index1);
            }
            if (mod[0] === DIFF_INSERT) {
              text2 = text2.substring(0, start_loc + index2) + mod[1] + text2.substring(start_loc + index2);
            } else if (mod[0] === DIFF_DELETE) {
              text2 = text2.substring(0, start_loc + index2) + text2.substring(start_loc + this.diff_xIndex(
                diffs,
                index1 + mod[1].length
              ));
            }
            if (mod[0] !== DIFF_DELETE) {
              index1 += mod[1].length;
            }
          }
        }
      }
    }
  }
  text2 = text2.substring(nullPadding.length, text2.length - nullPadding.length);
  return [text2, results];
};
diff_match_patch.prototype.patch_addPadding = function(patches) {
  var paddingLength = this.Patch_Margin;
  var nullPadding = "";
  for (var x = 1; x <= paddingLength; x++) {
    nullPadding += String.fromCharCode(x);
  }
  for (var x = 0; x < patches.length; x++) {
    patches[x].start1 += paddingLength;
    patches[x].start2 += paddingLength;
  }
  var patch = patches[0];
  var diffs = patch.diffs;
  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
    patch.start1 -= paddingLength;
    patch.start2 -= paddingLength;
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[0][1].length) {
    var extraLength = paddingLength - diffs[0][1].length;
    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
    patch.start1 -= extraLength;
    patch.start2 -= extraLength;
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }
  patch = patches[patches.length - 1];
  diffs = patch.diffs;
  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }
  return nullPadding;
};
diff_match_patch.prototype.patch_splitMax = function(patches) {
  var patch_size = this.Match_MaxBits;
  for (var x = 0; x < patches.length; x++) {
    if (patches[x].length1 <= patch_size) {
      continue;
    }
    var bigpatch = patches[x];
    patches.splice(x--, 1);
    var start1 = bigpatch.start1;
    var start2 = bigpatch.start2;
    var precontext = "";
    while (bigpatch.diffs.length !== 0) {
      var patch = new diff_match_patch.patch_obj();
      var empty = true;
      patch.start1 = start1 - precontext.length;
      patch.start2 = start2 - precontext.length;
      if (precontext !== "") {
        patch.length1 = patch.length2 = precontext.length;
        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));
      }
      while (bigpatch.diffs.length !== 0 && patch.length1 < patch_size - this.Patch_Margin) {
        var diff_type = bigpatch.diffs[0][0];
        var diff_text = bigpatch.diffs[0][1];
        if (diff_type === DIFF_INSERT) {
          patch.length2 += diff_text.length;
          start2 += diff_text.length;
          patch.diffs.push(bigpatch.diffs.shift());
          empty = false;
        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 && patch.diffs[0][0] == DIFF_EQUAL && diff_text.length > 2 * patch_size) {
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          empty = false;
          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
          bigpatch.diffs.shift();
        } else {
          diff_text = diff_text.substring(
            0,
            patch_size - patch.length1 - this.Patch_Margin
          );
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          if (diff_type === DIFF_EQUAL) {
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
          } else {
            empty = false;
          }
          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
          if (diff_text == bigpatch.diffs[0][1]) {
            bigpatch.diffs.shift();
          } else {
            bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diff_text.length);
          }
        }
      }
      precontext = this.diff_text2(patch.diffs);
      precontext = precontext.substring(precontext.length - this.Patch_Margin);
      var postcontext = this.diff_text1(bigpatch.diffs).substring(0, this.Patch_Margin);
      if (postcontext !== "") {
        patch.length1 += postcontext.length;
        patch.length2 += postcontext.length;
        if (patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
          patch.diffs[patch.diffs.length - 1][1] += postcontext;
        } else {
          patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));
        }
      }
      if (!empty) {
        patches.splice(++x, 0, patch);
      }
    }
  }
};
diff_match_patch.prototype.patch_toText = function(patches) {
  var text2 = [];
  for (var x = 0; x < patches.length; x++) {
    text2[x] = patches[x];
  }
  return text2.join("");
};
diff_match_patch.prototype.patch_fromText = function(textline) {
  var patches = [];
  if (!textline) {
    return patches;
  }
  var text2 = textline.split("\n");
  var textPointer = 0;
  var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
  while (textPointer < text2.length) {
    var m = text2[textPointer].match(patchHeader);
    if (!m) {
      throw new Error("Invalid patch string: " + text2[textPointer]);
    }
    var patch = new diff_match_patch.patch_obj();
    patches.push(patch);
    patch.start1 = parseInt(m[1], 10);
    if (m[2] === "") {
      patch.start1--;
      patch.length1 = 1;
    } else if (m[2] == "0") {
      patch.length1 = 0;
    } else {
      patch.start1--;
      patch.length1 = parseInt(m[2], 10);
    }
    patch.start2 = parseInt(m[3], 10);
    if (m[4] === "") {
      patch.start2--;
      patch.length2 = 1;
    } else if (m[4] == "0") {
      patch.length2 = 0;
    } else {
      patch.start2--;
      patch.length2 = parseInt(m[4], 10);
    }
    textPointer++;
    while (textPointer < text2.length) {
      var sign = text2[textPointer].charAt(0);
      try {
        var line = decodeURI(text2[textPointer].substring(1));
      } catch (ex) {
        throw new Error("Illegal escape in patch_fromText: " + line);
      }
      if (sign == "-") {
        patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));
      } else if (sign == "+") {
        patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));
      } else if (sign == " ") {
        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));
      } else if (sign == "@") {
        break;
      } else if (sign === "") {
      } else {
        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
      }
      textPointer++;
    }
  }
  return patches;
};
diff_match_patch.patch_obj = function() {
  this.diffs = [];
  this.start1 = null;
  this.start2 = null;
  this.length1 = 0;
  this.length2 = 0;
};
diff_match_patch.patch_obj.prototype.toString = function() {
  var coords1, coords2;
  if (this.length1 === 0) {
    coords1 = this.start1 + ",0";
  } else if (this.length1 == 1) {
    coords1 = this.start1 + 1;
  } else {
    coords1 = this.start1 + 1 + "," + this.length1;
  }
  if (this.length2 === 0) {
    coords2 = this.start2 + ",0";
  } else if (this.length2 == 1) {
    coords2 = this.start2 + 1;
  } else {
    coords2 = this.start2 + 1 + "," + this.length2;
  }
  var text2 = ["@@ -" + coords1 + " +" + coords2 + " @@\n"];
  var op;
  diff_match_patch.prototype.diff_cleanupSplitSurrogates(this.diffs);
  for (var x = 0; x < this.diffs.length; x++) {
    switch (this.diffs[x][0]) {
      case DIFF_INSERT:
        op = "+";
        break;
      case DIFF_DELETE:
        op = "-";
        break;
      case DIFF_EQUAL:
        op = " ";
        break;
    }
    text2[x + 1] = op + encodeURI(this.diffs[x][1]) + "\n";
  }
  return text2.join("").replace(/%20/g, " ");
};

// node_modules/yjs/dist/yjs.mjs
init_process_shim();

// node_modules/lib0/observable.js
init_process_shim();

// node_modules/lib0/map.js
init_process_shim();
var create = /* @__PURE__ */ __name(() => /* @__PURE__ */ new Map(), "create");
var copy = /* @__PURE__ */ __name((m) => {
  const r = create();
  m.forEach((v, k) => {
    r.set(k, v);
  });
  return r;
}, "copy");
var setIfUndefined = /* @__PURE__ */ __name((map3, key, createT) => {
  let set = map3.get(key);
  if (set === void 0) {
    map3.set(key, set = createT());
  }
  return set;
}, "setIfUndefined");
var map2 = /* @__PURE__ */ __name((m, f) => {
  const res = [];
  for (const [key, value] of m) {
    res.push(f(value, key));
  }
  return res;
}, "map");
var any = /* @__PURE__ */ __name((m, f) => {
  for (const [key, value] of m) {
    if (f(value, key)) {
      return true;
    }
  }
  return false;
}, "any");

// node_modules/lib0/set.js
init_process_shim();
var create2 = /* @__PURE__ */ __name(() => /* @__PURE__ */ new Set(), "create");

// node_modules/lib0/array.js
init_process_shim();
var last2 = /* @__PURE__ */ __name((arr) => arr[arr.length - 1], "last");
var appendTo = /* @__PURE__ */ __name((dest, src) => {
  for (let i = 0; i < src.length; i++) {
    dest.push(src[i]);
  }
}, "appendTo");
var from2 = Array.from;
var isArray5 = Array.isArray;

// node_modules/lib0/observable.js
var _ObservableV2 = class _ObservableV2 {
  constructor() {
    this._observers = create();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(name, f) {
    setIfUndefined(
      this._observers,
      /** @type {string} */
      name,
      create2
    ).add(f);
    return f;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(name, f) {
    const _f = /* @__PURE__ */ __name((...args2) => {
      this.off(
        name,
        /** @type {any} */
        _f
      );
      f(...args2);
    }, "_f");
    this.on(
      name,
      /** @type {any} */
      _f
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(name, f) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(name, args2) {
    return from2((this._observers.get(name) || create()).values()).forEach((f) => f(...args2));
  }
  destroy() {
    this._observers = create();
  }
};
__name(_ObservableV2, "ObservableV2");
var ObservableV2 = _ObservableV2;
var _Observable = class _Observable {
  constructor() {
    this._observers = create();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(name, f) {
    setIfUndefined(this._observers, name, create2).add(f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(name, f) {
    const _f = /* @__PURE__ */ __name((...args2) => {
      this.off(name, _f);
      f(...args2);
    }, "_f");
    this.on(name, _f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(name, f) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(name, args2) {
    return from2((this._observers.get(name) || create()).values()).forEach((f) => f(...args2));
  }
  destroy() {
    this._observers = create();
  }
};
__name(_Observable, "Observable");
var Observable4 = _Observable;

// node_modules/lib0/math.js
init_process_shim();
var floor = Math.floor;
var abs = Math.abs;
var min = /* @__PURE__ */ __name((a, b) => a < b ? a : b, "min");
var max = /* @__PURE__ */ __name((a, b) => a > b ? a : b, "max");
var isNaN2 = Number.isNaN;
var isNegativeZero = /* @__PURE__ */ __name((n) => n !== 0 ? n < 0 : 1 / n < 0, "isNegativeZero");

// node_modules/lib0/encoding.js
init_process_shim();

// node_modules/lib0/number.js
init_process_shim();

// node_modules/lib0/binary.js
init_process_shim();
var BIT1 = 1;
var BIT2 = 2;
var BIT3 = 4;
var BIT4 = 8;
var BIT6 = 32;
var BIT7 = 64;
var BIT8 = 128;
var BIT18 = 1 << 17;
var BIT19 = 1 << 18;
var BIT20 = 1 << 19;
var BIT21 = 1 << 20;
var BIT22 = 1 << 21;
var BIT23 = 1 << 22;
var BIT24 = 1 << 23;
var BIT25 = 1 << 24;
var BIT26 = 1 << 25;
var BIT27 = 1 << 26;
var BIT28 = 1 << 27;
var BIT29 = 1 << 28;
var BIT30 = 1 << 29;
var BIT31 = 1 << 30;
var BIT32 = 1 << 31;
var BITS5 = 31;
var BITS6 = 63;
var BITS7 = 127;
var BITS17 = BIT18 - 1;
var BITS18 = BIT19 - 1;
var BITS19 = BIT20 - 1;
var BITS20 = BIT21 - 1;
var BITS21 = BIT22 - 1;
var BITS22 = BIT23 - 1;
var BITS23 = BIT24 - 1;
var BITS24 = BIT25 - 1;
var BITS25 = BIT26 - 1;
var BITS26 = BIT27 - 1;
var BITS27 = BIT28 - 1;
var BITS28 = BIT29 - 1;
var BITS29 = BIT30 - 1;
var BITS30 = BIT31 - 1;
var BITS31 = 2147483647;

// node_modules/lib0/number.js
var MAX_SAFE_INTEGER3 = Number.MAX_SAFE_INTEGER;
var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
var LOWEST_INT32 = 1 << 31;
var isInteger = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor(num) === num);
var isNaN3 = Number.isNaN;
var parseInt2 = Number.parseInt;

// node_modules/lib0/string.js
init_process_shim();
var fromCharCode = String.fromCharCode;
var fromCodePoint = String.fromCodePoint;
var MAX_UTF16_CHARACTER = fromCharCode(65535);
var toLowerCase = /* @__PURE__ */ __name((s) => s.toLowerCase(), "toLowerCase");
var trimLeftRegex = /^\s*/g;
var trimLeft = /* @__PURE__ */ __name((s) => s.replace(trimLeftRegex, ""), "trimLeft");
var fromCamelCaseRegex = /([A-Z])/g;
var fromCamelCase = /* @__PURE__ */ __name((s, separator) => trimLeft(s.replace(fromCamelCaseRegex, (match) => `${separator}${toLowerCase(match)}`)), "fromCamelCase");
var _encodeUtf8Polyfill = /* @__PURE__ */ __name((str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    buf[i] = /** @type {number} */
    encodedString.codePointAt(i);
  }
  return buf;
}, "_encodeUtf8Polyfill");
var utf8TextEncoder = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
var _encodeUtf8Native = /* @__PURE__ */ __name((str) => utf8TextEncoder.encode(str), "_encodeUtf8Native");
var encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder = null;
}

// node_modules/lib0/encoding.js
var _Encoder = class _Encoder {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
};
__name(_Encoder, "Encoder");
var Encoder = _Encoder;
var createEncoder = /* @__PURE__ */ __name(() => new Encoder(), "createEncoder");
var length = /* @__PURE__ */ __name((encoder) => {
  let len = encoder.cpos;
  for (let i = 0; i < encoder.bufs.length; i++) {
    len += encoder.bufs[i].length;
  }
  return len;
}, "length");
var toUint8Array = /* @__PURE__ */ __name((encoder) => {
  const uint8arr = new Uint8Array(length(encoder));
  let curPos = 0;
  for (let i = 0; i < encoder.bufs.length; i++) {
    const d2 = encoder.bufs[i];
    uint8arr.set(d2, curPos);
    curPos += d2.length;
  }
  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
  return uint8arr;
}, "toUint8Array");
var verifyLen = /* @__PURE__ */ __name((encoder, len) => {
  const bufferLen = encoder.cbuf.length;
  if (bufferLen - encoder.cpos < len) {
    encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos));
    encoder.cbuf = new Uint8Array(max(bufferLen, len) * 2);
    encoder.cpos = 0;
  }
}, "verifyLen");
var write = /* @__PURE__ */ __name((encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
}, "write");
var writeUint8 = write;
var writeVarUint = /* @__PURE__ */ __name((encoder, num) => {
  while (num > BITS7) {
    write(encoder, BIT8 | BITS7 & num);
    num = floor(num / 128);
  }
  write(encoder, BITS7 & num);
}, "writeVarUint");
var writeVarInt = /* @__PURE__ */ __name((encoder, num) => {
  const isNegative = isNegativeZero(num);
  if (isNegative) {
    num = -num;
  }
  write(encoder, (num > BITS6 ? BIT8 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);
  num = floor(num / 64);
  while (num > 0) {
    write(encoder, (num > BITS7 ? BIT8 : 0) | BITS7 & num);
    num = floor(num / 128);
  }
}, "writeVarInt");
var _strBuffer = new Uint8Array(3e4);
var _maxStrBSize = _strBuffer.length / 3;
var _writeVarStringNative = /* @__PURE__ */ __name((encoder, str) => {
  if (str.length < _maxStrBSize) {
    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
    writeVarUint(encoder, written);
    for (let i = 0; i < written; i++) {
      write(encoder, _strBuffer[i]);
    }
  } else {
    writeVarUint8Array(encoder, encodeUtf8(str));
  }
}, "_writeVarStringNative");
var _writeVarStringPolyfill = /* @__PURE__ */ __name((encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint(encoder, len);
  for (let i = 0; i < len; i++) {
    write(
      encoder,
      /** @type {number} */
      encodedString.codePointAt(i)
    );
  }
}, "_writeVarStringPolyfill");
var writeVarString = utf8TextEncoder && /** @type {any} */
utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
var writeUint8Array = /* @__PURE__ */ __name((encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
}, "writeUint8Array");
var writeVarUint8Array = /* @__PURE__ */ __name((encoder, uint8Array) => {
  writeVarUint(encoder, uint8Array.byteLength);
  writeUint8Array(encoder, uint8Array);
}, "writeVarUint8Array");
var writeOnDataView = /* @__PURE__ */ __name((encoder, len) => {
  verifyLen(encoder, len);
  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
  encoder.cpos += len;
  return dview;
}, "writeOnDataView");
var writeFloat32 = /* @__PURE__ */ __name((encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false), "writeFloat32");
var writeFloat64 = /* @__PURE__ */ __name((encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false), "writeFloat64");
var writeBigInt64 = /* @__PURE__ */ __name((encoder, num) => (
  /** @type {any} */
  writeOnDataView(encoder, 8).setBigInt64(0, num, false)
), "writeBigInt64");
var floatTestBed = new DataView(new ArrayBuffer(4));
var isFloat32 = /* @__PURE__ */ __name((num) => {
  floatTestBed.setFloat32(0, num);
  return floatTestBed.getFloat32(0) === num;
}, "isFloat32");
var writeAny = /* @__PURE__ */ __name((encoder, data) => {
  switch (typeof data) {
    case "string":
      write(encoder, 119);
      writeVarString(encoder, data);
      break;
    case "number":
      if (isInteger(data) && abs(data) <= BITS31) {
        write(encoder, 125);
        writeVarInt(encoder, data);
      } else if (isFloat32(data)) {
        write(encoder, 124);
        writeFloat32(encoder, data);
      } else {
        write(encoder, 123);
        writeFloat64(encoder, data);
      }
      break;
    case "bigint":
      write(encoder, 122);
      writeBigInt64(encoder, data);
      break;
    case "object":
      if (data === null) {
        write(encoder, 126);
      } else if (isArray5(data)) {
        write(encoder, 117);
        writeVarUint(encoder, data.length);
        for (let i = 0; i < data.length; i++) {
          writeAny(encoder, data[i]);
        }
      } else if (data instanceof Uint8Array) {
        write(encoder, 116);
        writeVarUint8Array(encoder, data);
      } else {
        write(encoder, 118);
        const keys3 = Object.keys(data);
        writeVarUint(encoder, keys3.length);
        for (let i = 0; i < keys3.length; i++) {
          const key = keys3[i];
          writeVarString(encoder, key);
          writeAny(encoder, data[key]);
        }
      }
      break;
    case "boolean":
      write(encoder, data ? 120 : 121);
      break;
    default:
      write(encoder, 127);
  }
}, "writeAny");
var _RleEncoder = class _RleEncoder extends Encoder {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(writer) {
    super();
    this.w = writer;
    this.s = null;
    this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(v) {
    if (this.s === v) {
      this.count++;
    } else {
      if (this.count > 0) {
        writeVarUint(this, this.count - 1);
      }
      this.count = 1;
      this.w(this, v);
      this.s = v;
    }
  }
};
__name(_RleEncoder, "RleEncoder");
var RleEncoder = _RleEncoder;
var flushUintOptRleEncoder = /* @__PURE__ */ __name((encoder) => {
  if (encoder.count > 0) {
    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
}, "flushUintOptRleEncoder");
var _UintOptRleEncoder = class _UintOptRleEncoder {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(v) {
    if (this.s === v) {
      this.count++;
    } else {
      flushUintOptRleEncoder(this);
      this.count = 1;
      this.s = v;
    }
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    flushUintOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
__name(_UintOptRleEncoder, "UintOptRleEncoder");
var UintOptRleEncoder = _UintOptRleEncoder;
var flushIntDiffOptRleEncoder = /* @__PURE__ */ __name((encoder) => {
  if (encoder.count > 0) {
    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);
    writeVarInt(encoder.encoder, encodedDiff);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
}, "flushIntDiffOptRleEncoder");
var _IntDiffOptRleEncoder = class _IntDiffOptRleEncoder {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(v) {
    if (this.diff === v - this.s) {
      this.s = v;
      this.count++;
    } else {
      flushIntDiffOptRleEncoder(this);
      this.count = 1;
      this.diff = v - this.s;
      this.s = v;
    }
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    flushIntDiffOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
__name(_IntDiffOptRleEncoder, "IntDiffOptRleEncoder");
var IntDiffOptRleEncoder = _IntDiffOptRleEncoder;
var _StringEncoder = class _StringEncoder {
  constructor() {
    this.sarr = [];
    this.s = "";
    this.lensE = new UintOptRleEncoder();
  }
  /**
   * @param {string} string
   */
  write(string) {
    this.s += string;
    if (this.s.length > 19) {
      this.sarr.push(this.s);
      this.s = "";
    }
    this.lensE.write(string.length);
  }
  toUint8Array() {
    const encoder = new Encoder();
    this.sarr.push(this.s);
    this.s = "";
    writeVarString(encoder, this.sarr.join(""));
    writeUint8Array(encoder, this.lensE.toUint8Array());
    return toUint8Array(encoder);
  }
};
__name(_StringEncoder, "StringEncoder");
var StringEncoder = _StringEncoder;

// node_modules/lib0/decoding.js
init_process_shim();

// node_modules/lib0/error.js
init_process_shim();
var create3 = /* @__PURE__ */ __name((s) => new Error(s), "create");
var methodUnimplemented = /* @__PURE__ */ __name(() => {
  throw create3("Method unimplemented");
}, "methodUnimplemented");
var unexpectedCase = /* @__PURE__ */ __name(() => {
  throw create3("Unexpected case");
}, "unexpectedCase");

// node_modules/lib0/decoding.js
var errorUnexpectedEndOfArray = create3("Unexpected end of array");
var errorIntegerOutOfRange = create3("Integer out of Range");
var _Decoder = class _Decoder {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(uint8Array) {
    this.arr = uint8Array;
    this.pos = 0;
  }
};
__name(_Decoder, "Decoder");
var Decoder = _Decoder;
var createDecoder = /* @__PURE__ */ __name((uint8Array) => new Decoder(uint8Array), "createDecoder");
var hasContent = /* @__PURE__ */ __name((decoder) => decoder.pos !== decoder.arr.length, "hasContent");
var readUint8Array = /* @__PURE__ */ __name((decoder, len) => {
  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
  decoder.pos += len;
  return view;
}, "readUint8Array");
var readVarUint8Array = /* @__PURE__ */ __name((decoder) => readUint8Array(decoder, readVarUint(decoder)), "readVarUint8Array");
var readUint8 = /* @__PURE__ */ __name((decoder) => decoder.arr[decoder.pos++], "readUint8");
var readVarUint = /* @__PURE__ */ __name((decoder) => {
  let num = 0;
  let mult = 1;
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    const r = decoder.arr[decoder.pos++];
    num = num + (r & BITS7) * mult;
    mult *= 128;
    if (r < BIT8) {
      return num;
    }
    if (num > MAX_SAFE_INTEGER3) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
}, "readVarUint");
var readVarInt = /* @__PURE__ */ __name((decoder) => {
  let r = decoder.arr[decoder.pos++];
  let num = r & BITS6;
  let mult = 64;
  const sign = (r & BIT7) > 0 ? -1 : 1;
  if ((r & BIT8) === 0) {
    return sign * num;
  }
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    r = decoder.arr[decoder.pos++];
    num = num + (r & BITS7) * mult;
    mult *= 128;
    if (r < BIT8) {
      return sign * num;
    }
    if (num > MAX_SAFE_INTEGER3) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
}, "readVarInt");
var _readVarStringPolyfill = /* @__PURE__ */ __name((decoder) => {
  let remainingLen = readVarUint(decoder);
  if (remainingLen === 0) {
    return "";
  } else {
    let encodedString = String.fromCodePoint(readUint8(decoder));
    if (--remainingLen < 100) {
      while (remainingLen--) {
        encodedString += String.fromCodePoint(readUint8(decoder));
      }
    } else {
      while (remainingLen > 0) {
        const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;
        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
        decoder.pos += nextLen;
        encodedString += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          bytes
        );
        remainingLen -= nextLen;
      }
    }
    return decodeURIComponent(escape(encodedString));
  }
}, "_readVarStringPolyfill");
var _readVarStringNative = /* @__PURE__ */ __name((decoder) => (
  /** @type any */
  utf8TextDecoder.decode(readVarUint8Array(decoder))
), "_readVarStringNative");
var readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;
var readFromDataView = /* @__PURE__ */ __name((decoder, len) => {
  const dv2 = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);
  decoder.pos += len;
  return dv2;
}, "readFromDataView");
var readFloat32 = /* @__PURE__ */ __name((decoder) => readFromDataView(decoder, 4).getFloat32(0, false), "readFloat32");
var readFloat64 = /* @__PURE__ */ __name((decoder) => readFromDataView(decoder, 8).getFloat64(0, false), "readFloat64");
var readBigInt64 = /* @__PURE__ */ __name((decoder) => (
  /** @type {any} */
  readFromDataView(decoder, 8).getBigInt64(0, false)
), "readBigInt64");
var readAnyLookupTable = [
  (decoder) => void 0,
  // CASE 127: undefined
  (decoder) => null,
  // CASE 126: null
  readVarInt,
  // CASE 125: integer
  readFloat32,
  // CASE 124: float32
  readFloat64,
  // CASE 123: float64
  readBigInt64,
  // CASE 122: bigint
  (decoder) => false,
  // CASE 121: boolean (false)
  (decoder) => true,
  // CASE 120: boolean (true)
  readVarString,
  // CASE 119: string
  (decoder) => {
    const len = readVarUint(decoder);
    const obj = {};
    for (let i = 0; i < len; i++) {
      const key = readVarString(decoder);
      obj[key] = readAny(decoder);
    }
    return obj;
  },
  (decoder) => {
    const len = readVarUint(decoder);
    const arr = [];
    for (let i = 0; i < len; i++) {
      arr.push(readAny(decoder));
    }
    return arr;
  },
  readVarUint8Array
  // CASE 116: Uint8Array
];
var readAny = /* @__PURE__ */ __name((decoder) => readAnyLookupTable[127 - readUint8(decoder)](decoder), "readAny");
var _RleDecoder = class _RleDecoder extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */
  constructor(uint8Array, reader) {
    super(uint8Array);
    this.reader = reader;
    this.s = null;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = this.reader(this);
      if (hasContent(this)) {
        this.count = readVarUint(this) + 1;
      } else {
        this.count = -1;
      }
    }
    this.count--;
    return (
      /** @type {T} */
      this.s
    );
  }
};
__name(_RleDecoder, "RleDecoder");
var RleDecoder = _RleDecoder;
var _UintOptRleDecoder = class _UintOptRleDecoder extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = readVarInt(this);
      const isNegative = isNegativeZero(this.s);
      this.count = 1;
      if (isNegative) {
        this.s = -this.s;
        this.count = readVarUint(this) + 2;
      }
    }
    this.count--;
    return (
      /** @type {number} */
      this.s
    );
  }
};
__name(_UintOptRleDecoder, "UintOptRleDecoder");
var UintOptRleDecoder = _UintOptRleDecoder;
var _IntDiffOptRleDecoder = class _IntDiffOptRleDecoder extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @return {number}
   */
  read() {
    if (this.count === 0) {
      const diff = readVarInt(this);
      const hasCount = diff & 1;
      this.diff = floor(diff / 2);
      this.count = 1;
      if (hasCount) {
        this.count = readVarUint(this) + 2;
      }
    }
    this.s += this.diff;
    this.count--;
    return this.s;
  }
};
__name(_IntDiffOptRleDecoder, "IntDiffOptRleDecoder");
var IntDiffOptRleDecoder = _IntDiffOptRleDecoder;
var _StringDecoder = class _StringDecoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    this.decoder = new UintOptRleDecoder(uint8Array);
    this.str = readVarString(this.decoder);
    this.spos = 0;
  }
  /**
   * @return {string}
   */
  read() {
    const end = this.spos + this.decoder.read();
    const res = this.str.slice(this.spos, end);
    this.spos = end;
    return res;
  }
};
__name(_StringDecoder, "StringDecoder");
var StringDecoder = _StringDecoder;

// node_modules/lib0/random.js
init_process_shim();

// node_modules/lib0/webcrypto.js
init_process_shim();
var subtle = crypto.subtle;
var getRandomValues2 = crypto.getRandomValues.bind(crypto);

// node_modules/lib0/random.js
var uint32 = /* @__PURE__ */ __name(() => getRandomValues2(new Uint32Array(1))[0], "uint32");
var uuidv4Template = "10000000-1000-4000-8000" + -1e11;
var uuidv4 = /* @__PURE__ */ __name(() => uuidv4Template.replace(
  /[018]/g,
  /** @param {number} c */
  (c) => (c ^ uint32() & 15 >> c / 4).toString(16)
), "uuidv4");

// node_modules/lib0/promise.js
init_process_shim();

// node_modules/lib0/time.js
init_process_shim();
var getUnixTime = Date.now;

// node_modules/lib0/promise.js
var create4 = /* @__PURE__ */ __name((f) => (
  /** @type {Promise<T>} */
  new Promise(f)
), "create");
var all3 = Promise.all.bind(Promise);

// node_modules/lib0/buffer.js
init_process_shim();

// node_modules/lib0/environment.js
init_process_shim();

// node_modules/lib0/conditions.js
init_process_shim();
var undefinedToNull = /* @__PURE__ */ __name((v) => v === void 0 ? null : v, "undefinedToNull");

// node_modules/lib0/storage.js
init_process_shim();
var _VarStoragePolyfill = class _VarStoragePolyfill {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(key, newValue) {
    this.map.set(key, newValue);
  }
  /**
   * @param {string} key
   */
  getItem(key) {
    return this.map.get(key);
  }
};
__name(_VarStoragePolyfill, "VarStoragePolyfill");
var VarStoragePolyfill = _VarStoragePolyfill;
var _localStorage = new VarStoragePolyfill();
var usePolyfill = true;
try {
  if (typeof localStorage !== "undefined" && localStorage) {
    _localStorage = localStorage;
    usePolyfill = false;
  }
} catch (e) {
}
var varStorage = _localStorage;

// node_modules/lib0/function.js
init_process_shim();

// node_modules/lib0/object.js
init_process_shim();
var assign = Object.assign;
var keys2 = Object.keys;
var forEach2 = /* @__PURE__ */ __name((obj, f) => {
  for (const key in obj) {
    f(obj[key], key);
  }
}, "forEach");
var size = /* @__PURE__ */ __name((obj) => keys2(obj).length, "size");
var isEmpty = /* @__PURE__ */ __name((obj) => {
  for (const _k in obj) {
    return false;
  }
  return true;
}, "isEmpty");
var every = /* @__PURE__ */ __name((obj, f) => {
  for (const key in obj) {
    if (!f(obj[key], key)) {
      return false;
    }
  }
  return true;
}, "every");
var hasProperty = /* @__PURE__ */ __name((obj, key) => Object.prototype.hasOwnProperty.call(obj, key), "hasProperty");
var equalFlat = /* @__PURE__ */ __name((a, b) => a === b || size(a) === size(b) && every(a, (val, key) => (val !== void 0 || hasProperty(b, key)) && b[key] === val), "equalFlat");
var freeze = Object.freeze;
var deepFreeze = /* @__PURE__ */ __name((o) => {
  for (const key in o) {
    const c = o[key];
    if (typeof c === "object" || typeof c === "function") {
      deepFreeze(o[key]);
    }
  }
  return freeze(o);
}, "deepFreeze");

// node_modules/lib0/function.js
var callAll = /* @__PURE__ */ __name((fs, args2, i = 0) => {
  try {
    for (; i < fs.length; i++) {
      fs[i](...args2);
    }
  } finally {
    if (i < fs.length) {
      callAll(fs, args2, i + 1);
    }
  }
}, "callAll");
var id = /* @__PURE__ */ __name((a) => a, "id");
var isOneOf = /* @__PURE__ */ __name((value, options) => options.includes(value), "isOneOf");

// node_modules/lib0/environment.js
var isNode = typeof import_browser.default !== "undefined" && import_browser.default.release && /node|io\.js/.test(import_browser.default.release.name) && Object.prototype.toString.call(typeof import_browser.default !== "undefined" ? import_browser.default : 0) === "[object process]";
var isMac = typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
var params;
var args = [];
var computeParams = /* @__PURE__ */ __name(() => {
  if (params === void 0) {
    if (isNode) {
      params = create();
      const pargs = import_browser.default.argv;
      let currParamName = null;
      for (let i = 0; i < pargs.length; i++) {
        const parg = pargs[i];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params.set(currParamName, parg);
            currParamName = null;
          } else {
            args.push(parg);
          }
        }
      }
      if (currParamName !== null) {
        params.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params = create();
      (location.search || "?").slice(1).split("&").forEach((kv) => {
        if (kv.length !== 0) {
          const [key, value] = kv.split("=");
          params.set(`--${fromCamelCase(key, "-")}`, value);
          params.set(`-${fromCamelCase(key, "-")}`, value);
        }
      });
    } else {
      params = create();
    }
  }
  return params;
}, "computeParams");
var hasParam = /* @__PURE__ */ __name((name) => computeParams().has(name), "hasParam");
var getVariable = /* @__PURE__ */ __name((name) => isNode ? undefinedToNull(import_browser.default.env[name.toUpperCase().replaceAll("-", "_")]) : undefinedToNull(varStorage.getItem(name)), "getVariable");
var hasConf = /* @__PURE__ */ __name((name) => hasParam("--" + name) || getVariable(name) !== null, "hasConf");
var production = hasConf("production");
var forceColor = isNode && isOneOf(import_browser.default.env.FORCE_COLOR, ["true", "1", "2"]);
var supportsColor = forceColor || !hasParam("--no-colors") && // @todo deprecate --no-colors
!hasConf("no-color") && (!isNode || import_browser.default.stdout.isTTY) && (!isNode || hasParam("--color") || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));

// node_modules/lib0/buffer.js
var createUint8ArrayFromLen = /* @__PURE__ */ __name((len) => new Uint8Array(len), "createUint8ArrayFromLen");
var copyUint8Array = /* @__PURE__ */ __name((uint8Array) => {
  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);
  newBuf.set(uint8Array);
  return newBuf;
}, "copyUint8Array");

// node_modules/lib0/logging.js
init_process_shim();

// node_modules/lib0/pair.js
init_process_shim();
var _Pair = class _Pair {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }
};
__name(_Pair, "Pair");
var Pair = _Pair;
var create5 = /* @__PURE__ */ __name((left, right) => new Pair(left, right), "create");
var forEach3 = /* @__PURE__ */ __name((arr, f) => arr.forEach((p) => f(p.left, p.right)), "forEach");

// node_modules/lib0/dom.js
init_process_shim();
var doc = (
  /** @type {Document} */
  typeof document !== "undefined" ? document : {}
);
var createElement = /* @__PURE__ */ __name((name) => doc.createElement(name), "createElement");
var createDocumentFragment = /* @__PURE__ */ __name(() => doc.createDocumentFragment(), "createDocumentFragment");
var createTextNode = /* @__PURE__ */ __name((text2) => doc.createTextNode(text2), "createTextNode");
var domParser = (
  /** @type {DOMParser} */
  typeof DOMParser !== "undefined" ? new DOMParser() : null
);
var setAttributes = /* @__PURE__ */ __name((el, attrs) => {
  forEach3(attrs, (key, value) => {
    if (value === false) {
      el.removeAttribute(key);
    } else if (value === true) {
      el.setAttribute(key, "");
    } else {
      el.setAttribute(key, value);
    }
  });
  return el;
}, "setAttributes");
var fragment = /* @__PURE__ */ __name((children) => {
  const fragment2 = createDocumentFragment();
  for (let i = 0; i < children.length; i++) {
    appendChild(fragment2, children[i]);
  }
  return fragment2;
}, "fragment");
var append2 = /* @__PURE__ */ __name((parent, nodes) => {
  appendChild(parent, fragment(nodes));
  return parent;
}, "append");
var element = /* @__PURE__ */ __name((name, attrs = [], children = []) => append2(setAttributes(createElement(name), attrs), children), "element");
var text = createTextNode;
var mapToStyleString = /* @__PURE__ */ __name((m) => map2(m, (value, key) => `${key}:${value};`).join(""), "mapToStyleString");
var appendChild = /* @__PURE__ */ __name((parent, child) => parent.appendChild(child), "appendChild");
var ELEMENT_NODE = doc.ELEMENT_NODE;
var TEXT_NODE = doc.TEXT_NODE;
var CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;
var COMMENT_NODE = doc.COMMENT_NODE;
var DOCUMENT_NODE = doc.DOCUMENT_NODE;
var DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;
var DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;

// node_modules/lib0/logging.common.js
init_process_shim();

// node_modules/lib0/symbol.js
init_process_shim();
var create6 = Symbol;

// node_modules/lib0/logging.common.js
var BOLD = create6();
var UNBOLD = create6();
var BLUE = create6();
var GREY = create6();
var GREEN = create6();
var RED = create6();
var PURPLE = create6();
var ORANGE = create6();
var UNCOLOR = create6();
var computeNoColorLoggingArgs = /* @__PURE__ */ __name((args2) => {
  var _a9;
  if (args2.length === 1 && ((_a9 = args2[0]) == null ? void 0 : _a9.constructor) === Function) {
    args2 = /** @type {Array<string|Symbol|Object|number>} */
    /** @type {[function]} */
    args2[0]();
  }
  const strBuilder = [];
  const logArgs = [];
  let i = 0;
  for (; i < args2.length; i++) {
    const arg = args2[i];
    if (arg === void 0) {
      break;
    } else if (arg.constructor === String || arg.constructor === Number) {
      strBuilder.push(arg);
    } else if (arg.constructor === Object) {
      break;
    }
  }
  if (i > 0) {
    logArgs.push(strBuilder.join(""));
  }
  for (; i < args2.length; i++) {
    const arg = args2[i];
    if (!(arg instanceof Symbol)) {
      logArgs.push(arg);
    }
  }
  return logArgs;
}, "computeNoColorLoggingArgs");
var lastLoggingTime = getUnixTime();

// node_modules/lib0/logging.js
var _browserStyleMap = {
  [BOLD]: create5("font-weight", "bold"),
  [UNBOLD]: create5("font-weight", "normal"),
  [BLUE]: create5("color", "blue"),
  [GREEN]: create5("color", "green"),
  [GREY]: create5("color", "grey"),
  [RED]: create5("color", "red"),
  [PURPLE]: create5("color", "purple"),
  [ORANGE]: create5("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [UNCOLOR]: create5("color", "black")
};
var computeBrowserLoggingArgs = /* @__PURE__ */ __name((args2) => {
  var _a9;
  if (args2.length === 1 && ((_a9 = args2[0]) == null ? void 0 : _a9.constructor) === Function) {
    args2 = /** @type {Array<string|Symbol|Object|number>} */
    /** @type {[function]} */
    args2[0]();
  }
  const strBuilder = [];
  const styles = [];
  const currentStyle = create();
  let logArgs = [];
  let i = 0;
  for (; i < args2.length; i++) {
    const arg = args2[i];
    const style = _browserStyleMap[arg];
    if (style !== void 0) {
      currentStyle.set(style.left, style.right);
    } else {
      if (arg === void 0) {
        break;
      }
      if (arg.constructor === String || arg.constructor === Number) {
        const style2 = mapToStyleString(currentStyle);
        if (i > 0 || style2.length > 0) {
          strBuilder.push("%c" + arg);
          styles.push(style2);
        } else {
          strBuilder.push(arg);
        }
      } else {
        break;
      }
    }
  }
  if (i > 0) {
    logArgs = styles;
    logArgs.unshift(strBuilder.join(""));
  }
  for (; i < args2.length; i++) {
    const arg = args2[i];
    if (!(arg instanceof Symbol)) {
      logArgs.push(arg);
    }
  }
  return logArgs;
}, "computeBrowserLoggingArgs");
var computeLoggingArgs = supportsColor ? computeBrowserLoggingArgs : computeNoColorLoggingArgs;
var print = /* @__PURE__ */ __name((...args2) => {
  console.log(...computeLoggingArgs(args2));
  vconsoles.forEach((vc) => vc.print(args2));
}, "print");
var warn = /* @__PURE__ */ __name((...args2) => {
  console.warn(...computeLoggingArgs(args2));
  args2.unshift(ORANGE);
  vconsoles.forEach((vc) => vc.print(args2));
}, "warn");
var vconsoles = create2();

// node_modules/lib0/iterator.js
init_process_shim();
var createIterator = /* @__PURE__ */ __name((next) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next
}), "createIterator");
var iteratorFilter = /* @__PURE__ */ __name((iterator3, filter2) => createIterator(() => {
  let res;
  do {
    res = iterator3.next();
  } while (!res.done && !filter2(res.value));
  return res;
}), "iteratorFilter");
var iteratorMap = /* @__PURE__ */ __name((iterator3, fmap) => createIterator(() => {
  const { done, value } = iterator3.next();
  return { done, value: done ? void 0 : fmap(value) };
}), "iteratorMap");

// node_modules/yjs/dist/yjs.mjs
var _DeleteItem = class _DeleteItem {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(clock, len) {
    this.clock = clock;
    this.len = len;
  }
};
__name(_DeleteItem, "DeleteItem");
var DeleteItem = _DeleteItem;
var _DeleteSet = class _DeleteSet {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
};
__name(_DeleteSet, "DeleteSet");
var DeleteSet = _DeleteSet;
var iterateDeletedStructs = /* @__PURE__ */ __name((transaction, ds, f) => ds.clients.forEach((deletes, clientid) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    transaction.doc.store.clients.get(clientid)
  );
  if (structs != null) {
    const lastStruct = structs[structs.length - 1];
    const clockState = lastStruct.id.clock + lastStruct.length;
    for (let i = 0, del2 = deletes[i]; i < deletes.length && del2.clock < clockState; del2 = deletes[++i]) {
      iterateStructs(transaction, structs, del2.clock, del2.len, f);
    }
  }
}), "iterateDeletedStructs");
var findIndexDS = /* @__PURE__ */ __name((dis, clock) => {
  let left = 0;
  let right = dis.length - 1;
  while (left <= right) {
    const midindex = floor((left + right) / 2);
    const mid = dis[midindex];
    const midclock = mid.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.len) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
  }
  return null;
}, "findIndexDS");
var isDeleted = /* @__PURE__ */ __name((ds, id2) => {
  const dis = ds.clients.get(id2.client);
  return dis !== void 0 && findIndexDS(dis, id2.clock) !== null;
}, "isDeleted");
var sortAndMergeDeleteSet = /* @__PURE__ */ __name((ds) => {
  ds.clients.forEach((dels) => {
    dels.sort((a, b) => a.clock - b.clock);
    let i, j;
    for (i = 1, j = 1; i < dels.length; i++) {
      const left = dels[j - 1];
      const right = dels[i];
      if (left.clock + left.len >= right.clock) {
        left.len = max(left.len, right.clock + right.len - left.clock);
      } else {
        if (j < i) {
          dels[j] = right;
        }
        j++;
      }
    }
    dels.length = j;
  });
}, "sortAndMergeDeleteSet");
var mergeDeleteSets = /* @__PURE__ */ __name((dss) => {
  const merged = new DeleteSet();
  for (let dssI = 0; dssI < dss.length; dssI++) {
    dss[dssI].clients.forEach((delsLeft, client) => {
      if (!merged.clients.has(client)) {
        const dels = delsLeft.slice();
        for (let i = dssI + 1; i < dss.length; i++) {
          appendTo(dels, dss[i].clients.get(client) || []);
        }
        merged.clients.set(client, dels);
      }
    });
  }
  sortAndMergeDeleteSet(merged);
  return merged;
}, "mergeDeleteSets");
var addToDeleteSet = /* @__PURE__ */ __name((ds, client, clock, length2) => {
  setIfUndefined(ds.clients, client, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new DeleteItem(clock, length2));
}, "addToDeleteSet");
var createDeleteSet = /* @__PURE__ */ __name(() => new DeleteSet(), "createDeleteSet");
var createDeleteSetFromStructStore = /* @__PURE__ */ __name((ss) => {
  const ds = createDeleteSet();
  ss.clients.forEach((structs, client) => {
    const dsitems = [];
    for (let i = 0; i < structs.length; i++) {
      const struct = structs[i];
      if (struct.deleted) {
        const clock = struct.id.clock;
        let len = struct.length;
        if (i + 1 < structs.length) {
          for (let next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1]) {
            len += next.length;
          }
        }
        dsitems.push(new DeleteItem(clock, len));
      }
    }
    if (dsitems.length > 0) {
      ds.clients.set(client, dsitems);
    }
  });
  return ds;
}, "createDeleteSetFromStructStore");
var writeDeleteSet = /* @__PURE__ */ __name((encoder, ds) => {
  writeVarUint(encoder.restEncoder, ds.clients.size);
  from2(ds.clients.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, dsitems]) => {
    encoder.resetDsCurVal();
    writeVarUint(encoder.restEncoder, client);
    const len = dsitems.length;
    writeVarUint(encoder.restEncoder, len);
    for (let i = 0; i < len; i++) {
      const item = dsitems[i];
      encoder.writeDsClock(item.clock);
      encoder.writeDsLen(item.len);
    }
  });
}, "writeDeleteSet");
var readDeleteSet = /* @__PURE__ */ __name((decoder) => {
  const ds = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numClients; i++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    if (numberOfDeletes > 0) {
      const dsField = setIfUndefined(ds.clients, client, () => (
        /** @type {Array<DeleteItem>} */
        []
      ));
      for (let i2 = 0; i2 < numberOfDeletes; i2++) {
        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));
      }
    }
  }
  return ds;
}, "readDeleteSet");
var readAndApplyDeleteSet = /* @__PURE__ */ __name((decoder, transaction, store) => {
  const unappliedDS = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numClients; i++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    const structs = store.clients.get(client) || [];
    const state = getState(store, client);
    for (let i2 = 0; i2 < numberOfDeletes; i2++) {
      const clock = decoder.readDsClock();
      const clockEnd = clock + decoder.readDsLen();
      if (clock < state) {
        if (state < clockEnd) {
          addToDeleteSet(unappliedDS, client, state, clockEnd - state);
        }
        let index = findIndexSS(structs, clock);
        let struct = structs[index];
        if (!struct.deleted && struct.id.clock < clock) {
          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
          index++;
        }
        while (index < structs.length) {
          struct = structs[index++];
          if (struct.id.clock < clockEnd) {
            if (!struct.deleted) {
              if (clockEnd < struct.id.clock + struct.length) {
                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));
              }
              struct.delete(transaction);
            }
          } else {
            break;
          }
        }
      } else {
        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);
      }
    }
  }
  if (unappliedDS.clients.size > 0) {
    const ds = new UpdateEncoderV2();
    writeVarUint(ds.restEncoder, 0);
    writeDeleteSet(ds, unappliedDS);
    return ds.toUint8Array();
  }
  return null;
}, "readAndApplyDeleteSet");
var generateNewClientId = uint32;
var _Doc = class _Doc extends ObservableV2 {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid = uuidv4(), collectionid = null, gc = true, gcFilter = /* @__PURE__ */ __name(() => true, "gcFilter"), meta = null, autoLoad = false, shouldLoad = true } = {}) {
    super();
    this.gc = gc;
    this.gcFilter = gcFilter;
    this.clientID = generateNewClientId();
    this.guid = guid;
    this.collectionid = collectionid;
    this.share = /* @__PURE__ */ new Map();
    this.store = new StructStore();
    this._transaction = null;
    this._transactionCleanups = [];
    this.subdocs = /* @__PURE__ */ new Set();
    this._item = null;
    this.shouldLoad = shouldLoad;
    this.autoLoad = autoLoad;
    this.meta = meta;
    this.isLoaded = false;
    this.isSynced = false;
    this.isDestroyed = false;
    this.whenLoaded = create4((resolve) => {
      this.on("load", () => {
        this.isLoaded = true;
        resolve(this);
      });
    });
    const provideSyncedPromise = /* @__PURE__ */ __name(() => create4((resolve) => {
      const eventHandler = /* @__PURE__ */ __name((isSynced) => {
        if (isSynced === void 0 || isSynced === true) {
          this.off("sync", eventHandler);
          resolve();
        }
      }, "eventHandler");
      this.on("sync", eventHandler);
    }), "provideSyncedPromise");
    this.on("sync", (isSynced) => {
      if (isSynced === false && this.isSynced) {
        this.whenSynced = provideSyncedPromise();
      }
      this.isSynced = isSynced === void 0 || isSynced === true;
      if (this.isSynced && !this.isLoaded) {
        this.emit("load", [this]);
      }
    });
    this.whenSynced = provideSyncedPromise();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const item = this._item;
    if (item !== null && !this.shouldLoad) {
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          transaction.subdocsLoaded.add(this);
        },
        null,
        true
      );
    }
    this.shouldLoad = true;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(from2(this.subdocs).map((doc2) => doc2.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(f, origin2 = null) {
    return transact(this, f, origin2);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`
   *
   * After this method is called, the type is also available on `ydoc.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Y.Doc instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const ydoc = new Y.Doc(..)
   *   const appState = {
   *     document: ydoc.getText('document')
   *     comments: ydoc.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(name, TypeConstructor = (
    /** @type {any} */
    AbstractType
  )) {
    const type = setIfUndefined(this.share, name, () => {
      const t = new TypeConstructor();
      t._integrate(this, null);
      return t;
    });
    const Constr = type.constructor;
    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
      if (Constr === AbstractType) {
        const t = new TypeConstructor();
        t._map = type._map;
        type._map.forEach(
          /** @param {Item?} n */
          (n) => {
            for (; n !== null; n = n.left) {
              n.parent = t;
            }
          }
        );
        t._start = type._start;
        for (let n = t._start; n !== null; n = n.right) {
          n.parent = t;
        }
        t._length = type._length;
        this.share.set(name, t);
        t._integrate(this, null);
        return (
          /** @type {InstanceType<Type>} */
          t
        );
      } else {
        throw new Error(`Type with the name ${name} has already been defined with a different constructor`);
      }
    }
    return (
      /** @type {InstanceType<Type>} */
      type
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(name = "") {
    return (
      /** @type {YArray<T>} */
      this.get(name, YArray)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(name = "") {
    return this.get(name, YText);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(name = "") {
    return (
      /** @type {YMap<T>} */
      this.get(name, YMap)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(name = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(name, YXmlElement)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(name = "") {
    return this.get(name, YXmlFragment);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const doc2 = {};
    this.share.forEach((value, key) => {
      doc2[key] = value.toJSON();
    });
    return doc2;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    this.isDestroyed = true;
    from2(this.subdocs).forEach((subdoc) => subdoc.destroy());
    const item = this._item;
    if (item !== null) {
      this._item = null;
      const content = (
        /** @type {ContentDoc} */
        item.content
      );
      content.doc = new _Doc({ guid: this.guid, ...content.opts, shouldLoad: false });
      content.doc._item = item;
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          const doc2 = content.doc;
          if (!item.deleted) {
            transaction.subdocsAdded.add(doc2);
          }
          transaction.subdocsRemoved.add(this);
        },
        null,
        true
      );
    }
    this.emit("destroyed", [true]);
    this.emit("destroy", [this]);
    super.destroy();
  }
};
__name(_Doc, "Doc");
var Doc = _Doc;
var _DSDecoderV1 = class _DSDecoderV1 {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number}
   */
  readDsLen() {
    return readVarUint(this.restDecoder);
  }
};
__name(_DSDecoderV1, "DSDecoderV1");
var DSDecoderV1 = _DSDecoderV1;
var _UpdateDecoderV1 = class _UpdateDecoderV1 extends DSDecoderV1 {
  /**
   * @return {ID}
   */
  readLeftID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return readUint8(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readString() {
    return readVarString(this.restDecoder);
  }
  /**
   * @return {boolean} isKey
   */
  readParentInfo() {
    return readVarUint(this.restDecoder) === 1;
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readTypeRef() {
    return readVarUint(this.restDecoder);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number} len
   */
  readLen() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return copyUint8Array(readVarUint8Array(this.restDecoder));
  }
  /**
   * Legacy implementation uses JSON parse. We use any-decoding in v2.
   *
   * @return {any}
   */
  readJSON() {
    return JSON.parse(readVarString(this.restDecoder));
  }
  /**
   * @return {string}
   */
  readKey() {
    return readVarString(this.restDecoder);
  }
};
__name(_UpdateDecoderV1, "UpdateDecoderV1");
var UpdateDecoderV1 = _UpdateDecoderV1;
var _DSDecoderV2 = class _DSDecoderV2 {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    this.dsCurrVal = 0;
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @return {number}
   */
  readDsClock() {
    this.dsCurrVal += readVarUint(this.restDecoder);
    return this.dsCurrVal;
  }
  /**
   * @return {number}
   */
  readDsLen() {
    const diff = readVarUint(this.restDecoder) + 1;
    this.dsCurrVal += diff;
    return diff;
  }
};
__name(_DSDecoderV2, "DSDecoderV2");
var DSDecoderV2 = _DSDecoderV2;
var _UpdateDecoderV2 = class _UpdateDecoderV2 extends DSDecoderV2 {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    super(decoder);
    this.keys = [];
    readVarUint(decoder);
    this.keyClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.clientDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.leftClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.rightClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.infoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.stringDecoder = new StringDecoder(readVarUint8Array(decoder));
    this.parentInfoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.typeRefDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.lenDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
  }
  /**
   * @return {ID}
   */
  readLeftID() {
    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return this.clientDecoder.read();
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return (
      /** @type {number} */
      this.infoDecoder.read()
    );
  }
  /**
   * @return {string}
   */
  readString() {
    return this.stringDecoder.read();
  }
  /**
   * @return {boolean}
   */
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  /**
   * @return {number} An unsigned 8-bit integer
   */
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */
  readLen() {
    return this.lenDecoder.read();
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return readVarUint8Array(this.restDecoder);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */
  readJSON() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readKey() {
    const keyClock = this.keyClockDecoder.read();
    if (keyClock < this.keys.length) {
      return this.keys[keyClock];
    } else {
      const key = this.stringDecoder.read();
      this.keys.push(key);
      return key;
    }
  }
};
__name(_UpdateDecoderV2, "UpdateDecoderV2");
var UpdateDecoderV2 = _UpdateDecoderV2;
var _DSEncoderV1 = class _DSEncoderV1 {
  constructor() {
    this.restEncoder = createEncoder();
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    writeVarUint(this.restEncoder, clock);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    writeVarUint(this.restEncoder, len);
  }
};
__name(_DSEncoderV1, "DSEncoderV1");
var DSEncoderV1 = _DSEncoderV1;
var _UpdateEncoderV1 = class _UpdateEncoderV1 extends DSEncoderV1 {
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(client) {
    writeVarUint(this.restEncoder, client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    writeUint8(this.restEncoder, info);
  }
  /**
   * @param {string} s
   */
  writeString(s) {
    writeVarString(this.restEncoder, s);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    writeVarUint(this.restEncoder, isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    writeVarUint(this.restEncoder, info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    writeVarUint(this.restEncoder, len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * @param {any} embed
   */
  writeJSON(embed) {
    writeVarString(this.restEncoder, JSON.stringify(embed));
  }
  /**
   * @param {string} key
   */
  writeKey(key) {
    writeVarString(this.restEncoder, key);
  }
};
__name(_UpdateEncoderV1, "UpdateEncoderV1");
var UpdateEncoderV1 = _UpdateEncoderV1;
var _DSEncoderV2 = class _DSEncoderV2 {
  constructor() {
    this.restEncoder = createEncoder();
    this.dsCurrVal = 0;
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    const diff = clock - this.dsCurrVal;
    this.dsCurrVal = clock;
    writeVarUint(this.restEncoder, diff);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    if (len === 0) {
      unexpectedCase();
    }
    writeVarUint(this.restEncoder, len - 1);
    this.dsCurrVal += len;
  }
};
__name(_DSEncoderV2, "DSEncoderV2");
var DSEncoderV2 = _DSEncoderV2;
var _UpdateEncoderV2 = class _UpdateEncoderV2 extends DSEncoderV2 {
  constructor() {
    super();
    this.keyMap = /* @__PURE__ */ new Map();
    this.keyClock = 0;
    this.keyClockEncoder = new IntDiffOptRleEncoder();
    this.clientEncoder = new UintOptRleEncoder();
    this.leftClockEncoder = new IntDiffOptRleEncoder();
    this.rightClockEncoder = new IntDiffOptRleEncoder();
    this.infoEncoder = new RleEncoder(writeUint8);
    this.stringEncoder = new StringEncoder();
    this.parentInfoEncoder = new RleEncoder(writeUint8);
    this.typeRefEncoder = new UintOptRleEncoder();
    this.lenEncoder = new UintOptRleEncoder();
  }
  toUint8Array() {
    const encoder = createEncoder();
    writeVarUint(encoder, 0);
    writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.infoEncoder));
    writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.parentInfoEncoder));
    writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());
    writeUint8Array(encoder, toUint8Array(this.restEncoder));
    return toUint8Array(encoder);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    this.clientEncoder.write(id2.client);
    this.leftClockEncoder.write(id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    this.clientEncoder.write(id2.client);
    this.rightClockEncoder.write(id2.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(client) {
    this.clientEncoder.write(client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    this.infoEncoder.write(info);
  }
  /**
   * @param {string} s
   */
  writeString(s) {
    this.stringEncoder.write(s);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    this.parentInfoEncoder.write(isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    this.typeRefEncoder.write(info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    this.lenEncoder.write(len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(embed) {
    writeAny(this.restEncoder, embed);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(key) {
    const clock = this.keyMap.get(key);
    if (clock === void 0) {
      this.keyClockEncoder.write(this.keyClock++);
      this.stringEncoder.write(key);
    } else {
      this.keyClockEncoder.write(clock);
    }
  }
};
__name(_UpdateEncoderV2, "UpdateEncoderV2");
var UpdateEncoderV2 = _UpdateEncoderV2;
var writeStructs = /* @__PURE__ */ __name((encoder, structs, client, clock) => {
  clock = max(clock, structs[0].id.clock);
  const startNewStructs = findIndexSS(structs, clock);
  writeVarUint(encoder.restEncoder, structs.length - startNewStructs);
  encoder.writeClient(client);
  writeVarUint(encoder.restEncoder, clock);
  const firstStruct = structs[startNewStructs];
  firstStruct.write(encoder, clock - firstStruct.id.clock);
  for (let i = startNewStructs + 1; i < structs.length; i++) {
    structs[i].write(encoder, 0);
  }
}, "writeStructs");
var writeClientsStructs = /* @__PURE__ */ __name((encoder, store, _sm) => {
  const sm = /* @__PURE__ */ new Map();
  _sm.forEach((clock, client) => {
    if (getState(store, client) > clock) {
      sm.set(client, clock);
    }
  });
  getStateVector(store).forEach((_clock, client) => {
    if (!_sm.has(client)) {
      sm.set(client, 0);
    }
  });
  writeVarUint(encoder.restEncoder, sm.size);
  from2(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {
    writeStructs(
      encoder,
      /** @type {Array<GC|Item>} */
      store.clients.get(client),
      client,
      clock
    );
  });
}, "writeClientsStructs");
var readClientsStructRefs = /* @__PURE__ */ __name((decoder, doc2) => {
  const clientRefs = create();
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numOfStateUpdates; i++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const refs = new Array(numberOfStructs);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    clientRefs.set(client, { i: 0, refs });
    for (let i2 = 0; i2 < numberOfStructs; i2++) {
      const info = decoder.readInfo();
      switch (BITS5 & info) {
        case 0: {
          const len = decoder.readLen();
          refs[i2] = new GC(createID(client, clock), len);
          clock += len;
          break;
        }
        case 10: {
          const len = readVarUint(decoder.restDecoder);
          refs[i2] = new Skip(createID(client, clock), len);
          clock += len;
          break;
        }
        default: {
          const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
          const struct = new Item(
            createID(client, clock),
            null,
            // left
            (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
            // origin
            null,
            // right
            (info & BIT7) === BIT7 ? decoder.readRightID() : null,
            // right origin
            cantCopyParentInfo ? decoder.readParentInfo() ? doc2.get(decoder.readString()) : decoder.readLeftID() : null,
            // parent
            cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
            // parentSub
            readItemContent(decoder, info)
            // item content
          );
          refs[i2] = struct;
          clock += struct.length;
        }
      }
    }
  }
  return clientRefs;
}, "readClientsStructRefs");
var integrateStructs = /* @__PURE__ */ __name((transaction, store, clientsStructRefs) => {
  const stack = [];
  let clientsStructRefsIds = from2(clientsStructRefs.keys()).sort((a, b) => a - b);
  if (clientsStructRefsIds.length === 0) {
    return null;
  }
  const getNextStructTarget = /* @__PURE__ */ __name(() => {
    if (clientsStructRefsIds.length === 0) {
      return null;
    }
    let nextStructsTarget = (
      /** @type {{i:number,refs:Array<GC|Item>}} */
      clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1])
    );
    while (nextStructsTarget.refs.length === nextStructsTarget.i) {
      clientsStructRefsIds.pop();
      if (clientsStructRefsIds.length > 0) {
        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */
        clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
      } else {
        return null;
      }
    }
    return nextStructsTarget;
  }, "getNextStructTarget");
  let curStructsTarget = getNextStructTarget();
  if (curStructsTarget === null) {
    return null;
  }
  const restStructs = new StructStore();
  const missingSV = /* @__PURE__ */ new Map();
  const updateMissingSv = /* @__PURE__ */ __name((client, clock) => {
    const mclock = missingSV.get(client);
    if (mclock == null || mclock > clock) {
      missingSV.set(client, clock);
    }
  }, "updateMissingSv");
  let stackHead = (
    /** @type {any} */
    curStructsTarget.refs[
      /** @type {any} */
      curStructsTarget.i++
    ]
  );
  const state = /* @__PURE__ */ new Map();
  const addStackToRestSS = /* @__PURE__ */ __name(() => {
    for (const item of stack) {
      const client = item.id.client;
      const inapplicableItems = clientsStructRefs.get(client);
      if (inapplicableItems) {
        inapplicableItems.i--;
        restStructs.clients.set(client, inapplicableItems.refs.slice(inapplicableItems.i));
        clientsStructRefs.delete(client);
        inapplicableItems.i = 0;
        inapplicableItems.refs = [];
      } else {
        restStructs.clients.set(client, [item]);
      }
      clientsStructRefsIds = clientsStructRefsIds.filter((c) => c !== client);
    }
    stack.length = 0;
  }, "addStackToRestSS");
  while (true) {
    if (stackHead.constructor !== Skip) {
      const localClock = setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));
      const offset = localClock - stackHead.id.clock;
      if (offset < 0) {
        stack.push(stackHead);
        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);
        addStackToRestSS();
      } else {
        const missing = stackHead.getMissing(transaction, store);
        if (missing !== null) {
          stack.push(stackHead);
          const structRefs = clientsStructRefs.get(
            /** @type {number} */
            missing
          ) || { refs: [], i: 0 };
          if (structRefs.refs.length === structRefs.i) {
            updateMissingSv(
              /** @type {number} */
              missing,
              getState(store, missing)
            );
            addStackToRestSS();
          } else {
            stackHead = structRefs.refs[structRefs.i++];
            continue;
          }
        } else if (offset === 0 || offset < stackHead.length) {
          stackHead.integrate(transaction, offset);
          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);
        }
      }
    }
    if (stack.length > 0) {
      stackHead = /** @type {GC|Item} */
      stack.pop();
    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {
      stackHead = /** @type {GC|Item} */
      curStructsTarget.refs[curStructsTarget.i++];
    } else {
      curStructsTarget = getNextStructTarget();
      if (curStructsTarget === null) {
        break;
      } else {
        stackHead = /** @type {GC|Item} */
        curStructsTarget.refs[curStructsTarget.i++];
      }
    }
  }
  if (restStructs.clients.size > 0) {
    const encoder = new UpdateEncoderV2();
    writeClientsStructs(encoder, restStructs, /* @__PURE__ */ new Map());
    writeVarUint(encoder.restEncoder, 0);
    return { missing: missingSV, update: encoder.toUint8Array() };
  }
  return null;
}, "integrateStructs");
var writeStructsFromTransaction = /* @__PURE__ */ __name((encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState), "writeStructsFromTransaction");
var readUpdateV2 = /* @__PURE__ */ __name((decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) => transact(ydoc, (transaction) => {
  transaction.local = false;
  let retry = false;
  const doc2 = transaction.doc;
  const store = doc2.store;
  const ss = readClientsStructRefs(structDecoder, doc2);
  const restStructs = integrateStructs(transaction, store, ss);
  const pending = store.pendingStructs;
  if (pending) {
    for (const [client, clock] of pending.missing) {
      if (clock < getState(store, client)) {
        retry = true;
        break;
      }
    }
    if (restStructs) {
      for (const [client, clock] of restStructs.missing) {
        const mclock = pending.missing.get(client);
        if (mclock == null || mclock > clock) {
          pending.missing.set(client, clock);
        }
      }
      pending.update = mergeUpdatesV2([pending.update, restStructs.update]);
    }
  } else {
    store.pendingStructs = restStructs;
  }
  const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);
  if (store.pendingDs) {
    const pendingDSUpdate = new UpdateDecoderV2(createDecoder(store.pendingDs));
    readVarUint(pendingDSUpdate.restDecoder);
    const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);
    if (dsRest && dsRest2) {
      store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);
    } else {
      store.pendingDs = dsRest || dsRest2;
    }
  } else {
    store.pendingDs = dsRest;
  }
  if (retry) {
    const update = (
      /** @type {{update: Uint8Array}} */
      store.pendingStructs.update
    );
    store.pendingStructs = null;
    applyUpdateV2(transaction.doc, update);
  }
}, transactionOrigin, false), "readUpdateV2");
var applyUpdateV2 = /* @__PURE__ */ __name((ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {
  const decoder = createDecoder(update);
  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));
}, "applyUpdateV2");
var applyUpdate = /* @__PURE__ */ __name((ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1), "applyUpdate");
var writeStateAsUpdate = /* @__PURE__ */ __name((encoder, doc2, targetStateVector = /* @__PURE__ */ new Map()) => {
  writeClientsStructs(encoder, doc2.store, targetStateVector);
  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc2.store));
}, "writeStateAsUpdate");
var encodeStateAsUpdateV2 = /* @__PURE__ */ __name((doc2, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {
  const targetStateVector = decodeStateVector(encodedTargetStateVector);
  writeStateAsUpdate(encoder, doc2, targetStateVector);
  const updates = [encoder.toUint8Array()];
  if (doc2.store.pendingDs) {
    updates.push(doc2.store.pendingDs);
  }
  if (doc2.store.pendingStructs) {
    updates.push(diffUpdateV2(doc2.store.pendingStructs.update, encodedTargetStateVector));
  }
  if (updates.length > 1) {
    if (encoder.constructor === UpdateEncoderV1) {
      return mergeUpdates(updates.map((update, i) => i === 0 ? update : convertUpdateFormatV2ToV1(update)));
    } else if (encoder.constructor === UpdateEncoderV2) {
      return mergeUpdatesV2(updates);
    }
  }
  return updates[0];
}, "encodeStateAsUpdateV2");
var encodeStateAsUpdate = /* @__PURE__ */ __name((doc2, encodedTargetStateVector) => encodeStateAsUpdateV2(doc2, encodedTargetStateVector, new UpdateEncoderV1()), "encodeStateAsUpdate");
var readStateVector = /* @__PURE__ */ __name((decoder) => {
  const ss = /* @__PURE__ */ new Map();
  const ssLength = readVarUint(decoder.restDecoder);
  for (let i = 0; i < ssLength; i++) {
    const client = readVarUint(decoder.restDecoder);
    const clock = readVarUint(decoder.restDecoder);
    ss.set(client, clock);
  }
  return ss;
}, "readStateVector");
var decodeStateVector = /* @__PURE__ */ __name((decodedState) => readStateVector(new DSDecoderV1(createDecoder(decodedState))), "decodeStateVector");
var writeStateVector = /* @__PURE__ */ __name((encoder, sv) => {
  writeVarUint(encoder.restEncoder, sv.size);
  from2(sv.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {
    writeVarUint(encoder.restEncoder, client);
    writeVarUint(encoder.restEncoder, clock);
  });
  return encoder;
}, "writeStateVector");
var writeDocumentStateVector = /* @__PURE__ */ __name((encoder, doc2) => writeStateVector(encoder, getStateVector(doc2.store)), "writeDocumentStateVector");
var encodeStateVectorV2 = /* @__PURE__ */ __name((doc2, encoder = new DSEncoderV2()) => {
  if (doc2 instanceof Map) {
    writeStateVector(encoder, doc2);
  } else {
    writeDocumentStateVector(encoder, doc2);
  }
  return encoder.toUint8Array();
}, "encodeStateVectorV2");
var encodeStateVector = /* @__PURE__ */ __name((doc2) => encodeStateVectorV2(doc2, new DSEncoderV1()), "encodeStateVector");
var _EventHandler = class _EventHandler {
  constructor() {
    this.l = [];
  }
};
__name(_EventHandler, "EventHandler");
var EventHandler = _EventHandler;
var createEventHandler = /* @__PURE__ */ __name(() => new EventHandler(), "createEventHandler");
var addEventHandlerListener = /* @__PURE__ */ __name((eventHandler, f) => eventHandler.l.push(f), "addEventHandlerListener");
var removeEventHandlerListener = /* @__PURE__ */ __name((eventHandler, f) => {
  const l = eventHandler.l;
  const len = l.length;
  eventHandler.l = l.filter((g) => f !== g);
  if (len === eventHandler.l.length) {
    console.error("[yjs] Tried to remove event handler that doesn't exist.");
  }
}, "removeEventHandlerListener");
var callEventHandlerListeners = /* @__PURE__ */ __name((eventHandler, arg0, arg1) => callAll(eventHandler.l, [arg0, arg1]), "callEventHandlerListeners");
var _ID = class _ID {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(client, clock) {
    this.client = client;
    this.clock = clock;
  }
};
__name(_ID, "ID");
var ID = _ID;
var compareIDs = /* @__PURE__ */ __name((a, b) => a === b || a !== null && b !== null && a.client === b.client && a.clock === b.clock, "compareIDs");
var createID = /* @__PURE__ */ __name((client, clock) => new ID(client, clock), "createID");
var findRootTypeKey = /* @__PURE__ */ __name((type) => {
  for (const [key, value] of type.doc.share.entries()) {
    if (value === type) {
      return key;
    }
  }
  throw unexpectedCase();
}, "findRootTypeKey");
var _RelativePosition = class _RelativePosition {
  /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */
  constructor(type, tname, item, assoc = 0) {
    this.type = type;
    this.tname = tname;
    this.item = item;
    this.assoc = assoc;
  }
};
__name(_RelativePosition, "RelativePosition");
var RelativePosition = _RelativePosition;
var _AbsolutePosition = class _AbsolutePosition {
  /**
   * @param {AbstractType<any>} type
   * @param {number} index
   * @param {number} [assoc]
   */
  constructor(type, index, assoc = 0) {
    this.type = type;
    this.index = index;
    this.assoc = assoc;
  }
};
__name(_AbsolutePosition, "AbsolutePosition");
var AbsolutePosition = _AbsolutePosition;
var createAbsolutePosition = /* @__PURE__ */ __name((type, index, assoc = 0) => new AbsolutePosition(type, index, assoc), "createAbsolutePosition");
var createRelativePosition = /* @__PURE__ */ __name((type, item, assoc) => {
  let typeid = null;
  let tname = null;
  if (type._item === null) {
    tname = findRootTypeKey(type);
  } else {
    typeid = createID(type._item.id.client, type._item.id.clock);
  }
  return new RelativePosition(typeid, tname, item, assoc);
}, "createRelativePosition");
var createRelativePositionFromTypeIndex = /* @__PURE__ */ __name((type, index, assoc = 0) => {
  let t = type._start;
  if (assoc < 0) {
    if (index === 0) {
      return createRelativePosition(type, null, assoc);
    }
    index--;
  }
  while (t !== null) {
    if (!t.deleted && t.countable) {
      if (t.length > index) {
        return createRelativePosition(type, createID(t.id.client, t.id.clock + index), assoc);
      }
      index -= t.length;
    }
    if (t.right === null && assoc < 0) {
      return createRelativePosition(type, t.lastId, assoc);
    }
    t = t.right;
  }
  return createRelativePosition(type, null, assoc);
}, "createRelativePositionFromTypeIndex");
var getItemWithOffset = /* @__PURE__ */ __name((store, id2) => {
  const item = getItem(store, id2);
  const diff = id2.clock - item.id.clock;
  return {
    item,
    diff
  };
}, "getItemWithOffset");
var createAbsolutePositionFromRelativePosition = /* @__PURE__ */ __name((rpos, doc2, followUndoneDeletions = true) => {
  const store = doc2.store;
  const rightID = rpos.item;
  const typeID = rpos.type;
  const tname = rpos.tname;
  const assoc = rpos.assoc;
  let type = null;
  let index = 0;
  if (rightID !== null) {
    if (getState(store, rightID.client) <= rightID.clock) {
      return null;
    }
    const res = followUndoneDeletions ? followRedone(store, rightID) : getItemWithOffset(store, rightID);
    const right = res.item;
    if (!(right instanceof Item)) {
      return null;
    }
    type = /** @type {AbstractType<any>} */
    right.parent;
    if (type._item === null || !type._item.deleted) {
      index = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1);
      let n = right.left;
      while (n !== null) {
        if (!n.deleted && n.countable) {
          index += n.length;
        }
        n = n.left;
      }
    }
  } else {
    if (tname !== null) {
      type = doc2.get(tname);
    } else if (typeID !== null) {
      if (getState(store, typeID.client) <= typeID.clock) {
        return null;
      }
      const { item } = followUndoneDeletions ? followRedone(store, typeID) : { item: getItem(store, typeID) };
      if (item instanceof Item && item.content instanceof ContentType) {
        type = item.content.type;
      } else {
        return null;
      }
    } else {
      throw unexpectedCase();
    }
    if (assoc >= 0) {
      index = type._length;
    } else {
      index = 0;
    }
  }
  return createAbsolutePosition(type, index, rpos.assoc);
}, "createAbsolutePositionFromRelativePosition");
var compareRelativePositions = /* @__PURE__ */ __name((a, b) => a === b || a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc, "compareRelativePositions");
var _Snapshot = class _Snapshot {
  /**
   * @param {DeleteSet} ds
   * @param {Map<number,number>} sv state map
   */
  constructor(ds, sv) {
    this.ds = ds;
    this.sv = sv;
  }
};
__name(_Snapshot, "Snapshot");
var Snapshot = _Snapshot;
var createSnapshot = /* @__PURE__ */ __name((ds, sm) => new Snapshot(ds, sm), "createSnapshot");
var emptySnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());
var isVisible = /* @__PURE__ */ __name((item, snapshot) => snapshot === void 0 ? !item.deleted : snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id), "isVisible");
var splitSnapshotAffectedStructs = /* @__PURE__ */ __name((transaction, snapshot) => {
  const meta = setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, create2);
  const store = transaction.doc.store;
  if (!meta.has(snapshot)) {
    snapshot.sv.forEach((clock, client) => {
      if (clock < getState(store, client)) {
        getItemCleanStart(transaction, createID(client, clock));
      }
    });
    iterateDeletedStructs(transaction, snapshot.ds, (_item) => {
    });
    meta.add(snapshot);
  }
}, "splitSnapshotAffectedStructs");
var _StructStore = class _StructStore {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
    this.pendingStructs = null;
    this.pendingDs = null;
  }
};
__name(_StructStore, "StructStore");
var StructStore = _StructStore;
var getStateVector = /* @__PURE__ */ __name((store) => {
  const sm = /* @__PURE__ */ new Map();
  store.clients.forEach((structs, client) => {
    const struct = structs[structs.length - 1];
    sm.set(client, struct.id.clock + struct.length);
  });
  return sm;
}, "getStateVector");
var getState = /* @__PURE__ */ __name((store, client) => {
  const structs = store.clients.get(client);
  if (structs === void 0) {
    return 0;
  }
  const lastStruct = structs[structs.length - 1];
  return lastStruct.id.clock + lastStruct.length;
}, "getState");
var addStruct = /* @__PURE__ */ __name((store, struct) => {
  let structs = store.clients.get(struct.id.client);
  if (structs === void 0) {
    structs = [];
    store.clients.set(struct.id.client, structs);
  } else {
    const lastStruct = structs[structs.length - 1];
    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {
      throw unexpectedCase();
    }
  }
  structs.push(struct);
}, "addStruct");
var findIndexSS = /* @__PURE__ */ __name((structs, clock) => {
  let left = 0;
  let right = structs.length - 1;
  let mid = structs[right];
  let midclock = mid.id.clock;
  if (midclock === clock) {
    return right;
  }
  let midindex = floor(clock / (midclock + mid.length - 1) * right);
  while (left <= right) {
    mid = structs[midindex];
    midclock = mid.id.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.length) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
    midindex = floor((left + right) / 2);
  }
  throw unexpectedCase();
}, "findIndexSS");
var find = /* @__PURE__ */ __name((store, id2) => {
  const structs = store.clients.get(id2.client);
  return structs[findIndexSS(structs, id2.clock)];
}, "find");
var getItem = (
  /** @type {function(StructStore,ID):Item} */
  find
);
var findIndexCleanStart = /* @__PURE__ */ __name((transaction, structs, clock) => {
  const index = findIndexSS(structs, clock);
  const struct = structs[index];
  if (struct.id.clock < clock && struct instanceof Item) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
    return index + 1;
  }
  return index;
}, "findIndexCleanStart");
var getItemCleanStart = /* @__PURE__ */ __name((transaction, id2) => {
  const structs = (
    /** @type {Array<Item>} */
    transaction.doc.store.clients.get(id2.client)
  );
  return structs[findIndexCleanStart(transaction, structs, id2.clock)];
}, "getItemCleanStart");
var getItemCleanEnd = /* @__PURE__ */ __name((transaction, store, id2) => {
  const structs = store.clients.get(id2.client);
  const index = findIndexSS(structs, id2.clock);
  const struct = structs[index];
  if (id2.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, id2.clock - struct.id.clock + 1));
  }
  return struct;
}, "getItemCleanEnd");
var replaceStruct = /* @__PURE__ */ __name((store, struct, newStruct) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    store.clients.get(struct.id.client)
  );
  structs[findIndexSS(structs, struct.id.clock)] = newStruct;
}, "replaceStruct");
var iterateStructs = /* @__PURE__ */ __name((transaction, structs, clockStart, len, f) => {
  if (len === 0) {
    return;
  }
  const clockEnd = clockStart + len;
  let index = findIndexCleanStart(transaction, structs, clockStart);
  let struct;
  do {
    struct = structs[index++];
    if (clockEnd < struct.id.clock + struct.length) {
      findIndexCleanStart(transaction, structs, clockEnd);
    }
    f(struct);
  } while (index < structs.length && structs[index].id.clock < clockEnd);
}, "iterateStructs");
var _Transaction = class _Transaction {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(doc2, origin2, local) {
    this.doc = doc2;
    this.deleteSet = new DeleteSet();
    this.beforeState = getStateVector(doc2.store);
    this.afterState = /* @__PURE__ */ new Map();
    this.changed = /* @__PURE__ */ new Map();
    this.changedParentTypes = /* @__PURE__ */ new Map();
    this._mergeStructs = [];
    this.origin = origin2;
    this.meta = /* @__PURE__ */ new Map();
    this.local = local;
    this.subdocsAdded = /* @__PURE__ */ new Set();
    this.subdocsRemoved = /* @__PURE__ */ new Set();
    this.subdocsLoaded = /* @__PURE__ */ new Set();
    this._needFormattingCleanup = false;
  }
};
__name(_Transaction, "Transaction");
var Transaction = _Transaction;
var writeUpdateMessageFromTransaction = /* @__PURE__ */ __name((encoder, transaction) => {
  if (transaction.deleteSet.clients.size === 0 && !any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {
    return false;
  }
  sortAndMergeDeleteSet(transaction.deleteSet);
  writeStructsFromTransaction(encoder, transaction);
  writeDeleteSet(encoder, transaction.deleteSet);
  return true;
}, "writeUpdateMessageFromTransaction");
var addChangedTypeToTransaction = /* @__PURE__ */ __name((transaction, type, parentSub) => {
  const item = type._item;
  if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {
    setIfUndefined(transaction.changed, type, create2).add(parentSub);
  }
}, "addChangedTypeToTransaction");
var tryToMergeWithLefts = /* @__PURE__ */ __name((structs, pos) => {
  let right = structs[pos];
  let left = structs[pos - 1];
  let i = pos;
  for (; i > 0; right = left, left = structs[--i - 1]) {
    if (left.deleted === right.deleted && left.constructor === right.constructor) {
      if (left.mergeWith(right)) {
        if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */
        right.parent._map.get(right.parentSub) === right) {
          right.parent._map.set(
            right.parentSub,
            /** @type {Item} */
            left
          );
        }
        continue;
      }
    }
    break;
  }
  const merged = pos - i;
  if (merged) {
    structs.splice(pos + 1 - merged, merged);
  }
  return merged;
}, "tryToMergeWithLefts");
var tryGcDeleteSet = /* @__PURE__ */ __name((ds, store, gcFilter) => {
  for (const [client, deleteItems] of ds.clients.entries()) {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const endDeleteItemClock = deleteItem.clock + deleteItem.len;
      for (let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]) {
        const struct2 = structs[si];
        if (deleteItem.clock + deleteItem.len <= struct2.id.clock) {
          break;
        }
        if (struct2 instanceof Item && struct2.deleted && !struct2.keep && gcFilter(struct2)) {
          struct2.gc(store, false);
        }
      }
    }
  }
}, "tryGcDeleteSet");
var tryMergeDeleteSet = /* @__PURE__ */ __name((ds, store) => {
  ds.clients.forEach((deleteItems, client) => {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const mostRightIndexToCheck = min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
      for (let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si]) {
        si -= 1 + tryToMergeWithLefts(structs, si);
      }
    }
  });
}, "tryMergeDeleteSet");
var cleanupTransactions = /* @__PURE__ */ __name((transactionCleanups, i) => {
  if (i < transactionCleanups.length) {
    const transaction = transactionCleanups[i];
    const doc2 = transaction.doc;
    const store = doc2.store;
    const ds = transaction.deleteSet;
    const mergeStructs = transaction._mergeStructs;
    try {
      sortAndMergeDeleteSet(ds);
      transaction.afterState = getStateVector(transaction.doc.store);
      doc2.emit("beforeObserverCalls", [transaction, doc2]);
      const fs = [];
      transaction.changed.forEach(
        (subs, itemtype) => fs.push(() => {
          if (itemtype._item === null || !itemtype._item.deleted) {
            itemtype._callObserver(transaction, subs);
          }
        })
      );
      fs.push(() => {
        transaction.changedParentTypes.forEach((events, type) => {
          if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {
            events = events.filter(
              (event) => event.target._item === null || !event.target._item.deleted
            );
            events.forEach((event) => {
              event.currentTarget = type;
              event._path = null;
            });
            events.sort((event1, event2) => event1.path.length - event2.path.length);
            callEventHandlerListeners(type._dEH, events, transaction);
          }
        });
      });
      fs.push(() => doc2.emit("afterTransaction", [transaction, doc2]));
      callAll(fs, []);
      if (transaction._needFormattingCleanup) {
        cleanupYTextAfterTransaction(transaction);
      }
    } finally {
      if (doc2.gc) {
        tryGcDeleteSet(ds, store, doc2.gcFilter);
      }
      tryMergeDeleteSet(ds, store);
      transaction.afterState.forEach((clock, client) => {
        const beforeClock = transaction.beforeState.get(client) || 0;
        if (beforeClock !== clock) {
          const structs = (
            /** @type {Array<GC|Item>} */
            store.clients.get(client)
          );
          const firstChangePos = max(findIndexSS(structs, beforeClock), 1);
          for (let i2 = structs.length - 1; i2 >= firstChangePos; ) {
            i2 -= 1 + tryToMergeWithLefts(structs, i2);
          }
        }
      });
      for (let i2 = mergeStructs.length - 1; i2 >= 0; i2--) {
        const { client, clock } = mergeStructs[i2].id;
        const structs = (
          /** @type {Array<GC|Item>} */
          store.clients.get(client)
        );
        const replacedStructPos = findIndexSS(structs, clock);
        if (replacedStructPos + 1 < structs.length) {
          if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {
            continue;
          }
        }
        if (replacedStructPos > 0) {
          tryToMergeWithLefts(structs, replacedStructPos);
        }
      }
      if (!transaction.local && transaction.afterState.get(doc2.clientID) !== transaction.beforeState.get(doc2.clientID)) {
        print(ORANGE, BOLD, "[yjs] ", UNBOLD, RED, "Changed the client-id because another client seems to be using it.");
        doc2.clientID = generateNewClientId();
      }
      doc2.emit("afterTransactionCleanup", [transaction, doc2]);
      if (doc2._observers.has("update")) {
        const encoder = new UpdateEncoderV1();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc2.emit("update", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      if (doc2._observers.has("updateV2")) {
        const encoder = new UpdateEncoderV2();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc2.emit("updateV2", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
      if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
        subdocsAdded.forEach((subdoc) => {
          subdoc.clientID = doc2.clientID;
          if (subdoc.collectionid == null) {
            subdoc.collectionid = doc2.collectionid;
          }
          doc2.subdocs.add(subdoc);
        });
        subdocsRemoved.forEach((subdoc) => doc2.subdocs.delete(subdoc));
        doc2.emit("subdocs", [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc2, transaction]);
        subdocsRemoved.forEach((subdoc) => subdoc.destroy());
      }
      if (transactionCleanups.length <= i + 1) {
        doc2._transactionCleanups = [];
        doc2.emit("afterAllTransactions", [doc2, transactionCleanups]);
      } else {
        cleanupTransactions(transactionCleanups, i + 1);
      }
    }
  }
}, "cleanupTransactions");
var transact = /* @__PURE__ */ __name((doc2, f, origin2 = null, local = true) => {
  const transactionCleanups = doc2._transactionCleanups;
  let initialCall = false;
  let result = null;
  if (doc2._transaction === null) {
    initialCall = true;
    doc2._transaction = new Transaction(doc2, origin2, local);
    transactionCleanups.push(doc2._transaction);
    if (transactionCleanups.length === 1) {
      doc2.emit("beforeAllTransactions", [doc2]);
    }
    doc2.emit("beforeTransaction", [doc2._transaction, doc2]);
  }
  try {
    result = f(doc2._transaction);
  } finally {
    if (initialCall) {
      const finishCleanup = doc2._transaction === transactionCleanups[0];
      doc2._transaction = null;
      if (finishCleanup) {
        cleanupTransactions(transactionCleanups, 0);
      }
    }
  }
  return result;
}, "transact");
function* lazyStructReaderGenerator(decoder) {
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numOfStateUpdates; i++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    for (let i2 = 0; i2 < numberOfStructs; i2++) {
      const info = decoder.readInfo();
      if (info === 10) {
        const len = readVarUint(decoder.restDecoder);
        yield new Skip(createID(client, clock), len);
        clock += len;
      } else if ((BITS5 & info) !== 0) {
        const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
        const struct = new Item(
          createID(client, clock),
          null,
          // left
          (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
          // origin
          null,
          // right
          (info & BIT7) === BIT7 ? decoder.readRightID() : null,
          // right origin
          // @ts-ignore Force writing a string here.
          cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null,
          // parent
          cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
          // parentSub
          readItemContent(decoder, info)
          // item content
        );
        yield struct;
        clock += struct.length;
      } else {
        const len = decoder.readLen();
        yield new GC(createID(client, clock), len);
        clock += len;
      }
    }
  }
}
__name(lazyStructReaderGenerator, "lazyStructReaderGenerator");
var _LazyStructReader = class _LazyStructReader {
  /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */
  constructor(decoder, filterSkips) {
    this.gen = lazyStructReaderGenerator(decoder);
    this.curr = null;
    this.done = false;
    this.filterSkips = filterSkips;
    this.next();
  }
  /**
   * @return {Item | GC | Skip |null}
   */
  next() {
    do {
      this.curr = this.gen.next().value || null;
    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);
    return this.curr;
  }
};
__name(_LazyStructReader, "LazyStructReader");
var LazyStructReader = _LazyStructReader;
var _LazyStructWriter = class _LazyStructWriter {
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  constructor(encoder) {
    this.currClient = 0;
    this.startClock = 0;
    this.written = 0;
    this.encoder = encoder;
    this.clientStructs = [];
  }
};
__name(_LazyStructWriter, "LazyStructWriter");
var LazyStructWriter = _LazyStructWriter;
var mergeUpdates = /* @__PURE__ */ __name((updates) => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1), "mergeUpdates");
var sliceStruct = /* @__PURE__ */ __name((left, diff) => {
  if (left.constructor === GC) {
    const { client, clock } = left.id;
    return new GC(createID(client, clock + diff), left.length - diff);
  } else if (left.constructor === Skip) {
    const { client, clock } = left.id;
    return new Skip(createID(client, clock + diff), left.length - diff);
  } else {
    const leftItem = (
      /** @type {Item} */
      left
    );
    const { client, clock } = leftItem.id;
    return new Item(
      createID(client, clock + diff),
      null,
      createID(client, clock + diff - 1),
      null,
      leftItem.rightOrigin,
      leftItem.parent,
      leftItem.parentSub,
      leftItem.content.splice(diff)
    );
  }
}, "sliceStruct");
var mergeUpdatesV2 = /* @__PURE__ */ __name((updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  if (updates.length === 1) {
    return updates[0];
  }
  const updateDecoders = updates.map((update) => new YDecoder(createDecoder(update)));
  let lazyStructDecoders = updateDecoders.map((decoder) => new LazyStructReader(decoder, true));
  let currWrite = null;
  const updateEncoder = new YEncoder();
  const lazyStructEncoder = new LazyStructWriter(updateEncoder);
  while (true) {
    lazyStructDecoders = lazyStructDecoders.filter((dec) => dec.curr !== null);
    lazyStructDecoders.sort(
      /** @type {function(any,any):number} */
      (dec1, dec2) => {
        if (dec1.curr.id.client === dec2.curr.id.client) {
          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
          if (clockDiff === 0) {
            return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1;
          } else {
            return clockDiff;
          }
        } else {
          return dec2.curr.id.client - dec1.curr.id.client;
        }
      }
    );
    if (lazyStructDecoders.length === 0) {
      break;
    }
    const currDecoder = lazyStructDecoders[0];
    const firstClient = (
      /** @type {Item | GC} */
      currDecoder.curr.id.client
    );
    if (currWrite !== null) {
      let curr = (
        /** @type {Item | GC | null} */
        currDecoder.curr
      );
      let iterated = false;
      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {
        curr = currDecoder.next();
        iterated = true;
      }
      if (curr === null || // current decoder is empty
      curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`
      iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) {
        continue;
      }
      if (firstClient !== currWrite.struct.id.client) {
        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
        currWrite = { struct: curr, offset: 0 };
        currDecoder.next();
      } else {
        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
          if (currWrite.struct.constructor === Skip) {
            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
          } else {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);
            currWrite = { struct, offset: 0 };
          }
        } else {
          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
          if (diff > 0) {
            if (currWrite.struct.constructor === Skip) {
              currWrite.struct.length -= diff;
            } else {
              curr = sliceStruct(curr, diff);
            }
          }
          if (!currWrite.struct.mergeWith(
            /** @type {any} */
            curr
          )) {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            currWrite = { struct: curr, offset: 0 };
            currDecoder.next();
          }
        }
      }
    } else {
      currWrite = { struct: (
        /** @type {Item | GC} */
        currDecoder.curr
      ), offset: 0 };
      currDecoder.next();
    }
    for (let next = currDecoder.curr; next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()) {
      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
      currWrite = { struct: next, offset: 0 };
    }
  }
  if (currWrite !== null) {
    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
    currWrite = null;
  }
  finishLazyStructWriting(lazyStructEncoder);
  const dss = updateDecoders.map((decoder) => readDeleteSet(decoder));
  const ds = mergeDeleteSets(dss);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
}, "mergeUpdatesV2");
var diffUpdateV2 = /* @__PURE__ */ __name((update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  const state = decodeStateVector(sv);
  const encoder = new YEncoder();
  const lazyStructWriter = new LazyStructWriter(encoder);
  const decoder = new YDecoder(createDecoder(update));
  const reader = new LazyStructReader(decoder, false);
  while (reader.curr) {
    const curr = reader.curr;
    const currClient = curr.id.client;
    const svClock = state.get(currClient) || 0;
    if (reader.curr.constructor === Skip) {
      reader.next();
      continue;
    }
    if (curr.id.clock + curr.length > svClock) {
      writeStructToLazyStructWriter(lazyStructWriter, curr, max(svClock - curr.id.clock, 0));
      reader.next();
      while (reader.curr && reader.curr.id.client === currClient) {
        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);
        reader.next();
      }
    } else {
      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {
        reader.next();
      }
    }
  }
  finishLazyStructWriting(lazyStructWriter);
  const ds = readDeleteSet(decoder);
  writeDeleteSet(encoder, ds);
  return encoder.toUint8Array();
}, "diffUpdateV2");
var flushLazyStructWriter = /* @__PURE__ */ __name((lazyWriter) => {
  if (lazyWriter.written > 0) {
    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: toUint8Array(lazyWriter.encoder.restEncoder) });
    lazyWriter.encoder.restEncoder = createEncoder();
    lazyWriter.written = 0;
  }
}, "flushLazyStructWriter");
var writeStructToLazyStructWriter = /* @__PURE__ */ __name((lazyWriter, struct, offset) => {
  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {
    flushLazyStructWriter(lazyWriter);
  }
  if (lazyWriter.written === 0) {
    lazyWriter.currClient = struct.id.client;
    lazyWriter.encoder.writeClient(struct.id.client);
    writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);
  }
  struct.write(lazyWriter.encoder, offset);
  lazyWriter.written++;
}, "writeStructToLazyStructWriter");
var finishLazyStructWriting = /* @__PURE__ */ __name((lazyWriter) => {
  flushLazyStructWriter(lazyWriter);
  const restEncoder = lazyWriter.encoder.restEncoder;
  writeVarUint(restEncoder, lazyWriter.clientStructs.length);
  for (let i = 0; i < lazyWriter.clientStructs.length; i++) {
    const partStructs = lazyWriter.clientStructs[i];
    writeVarUint(restEncoder, partStructs.written);
    writeUint8Array(restEncoder, partStructs.restEncoder);
  }
}, "finishLazyStructWriting");
var convertUpdateFormat = /* @__PURE__ */ __name((update, blockTransformer, YDecoder, YEncoder) => {
  const updateDecoder = new YDecoder(createDecoder(update));
  const lazyDecoder = new LazyStructReader(updateDecoder, false);
  const updateEncoder = new YEncoder();
  const lazyWriter = new LazyStructWriter(updateEncoder);
  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
    writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);
  }
  finishLazyStructWriting(lazyWriter);
  const ds = readDeleteSet(updateDecoder);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
}, "convertUpdateFormat");
var convertUpdateFormatV2ToV1 = /* @__PURE__ */ __name((update) => convertUpdateFormat(update, id, UpdateDecoderV2, UpdateEncoderV1), "convertUpdateFormatV2ToV1");
var errorComputeChanges = "You must not compute changes after the event-handler fired.";
var _YEvent = class _YEvent {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(target, transaction) {
    this.target = target;
    this.currentTarget = target;
    this.transaction = transaction;
    this._changes = null;
    this._keys = null;
    this._delta = null;
    this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = getPathTo(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(struct) {
    return isDeleted(this.transaction.deleteSet, struct.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create3(errorComputeChanges);
      }
      const keys3 = /* @__PURE__ */ new Map();
      const target = this.target;
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      changed.forEach((key) => {
        if (key !== null) {
          const item = (
            /** @type {Item} */
            target._map.get(key)
          );
          let action;
          let oldValue;
          if (this.adds(item)) {
            let prev = item.left;
            while (prev !== null && this.adds(prev)) {
              prev = prev.left;
            }
            if (this.deletes(item)) {
              if (prev !== null && this.deletes(prev)) {
                action = "delete";
                oldValue = last2(prev.content.getContent());
              } else {
                return;
              }
            } else {
              if (prev !== null && this.deletes(prev)) {
                action = "update";
                oldValue = last2(prev.content.getContent());
              } else {
                action = "add";
                oldValue = void 0;
              }
            }
          } else {
            if (this.deletes(item)) {
              action = "delete";
              oldValue = last2(
                /** @type {Item} */
                item.content.getContent()
              );
            } else {
              return;
            }
          }
          keys3.set(key, { action, oldValue });
        }
      });
      this._keys = keys3;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(struct) {
    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let changes = this._changes;
    if (changes === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create3(errorComputeChanges);
      }
      const target = this.target;
      const added = create2();
      const deleted = create2();
      const delta = [];
      changes = {
        added,
        deleted,
        delta,
        keys: this.keys
      };
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      if (changed.has(null)) {
        let lastOp = null;
        const packOp = /* @__PURE__ */ __name(() => {
          if (lastOp) {
            delta.push(lastOp);
          }
        }, "packOp");
        for (let item = target._start; item !== null; item = item.right) {
          if (item.deleted) {
            if (this.deletes(item) && !this.adds(item)) {
              if (lastOp === null || lastOp.delete === void 0) {
                packOp();
                lastOp = { delete: 0 };
              }
              lastOp.delete += item.length;
              deleted.add(item);
            }
          } else {
            if (this.adds(item)) {
              if (lastOp === null || lastOp.insert === void 0) {
                packOp();
                lastOp = { insert: [] };
              }
              lastOp.insert = lastOp.insert.concat(item.content.getContent());
              added.add(item);
            } else {
              if (lastOp === null || lastOp.retain === void 0) {
                packOp();
                lastOp = { retain: 0 };
              }
              lastOp.retain += item.length;
            }
          }
        }
        if (lastOp !== null && lastOp.retain === void 0) {
          packOp();
        }
      }
      this._changes = changes;
    }
    return (
      /** @type {any} */
      changes
    );
  }
};
__name(_YEvent, "YEvent");
var YEvent = _YEvent;
var getPathTo = /* @__PURE__ */ __name((parent, child) => {
  const path = [];
  while (child._item !== null && child !== parent) {
    if (child._item.parentSub !== null) {
      path.unshift(child._item.parentSub);
    } else {
      let i = 0;
      let c = (
        /** @type {AbstractType<any>} */
        child._item.parent._start
      );
      while (c !== child._item && c !== null) {
        if (!c.deleted && c.countable) {
          i += c.length;
        }
        c = c.right;
      }
      path.unshift(i);
    }
    child = /** @type {AbstractType<any>} */
    child._item.parent;
  }
  return path;
}, "getPathTo");
var warnPrematureAccess = /* @__PURE__ */ __name(() => {
  warn("Invalid access: Add Yjs type to a document before reading data.");
}, "warnPrematureAccess");
var maxSearchMarker = 80;
var globalSearchMarkerTimestamp = 0;
var _ArraySearchMarker = class _ArraySearchMarker {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(p, index) {
    p.marker = true;
    this.p = p;
    this.index = index;
    this.timestamp = globalSearchMarkerTimestamp++;
  }
};
__name(_ArraySearchMarker, "ArraySearchMarker");
var ArraySearchMarker = _ArraySearchMarker;
var refreshMarkerTimestamp = /* @__PURE__ */ __name((marker) => {
  marker.timestamp = globalSearchMarkerTimestamp++;
}, "refreshMarkerTimestamp");
var overwriteMarker = /* @__PURE__ */ __name((marker, p, index) => {
  marker.p.marker = false;
  marker.p = p;
  p.marker = true;
  marker.index = index;
  marker.timestamp = globalSearchMarkerTimestamp++;
}, "overwriteMarker");
var markPosition = /* @__PURE__ */ __name((searchMarker, p, index) => {
  if (searchMarker.length >= maxSearchMarker) {
    const marker = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b);
    overwriteMarker(marker, p, index);
    return marker;
  } else {
    const pm = new ArraySearchMarker(p, index);
    searchMarker.push(pm);
    return pm;
  }
}, "markPosition");
var findMarker = /* @__PURE__ */ __name((yarray, index) => {
  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {
    return null;
  }
  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => abs(index - a.index) < abs(index - b.index) ? a : b);
  let p = yarray._start;
  let pindex = 0;
  if (marker !== null) {
    p = marker.p;
    pindex = marker.index;
    refreshMarkerTimestamp(marker);
  }
  while (p.right !== null && pindex < index) {
    if (!p.deleted && p.countable) {
      if (index < pindex + p.length) {
        break;
      }
      pindex += p.length;
    }
    p = p.right;
  }
  while (p.left !== null && pindex > index) {
    p = p.left;
    if (!p.deleted && p.countable) {
      pindex -= p.length;
    }
  }
  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {
    p = p.left;
    if (!p.deleted && p.countable) {
      pindex -= p.length;
    }
  }
  if (marker !== null && abs(marker.index - pindex) < /** @type {YText|YArray<any>} */
  p.parent.length / maxSearchMarker) {
    overwriteMarker(marker, p, pindex);
    return marker;
  } else {
    return markPosition(yarray._searchMarker, p, pindex);
  }
}, "findMarker");
var updateMarkerChanges = /* @__PURE__ */ __name((searchMarker, index, len) => {
  for (let i = searchMarker.length - 1; i >= 0; i--) {
    const m = searchMarker[i];
    if (len > 0) {
      let p = m.p;
      p.marker = false;
      while (p && (p.deleted || !p.countable)) {
        p = p.left;
        if (p && !p.deleted && p.countable) {
          m.index -= p.length;
        }
      }
      if (p === null || p.marker === true) {
        searchMarker.splice(i, 1);
        continue;
      }
      m.p = p;
      p.marker = true;
    }
    if (index < m.index || len > 0 && index === m.index) {
      m.index = max(index, m.index + len);
    }
  }
}, "updateMarkerChanges");
var callTypeObservers = /* @__PURE__ */ __name((type, transaction, event) => {
  const changedType = type;
  const changedParentTypes = transaction.changedParentTypes;
  while (true) {
    setIfUndefined(changedParentTypes, type, () => []).push(event);
    if (type._item === null) {
      break;
    }
    type = /** @type {AbstractType<any>} */
    type._item.parent;
  }
  callEventHandlerListeners(changedType._eH, event, transaction);
}, "callTypeObservers");
var _AbstractType = class _AbstractType {
  constructor() {
    this._item = null;
    this._map = /* @__PURE__ */ new Map();
    this._start = null;
    this.doc = null;
    this._length = 0;
    this._eH = createEventHandler();
    this._dEH = createEventHandler();
    this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(y, item) {
    this.doc = y;
    this._item = item;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw methodUnimplemented();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw methodUnimplemented();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(_encoder) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let n = this._start;
    while (n !== null && n.deleted) {
      n = n.right;
    }
    return n;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, _parentSubs) {
    if (!transaction.local && this._searchMarker) {
      this._searchMarker.length = 0;
    }
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(f) {
    addEventHandlerListener(this._eH, f);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(f) {
    addEventHandlerListener(this._dEH, f);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(f) {
    removeEventHandlerListener(this._eH, f);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(f) {
    removeEventHandlerListener(this._dEH, f);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
};
__name(_AbstractType, "AbstractType");
var AbstractType = _AbstractType;
var typeListSlice = /* @__PURE__ */ __name((type, start, end) => {
  var _a9;
  (_a9 = type.doc) != null ? _a9 : warnPrematureAccess();
  if (start < 0) {
    start = type._length + start;
  }
  if (end < 0) {
    end = type._length + end;
  }
  let len = end - start;
  const cs = [];
  let n = type._start;
  while (n !== null && len > 0) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      if (c.length <= start) {
        start -= c.length;
      } else {
        for (let i = start; i < c.length && len > 0; i++) {
          cs.push(c[i]);
          len--;
        }
        start = 0;
      }
    }
    n = n.right;
  }
  return cs;
}, "typeListSlice");
var typeListToArray = /* @__PURE__ */ __name((type) => {
  var _a9;
  (_a9 = type.doc) != null ? _a9 : warnPrematureAccess();
  const cs = [];
  let n = type._start;
  while (n !== null) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      for (let i = 0; i < c.length; i++) {
        cs.push(c[i]);
      }
    }
    n = n.right;
  }
  return cs;
}, "typeListToArray");
var typeListForEach = /* @__PURE__ */ __name((type, f) => {
  var _a9;
  let index = 0;
  let n = type._start;
  (_a9 = type.doc) != null ? _a9 : warnPrematureAccess();
  while (n !== null) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      for (let i = 0; i < c.length; i++) {
        f(c[i], index++, type);
      }
    }
    n = n.right;
  }
}, "typeListForEach");
var typeListMap = /* @__PURE__ */ __name((type, f) => {
  const result = [];
  typeListForEach(type, (c, i) => {
    result.push(f(c, i, type));
  });
  return result;
}, "typeListMap");
var typeListCreateIterator = /* @__PURE__ */ __name((type) => {
  let n = type._start;
  let currentContent = null;
  let currentContentIndex = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: /* @__PURE__ */ __name(() => {
      if (currentContent === null) {
        while (n !== null && n.deleted) {
          n = n.right;
        }
        if (n === null) {
          return {
            done: true,
            value: void 0
          };
        }
        currentContent = n.content.getContent();
        currentContentIndex = 0;
        n = n.right;
      }
      const value = currentContent[currentContentIndex++];
      if (currentContent.length <= currentContentIndex) {
        currentContent = null;
      }
      return {
        done: false,
        value
      };
    }, "next")
  };
}, "typeListCreateIterator");
var typeListGet = /* @__PURE__ */ __name((type, index) => {
  var _a9;
  (_a9 = type.doc) != null ? _a9 : warnPrematureAccess();
  const marker = findMarker(type, index);
  let n = type._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
  }
  for (; n !== null; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index < n.length) {
        return n.content.getContent()[index];
      }
      index -= n.length;
    }
  }
}, "typeListGet");
var typeListInsertGenericsAfter = /* @__PURE__ */ __name((transaction, parent, referenceItem, content) => {
  let left = referenceItem;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const store = doc2.store;
  const right = referenceItem === null ? parent._start : referenceItem.right;
  let jsonContent = [];
  const packJsonContent = /* @__PURE__ */ __name(() => {
    if (jsonContent.length > 0) {
      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
      left.integrate(transaction, 0);
      jsonContent = [];
    }
  }, "packJsonContent");
  content.forEach((c) => {
    if (c === null) {
      jsonContent.push(c);
    } else {
      switch (c.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          jsonContent.push(c);
          break;
        default:
          packJsonContent();
          switch (c.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(
                /** @type {Uint8Array} */
                c
              )));
              left.integrate(transaction, 0);
              break;
            case Doc:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(
                /** @type {Doc} */
                c
              ));
              left.integrate(transaction, 0);
              break;
            default:
              if (c instanceof AbstractType) {
                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));
                left.integrate(transaction, 0);
              } else {
                throw new Error("Unexpected content type in insert operation");
              }
          }
      }
    }
  });
  packJsonContent();
}, "typeListInsertGenericsAfter");
var lengthExceeded = /* @__PURE__ */ __name(() => create3("Length exceeded!"), "lengthExceeded");
var typeListInsertGenerics = /* @__PURE__ */ __name((transaction, parent, index, content) => {
  if (index > parent._length) {
    throw lengthExceeded();
  }
  if (index === 0) {
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, index, content.length);
    }
    return typeListInsertGenericsAfter(transaction, parent, null, content);
  }
  const startIndex = index;
  const marker = findMarker(parent, index);
  let n = parent._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
    if (index === 0) {
      n = n.prev;
      index += n && n.countable && !n.deleted ? n.length : 0;
    }
  }
  for (; n !== null; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index <= n.length) {
        if (index < n.length) {
          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
        }
        break;
      }
      index -= n.length;
    }
  }
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, startIndex, content.length);
  }
  return typeListInsertGenericsAfter(transaction, parent, n, content);
}, "typeListInsertGenerics");
var typeListPushGenerics = /* @__PURE__ */ __name((transaction, parent, content) => {
  const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });
  let n = marker.p;
  if (n) {
    while (n.right) {
      n = n.right;
    }
  }
  return typeListInsertGenericsAfter(transaction, parent, n, content);
}, "typeListPushGenerics");
var typeListDelete = /* @__PURE__ */ __name((transaction, parent, index, length2) => {
  if (length2 === 0) {
    return;
  }
  const startIndex = index;
  const startLength = length2;
  const marker = findMarker(parent, index);
  let n = parent._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
  }
  for (; n !== null && index > 0; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index < n.length) {
        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
      }
      index -= n.length;
    }
  }
  while (length2 > 0 && n !== null) {
    if (!n.deleted) {
      if (length2 < n.length) {
        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length2));
      }
      n.delete(transaction);
      length2 -= n.length;
    }
    n = n.right;
  }
  if (length2 > 0) {
    throw lengthExceeded();
  }
  if (parent._searchMarker) {
    updateMarkerChanges(
      parent._searchMarker,
      startIndex,
      -startLength + length2
      /* in case we remove the above exception */
    );
  }
}, "typeListDelete");
var typeMapDelete = /* @__PURE__ */ __name((transaction, parent, key) => {
  const c = parent._map.get(key);
  if (c !== void 0) {
    c.delete(transaction);
  }
}, "typeMapDelete");
var typeMapSet = /* @__PURE__ */ __name((transaction, parent, key, value) => {
  const left = parent._map.get(key) || null;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  let content;
  if (value == null) {
    content = new ContentAny([value]);
  } else {
    switch (value.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
      case Date:
      case BigInt:
        content = new ContentAny([value]);
        break;
      case Uint8Array:
        content = new ContentBinary(
          /** @type {Uint8Array} */
          value
        );
        break;
      case Doc:
        content = new ContentDoc(
          /** @type {Doc} */
          value
        );
        break;
      default:
        if (value instanceof AbstractType) {
          content = new ContentType(value);
        } else {
          throw new Error("Unexpected content type");
        }
    }
  }
  new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);
}, "typeMapSet");
var typeMapGet = /* @__PURE__ */ __name((parent, key) => {
  var _a9;
  (_a9 = parent.doc) != null ? _a9 : warnPrematureAccess();
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted ? val.content.getContent()[val.length - 1] : void 0;
}, "typeMapGet");
var typeMapGetAll = /* @__PURE__ */ __name((parent) => {
  var _a9;
  const res = {};
  (_a9 = parent.doc) != null ? _a9 : warnPrematureAccess();
  parent._map.forEach((value, key) => {
    if (!value.deleted) {
      res[key] = value.content.getContent()[value.length - 1];
    }
  });
  return res;
}, "typeMapGetAll");
var typeMapHas = /* @__PURE__ */ __name((parent, key) => {
  var _a9;
  (_a9 = parent.doc) != null ? _a9 : warnPrematureAccess();
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted;
}, "typeMapHas");
var typeMapGetAllSnapshot = /* @__PURE__ */ __name((parent, snapshot) => {
  const res = {};
  parent._map.forEach((value, key) => {
    let v = value;
    while (v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))) {
      v = v.left;
    }
    if (v !== null && isVisible(v, snapshot)) {
      res[key] = v.content.getContent()[v.length - 1];
    }
  });
  return res;
}, "typeMapGetAllSnapshot");
var createMapIterator = /* @__PURE__ */ __name((type) => {
  var _a9;
  (_a9 = type.doc) != null ? _a9 : warnPrematureAccess();
  return iteratorFilter(
    type._map.entries(),
    /** @param {any} entry */
    (entry) => !entry[1].deleted
  );
}, "createMapIterator");
var _YArrayEvent = class _YArrayEvent extends YEvent {
};
__name(_YArrayEvent, "YArrayEvent");
var YArrayEvent = _YArrayEvent;
var _YArray = class _YArray extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
    this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(items) {
    const a = new _YArray();
    a.push(items);
    return a;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new _YArray();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YArray<T>}
   */
  clone() {
    const arr = new _YArray();
    arr.insert(0, this.toArray().map(
      (el) => el instanceof AbstractType ? (
        /** @type {typeof el} */
        el.clone()
      ) : el
    ));
    return arr;
  }
  get length() {
    var _a9;
    (_a9 = this.doc) != null ? _a9 : warnPrematureAccess();
    return this._length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(
          transaction,
          this,
          index,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListPushGenerics(
          transaction,
          this,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.push(...content);
    }
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<T>} content Array of content to prepend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(index, length2 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length2);
      });
    } else {
      this._prelimContent.splice(index, length2);
    }
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(index) {
    return typeListGet(this, index);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Returns a portion of this YArray into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((c) => c instanceof AbstractType ? c.toJSON() : c);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(f) {
    return typeListMap(
      this,
      /** @type {any} */
      f
    );
  }
  /**
   * Executes a provided function once on every element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    typeListForEach(this, f);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return typeListCreateIterator(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YArrayRefID);
  }
};
__name(_YArray, "YArray");
var YArray = _YArray;
var readYArray = /* @__PURE__ */ __name((_decoder) => new YArray(), "readYArray");
var _YMapEvent = class _YMapEvent extends YEvent {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(ymap, transaction, subs) {
    super(ymap, transaction);
    this.keysChanged = subs;
  }
};
__name(_YMapEvent, "YMapEvent");
var YMapEvent = _YMapEvent;
var _YMap = class _YMap extends AbstractType {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(entries) {
    super();
    this._prelimContent = null;
    if (entries === void 0) {
      this._prelimContent = /* @__PURE__ */ new Map();
    } else {
      this._prelimContent = new Map(entries);
    }
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this._prelimContent.forEach((value, key) => {
      this.set(key, value);
    });
    this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new _YMap();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YMap<MapType>}
   */
  clone() {
    const map3 = new _YMap();
    this.forEach((value, key) => {
      map3.set(key, value instanceof AbstractType ? (
        /** @type {typeof value} */
        value.clone()
      ) : value);
    });
    return map3;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    var _a9;
    (_a9 = this.doc) != null ? _a9 : warnPrematureAccess();
    const map3 = {};
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        const v = item.content.getContent()[item.length - 1];
        map3[key] = v instanceof AbstractType ? v.toJSON() : v;
      }
    });
    return map3;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...createMapIterator(this)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return iteratorMap(
      createMapIterator(this),
      /** @param {any} v */
      (v) => v[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return iteratorMap(
      createMapIterator(this),
      /** @param {any} v */
      (v) => v[1].content.getContent()[v[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return iteratorMap(
      createMapIterator(this),
      /** @param {any} v */
      (v) => (
        /** @type {any} */
        [v[0], v[1].content.getContent()[v[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    var _a9;
    (_a9 = this.doc) != null ? _a9 : warnPrematureAccess();
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        f(item.content.getContent()[item.length - 1], key, this);
      }
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(key) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, key);
      });
    } else {
      this._prelimContent.delete(key);
    }
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(key, value) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(
          transaction,
          this,
          key,
          /** @type {any} */
          value
        );
      });
    } else {
      this._prelimContent.set(key, value);
    }
    return value;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(key) {
    return (
      /** @type {any} */
      typeMapGet(this, key)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(key) {
    return typeMapHas(this, key);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        this.forEach(function(_value, key, map3) {
          typeMapDelete(transaction, map3, key);
        });
      });
    } else {
      this._prelimContent.clear();
    }
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YMapRefID);
  }
};
__name(_YMap, "YMap");
var YMap = _YMap;
var readYMap = /* @__PURE__ */ __name((_decoder) => new YMap(), "readYMap");
var equalAttrs = /* @__PURE__ */ __name((a, b) => a === b || typeof a === "object" && typeof b === "object" && a && b && equalFlat(a, b), "equalAttrs");
var _ItemTextListPosition = class _ItemTextListPosition {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(left, right, index, currentAttributes) {
    this.left = left;
    this.right = right;
    this.index = index;
    this.currentAttributes = currentAttributes;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    if (this.right === null) {
      unexpectedCase();
    }
    switch (this.right.content.constructor) {
      case ContentFormat:
        if (!this.right.deleted) {
          updateCurrentAttributes(
            this.currentAttributes,
            /** @type {ContentFormat} */
            this.right.content
          );
        }
        break;
      default:
        if (!this.right.deleted) {
          this.index += this.right.length;
        }
        break;
    }
    this.left = this.right;
    this.right = this.right.right;
  }
};
__name(_ItemTextListPosition, "ItemTextListPosition");
var ItemTextListPosition = _ItemTextListPosition;
var findNextPosition = /* @__PURE__ */ __name((transaction, pos, count2) => {
  while (pos.right !== null && count2 > 0) {
    switch (pos.right.content.constructor) {
      case ContentFormat:
        if (!pos.right.deleted) {
          updateCurrentAttributes(
            pos.currentAttributes,
            /** @type {ContentFormat} */
            pos.right.content
          );
        }
        break;
      default:
        if (!pos.right.deleted) {
          if (count2 < pos.right.length) {
            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count2));
          }
          pos.index += pos.right.length;
          count2 -= pos.right.length;
        }
        break;
    }
    pos.left = pos.right;
    pos.right = pos.right.right;
  }
  return pos;
}, "findNextPosition");
var findPosition = /* @__PURE__ */ __name((transaction, parent, index, useSearchMarker) => {
  const currentAttributes = /* @__PURE__ */ new Map();
  const marker = useSearchMarker ? findMarker(parent, index) : null;
  if (marker) {
    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);
    return findNextPosition(transaction, pos, index - marker.index);
  } else {
    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
    return findNextPosition(transaction, pos, index);
  }
}, "findPosition");
var insertNegatedAttributes = /* @__PURE__ */ __name((transaction, parent, currPos, negatedAttributes) => {
  while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(
    negatedAttributes.get(
      /** @type {ContentFormat} */
      currPos.right.content.key
    ),
    /** @type {ContentFormat} */
    currPos.right.content.value
  ))) {
    if (!currPos.right.deleted) {
      negatedAttributes.delete(
        /** @type {ContentFormat} */
        currPos.right.content.key
      );
    }
    currPos.forward();
  }
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  negatedAttributes.forEach((val, key) => {
    const left = currPos.left;
    const right = currPos.right;
    const nextFormat = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
    nextFormat.integrate(transaction, 0);
    currPos.right = nextFormat;
    currPos.forward();
  });
}, "insertNegatedAttributes");
var updateCurrentAttributes = /* @__PURE__ */ __name((currentAttributes, format) => {
  const { key, value } = format;
  if (value === null) {
    currentAttributes.delete(key);
  } else {
    currentAttributes.set(key, value);
  }
}, "updateCurrentAttributes");
var minimizeAttributeChanges = /* @__PURE__ */ __name((currPos, attributes) => {
  var _a9;
  while (true) {
    if (currPos.right === null) {
      break;
    } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(
      (_a9 = attributes[
        /** @type {ContentFormat} */
        currPos.right.content.key
      ]) != null ? _a9 : null,
      /** @type {ContentFormat} */
      currPos.right.content.value
    )) ;
    else {
      break;
    }
    currPos.forward();
  }
}, "minimizeAttributeChanges");
var insertAttributes = /* @__PURE__ */ __name((transaction, parent, currPos, attributes) => {
  var _a9;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const negatedAttributes = /* @__PURE__ */ new Map();
  for (const key in attributes) {
    const val = attributes[key];
    const currentVal = (_a9 = currPos.currentAttributes.get(key)) != null ? _a9 : null;
    if (!equalAttrs(currentVal, val)) {
      negatedAttributes.set(key, currentVal);
      const { left, right } = currPos;
      currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
      currPos.right.integrate(transaction, 0);
      currPos.forward();
    }
  }
  return negatedAttributes;
}, "insertAttributes");
var insertText = /* @__PURE__ */ __name((transaction, parent, currPos, text2, attributes) => {
  currPos.currentAttributes.forEach((_val, key) => {
    if (attributes[key] === void 0) {
      attributes[key] = null;
    }
  });
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  const content = text2.constructor === String ? new ContentString(
    /** @type {string} */
    text2
  ) : text2 instanceof AbstractType ? new ContentType(text2) : new ContentEmbed(text2);
  let { left, right, index } = currPos;
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());
  }
  right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);
  right.integrate(transaction, 0);
  currPos.right = right;
  currPos.index = index;
  currPos.forward();
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
}, "insertText");
var formatText = /* @__PURE__ */ __name((transaction, parent, currPos, length2, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  iterationLoop: while (currPos.right !== null && (length2 > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))) {
    if (!currPos.right.deleted) {
      switch (currPos.right.content.constructor) {
        case ContentFormat: {
          const { key, value } = (
            /** @type {ContentFormat} */
            currPos.right.content
          );
          const attr = attributes[key];
          if (attr !== void 0) {
            if (equalAttrs(attr, value)) {
              negatedAttributes.delete(key);
            } else {
              if (length2 === 0) {
                break iterationLoop;
              }
              negatedAttributes.set(key, value);
            }
            currPos.right.delete(transaction);
          } else {
            currPos.currentAttributes.set(key, value);
          }
          break;
        }
        default:
          if (length2 < currPos.right.length) {
            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length2));
          }
          length2 -= currPos.right.length;
          break;
      }
    }
    currPos.forward();
  }
  if (length2 > 0) {
    let newlines = "";
    for (; length2 > 0; length2--) {
      newlines += "\n";
    }
    currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
    currPos.right.integrate(transaction, 0);
    currPos.forward();
  }
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
}, "formatText");
var cleanupFormattingGap = /* @__PURE__ */ __name((transaction, start, curr, startAttributes, currAttributes) => {
  var _a9, _b2;
  let end = start;
  const endFormats = create();
  while (end && (!end.countable || end.deleted)) {
    if (!end.deleted && end.content.constructor === ContentFormat) {
      const cf = (
        /** @type {ContentFormat} */
        end.content
      );
      endFormats.set(cf.key, cf);
    }
    end = end.right;
  }
  let cleanups = 0;
  let reachedCurr = false;
  while (start !== end) {
    if (curr === start) {
      reachedCurr = true;
    }
    if (!start.deleted) {
      const content = start.content;
      switch (content.constructor) {
        case ContentFormat: {
          const { key, value } = (
            /** @type {ContentFormat} */
            content
          );
          const startAttrValue = (_a9 = startAttributes.get(key)) != null ? _a9 : null;
          if (endFormats.get(key) !== content || startAttrValue === value) {
            start.delete(transaction);
            cleanups++;
            if (!reachedCurr && ((_b2 = currAttributes.get(key)) != null ? _b2 : null) === value && startAttrValue !== value) {
              if (startAttrValue === null) {
                currAttributes.delete(key);
              } else {
                currAttributes.set(key, startAttrValue);
              }
            }
          }
          if (!reachedCurr && !start.deleted) {
            updateCurrentAttributes(
              currAttributes,
              /** @type {ContentFormat} */
              content
            );
          }
          break;
        }
      }
    }
    start = /** @type {Item} */
    start.right;
  }
  return cleanups;
}, "cleanupFormattingGap");
var cleanupContextlessFormattingGap = /* @__PURE__ */ __name((transaction, item) => {
  while (item && item.right && (item.right.deleted || !item.right.countable)) {
    item = item.right;
  }
  const attrs = /* @__PURE__ */ new Set();
  while (item && (item.deleted || !item.countable)) {
    if (!item.deleted && item.content.constructor === ContentFormat) {
      const key = (
        /** @type {ContentFormat} */
        item.content.key
      );
      if (attrs.has(key)) {
        item.delete(transaction);
      } else {
        attrs.add(key);
      }
    }
    item = item.left;
  }
}, "cleanupContextlessFormattingGap");
var cleanupYTextFormatting = /* @__PURE__ */ __name((type) => {
  let res = 0;
  transact(
    /** @type {Doc} */
    type.doc,
    (transaction) => {
      let start = (
        /** @type {Item} */
        type._start
      );
      let end = type._start;
      let startAttributes = create();
      const currentAttributes = copy(startAttributes);
      while (end) {
        if (end.deleted === false) {
          switch (end.content.constructor) {
            case ContentFormat:
              updateCurrentAttributes(
                currentAttributes,
                /** @type {ContentFormat} */
                end.content
              );
              break;
            default:
              res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);
              startAttributes = copy(currentAttributes);
              start = end;
              break;
          }
        }
        end = end.right;
      }
    }
  );
  return res;
}, "cleanupYTextFormatting");
var cleanupYTextAfterTransaction = /* @__PURE__ */ __name((transaction) => {
  const needFullCleanup = /* @__PURE__ */ new Set();
  const doc2 = transaction.doc;
  for (const [client, afterClock] of transaction.afterState.entries()) {
    const clock = transaction.beforeState.get(client) || 0;
    if (afterClock === clock) {
      continue;
    }
    iterateStructs(
      transaction,
      /** @type {Array<Item|GC>} */
      doc2.store.clients.get(client),
      clock,
      afterClock,
      (item) => {
        if (!item.deleted && /** @type {Item} */
        item.content.constructor === ContentFormat && item.constructor !== GC) {
          needFullCleanup.add(
            /** @type {any} */
            item.parent
          );
        }
      }
    );
  }
  transact(doc2, (t) => {
    iterateDeletedStructs(transaction, transaction.deleteSet, (item) => {
      if (item instanceof GC || !/** @type {YText} */
      item.parent._hasFormatting || needFullCleanup.has(
        /** @type {YText} */
        item.parent
      )) {
        return;
      }
      const parent = (
        /** @type {YText} */
        item.parent
      );
      if (item.content.constructor === ContentFormat) {
        needFullCleanup.add(parent);
      } else {
        cleanupContextlessFormattingGap(t, item);
      }
    });
    for (const yText of needFullCleanup) {
      cleanupYTextFormatting(yText);
    }
  });
}, "cleanupYTextAfterTransaction");
var deleteText = /* @__PURE__ */ __name((transaction, currPos, length2) => {
  const startLength = length2;
  const startAttrs = copy(currPos.currentAttributes);
  const start = currPos.right;
  while (length2 > 0 && currPos.right !== null) {
    if (currPos.right.deleted === false) {
      switch (currPos.right.content.constructor) {
        case ContentType:
        case ContentEmbed:
        case ContentString:
          if (length2 < currPos.right.length) {
            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length2));
          }
          length2 -= currPos.right.length;
          currPos.right.delete(transaction);
          break;
      }
    }
    currPos.forward();
  }
  if (start) {
    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);
  }
  const parent = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (currPos.left || currPos.right).parent
  );
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length2);
  }
  return currPos;
}, "deleteText");
var _YTextEvent = class _YTextEvent extends YEvent {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(ytext, transaction, subs) {
    super(ytext, transaction);
    this.childListChanged = false;
    this.keysChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.keysChanged.add(sub);
      }
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const changes = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = changes;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const y = (
        /** @type {Doc} */
        this.target.doc
      );
      const delta = [];
      transact(y, (transaction) => {
        var _a9, _b2, _c;
        const currentAttributes = /* @__PURE__ */ new Map();
        const oldAttributes = /* @__PURE__ */ new Map();
        let item = this.target._start;
        let action = null;
        const attributes = {};
        let insert = "";
        let retain = 0;
        let deleteLen = 0;
        const addOp = /* @__PURE__ */ __name(() => {
          if (action !== null) {
            let op = null;
            switch (action) {
              case "delete":
                if (deleteLen > 0) {
                  op = { delete: deleteLen };
                }
                deleteLen = 0;
                break;
              case "insert":
                if (typeof insert === "object" || insert.length > 0) {
                  op = { insert };
                  if (currentAttributes.size > 0) {
                    op.attributes = {};
                    currentAttributes.forEach((value, key) => {
                      if (value !== null) {
                        op.attributes[key] = value;
                      }
                    });
                  }
                }
                insert = "";
                break;
              case "retain":
                if (retain > 0) {
                  op = { retain };
                  if (!isEmpty(attributes)) {
                    op.attributes = assign({}, attributes);
                  }
                }
                retain = 0;
                break;
            }
            if (op) delta.push(op);
            action = null;
          }
        }, "addOp");
        while (item !== null) {
          switch (item.content.constructor) {
            case ContentType:
            case ContentEmbed:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  addOp();
                  action = "insert";
                  insert = item.content.getContent()[0];
                  addOp();
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += 1;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += 1;
              }
              break;
            case ContentString:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  if (action !== "insert") {
                    addOp();
                    action = "insert";
                  }
                  insert += /** @type {ContentString} */
                  item.content.str;
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += item.length;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += item.length;
              }
              break;
            case ContentFormat: {
              const { key, value } = (
                /** @type {ContentFormat} */
                item.content
              );
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  const curVal = (_a9 = currentAttributes.get(key)) != null ? _a9 : null;
                  if (!equalAttrs(curVal, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (equalAttrs(value, (_b2 = oldAttributes.get(key)) != null ? _b2 : null)) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else if (value !== null) {
                    item.delete(transaction);
                  }
                }
              } else if (this.deletes(item)) {
                oldAttributes.set(key, value);
                const curVal = (_c = currentAttributes.get(key)) != null ? _c : null;
                if (!equalAttrs(curVal, value)) {
                  if (action === "retain") {
                    addOp();
                  }
                  attributes[key] = curVal;
                }
              } else if (!item.deleted) {
                oldAttributes.set(key, value);
                const attr = attributes[key];
                if (attr !== void 0) {
                  if (!equalAttrs(attr, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (value === null) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else if (attr !== null) {
                    item.delete(transaction);
                  }
                }
              }
              if (!item.deleted) {
                if (action === "insert") {
                  addOp();
                }
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  item.content
                );
              }
              break;
            }
          }
          item = item.right;
        }
        addOp();
        while (delta.length > 0) {
          const lastOp = delta[delta.length - 1];
          if (lastOp.retain !== void 0 && lastOp.attributes === void 0) {
            delta.pop();
          } else {
            break;
          }
        }
      });
      this._delta = delta;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
};
__name(_YTextEvent, "YTextEvent");
var YTextEvent = _YTextEvent;
var _YText = class _YText extends AbstractType {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(string) {
    super();
    this._pending = string !== void 0 ? [() => this.insert(0, string)] : [];
    this._searchMarker = [];
    this._hasFormatting = false;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    var _a9;
    (_a9 = this.doc) != null ? _a9 : warnPrematureAccess();
    return this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    try {
      this._pending.forEach((f) => f());
    } catch (e) {
      console.error(e);
    }
    this._pending = null;
  }
  _copy() {
    return new _YText();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YText}
   */
  clone() {
    const text2 = new _YText();
    text2.applyDelta(this.toDelta());
    return text2;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    const event = new YTextEvent(this, transaction, parentSubs);
    callTypeObservers(this, transaction, event);
    if (!transaction.local && this._hasFormatting) {
      transaction._needFormattingCleanup = true;
    }
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    var _a9;
    (_a9 = this.doc) != null ? _a9 : warnPrematureAccess();
    let str = "";
    let n = this._start;
    while (n !== null) {
      if (!n.deleted && n.countable && n.content.constructor === ContentString) {
        str += /** @type {ContentString} */
        n.content.str;
      }
      n = n.right;
    }
    return str;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {Array<any>} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(delta, { sanitize = true } = {}) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const currPos = new ItemTextListPosition(null, this._start, 0, /* @__PURE__ */ new Map());
        for (let i = 0; i < delta.length; i++) {
          const op = delta[i];
          if (op.insert !== void 0) {
            const ins = !sanitize && typeof op.insert === "string" && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === "\n" ? op.insert.slice(0, -1) : op.insert;
            if (typeof ins !== "string" || ins.length > 0) {
              insertText(transaction, this, currPos, ins, op.attributes || {});
            }
          } else if (op.retain !== void 0) {
            formatText(transaction, this, currPos, op.retain, op.attributes || {});
          } else if (op.delete !== void 0) {
            deleteText(transaction, currPos, op.delete);
          }
        }
      });
    } else {
      this._pending.push(() => this.applyDelta(delta));
    }
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(snapshot, prevSnapshot, computeYChange) {
    var _a9;
    (_a9 = this.doc) != null ? _a9 : warnPrematureAccess();
    const ops = [];
    const currentAttributes = /* @__PURE__ */ new Map();
    const doc2 = (
      /** @type {Doc} */
      this.doc
    );
    let str = "";
    let n = this._start;
    function packStr() {
      if (str.length > 0) {
        const attributes = {};
        let addAttributes = false;
        currentAttributes.forEach((value, key) => {
          addAttributes = true;
          attributes[key] = value;
        });
        const op = { insert: str };
        if (addAttributes) {
          op.attributes = attributes;
        }
        ops.push(op);
        str = "";
      }
    }
    __name(packStr, "packStr");
    const computeDelta = /* @__PURE__ */ __name(() => {
      while (n !== null) {
        if (isVisible(n, snapshot) || prevSnapshot !== void 0 && isVisible(n, prevSnapshot)) {
          switch (n.content.constructor) {
            case ContentString: {
              const cur = currentAttributes.get("ychange");
              if (snapshot !== void 0 && !isVisible(n, snapshot)) {
                if (cur === void 0 || cur.user !== n.id.client || cur.type !== "removed") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("removed", n.id) : { type: "removed" });
                }
              } else if (prevSnapshot !== void 0 && !isVisible(n, prevSnapshot)) {
                if (cur === void 0 || cur.user !== n.id.client || cur.type !== "added") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("added", n.id) : { type: "added" });
                }
              } else if (cur !== void 0) {
                packStr();
                currentAttributes.delete("ychange");
              }
              str += /** @type {ContentString} */
              n.content.str;
              break;
            }
            case ContentType:
            case ContentEmbed: {
              packStr();
              const op = {
                insert: n.content.getContent()[0]
              };
              if (currentAttributes.size > 0) {
                const attrs = (
                  /** @type {Object<string,any>} */
                  {}
                );
                op.attributes = attrs;
                currentAttributes.forEach((value, key) => {
                  attrs[key] = value;
                });
              }
              ops.push(op);
              break;
            }
            case ContentFormat:
              if (isVisible(n, snapshot)) {
                packStr();
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  n.content
                );
              }
              break;
          }
        }
        n = n.right;
      }
      packStr();
    }, "computeDelta");
    if (snapshot || prevSnapshot) {
      transact(doc2, (transaction) => {
        if (snapshot) {
          splitSnapshotAffectedStructs(transaction, snapshot);
        }
        if (prevSnapshot) {
          splitSnapshotAffectedStructs(transaction, prevSnapshot);
        }
        computeDelta();
      }, "cleanup");
    } else {
      computeDelta();
    }
    return ops;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(index, text2, attributes) {
    if (text2.length <= 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index, !attributes);
        if (!attributes) {
          attributes = {};
          pos.currentAttributes.forEach((v, k) => {
            attributes[k] = v;
          });
        }
        insertText(transaction, this, pos, text2, attributes);
      });
    } else {
      this._pending.push(() => this.insert(index, text2, attributes));
    }
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(index, embed, attributes) {
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index, !attributes);
        insertText(transaction, this, pos, embed, attributes || {});
      });
    } else {
      this._pending.push(() => this.insertEmbed(index, embed, attributes || {}));
    }
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(index, length2) {
    if (length2 === 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        deleteText(transaction, findPosition(transaction, this, index, true), length2);
      });
    } else {
      this._pending.push(() => this.delete(index, length2));
    }
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(index, length2, attributes) {
    if (length2 === 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index, false);
        if (pos.right === null) {
          return;
        }
        formatText(transaction, this, pos, length2, attributes);
      });
    } else {
      this._pending.push(() => this.format(index, length2, attributes));
    }
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._pending.push(() => this.removeAttribute(attributeName));
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._pending.push(() => this.setAttribute(attributeName, attributeValue));
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return typeMapGetAll(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YTextRefID);
  }
};
__name(_YText, "YText");
var YText = _YText;
var readYText = /* @__PURE__ */ __name((_decoder) => new YText(), "readYText");
var _YXmlTreeWalker = class _YXmlTreeWalker {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(root2, f = () => true) {
    var _a9;
    this._filter = f;
    this._root = root2;
    this._currentNode = /** @type {Item} */
    root2._start;
    this._firstCall = true;
    (_a9 = root2.doc) != null ? _a9 : warnPrematureAccess();
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let n = this._currentNode;
    let type = n && n.content && /** @type {any} */
    n.content.type;
    if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) {
      do {
        type = /** @type {any} */
        n.content.type;
        if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {
          n = type._start;
        } else {
          while (n !== null) {
            const nxt = n.next;
            if (nxt !== null) {
              n = nxt;
              break;
            } else if (n.parent === this._root) {
              n = null;
            } else {
              n = /** @type {AbstractType<any>} */
              n.parent._item;
            }
          }
        }
      } while (n !== null && (n.deleted || !this._filter(
        /** @type {ContentType} */
        n.content.type
      )));
    }
    this._firstCall = false;
    if (n === null) {
      return { value: void 0, done: true };
    }
    this._currentNode = n;
    return { value: (
      /** @type {any} */
      n.content.type
    ), done: false };
  }
};
__name(_YXmlTreeWalker, "YXmlTreeWalker");
var YXmlTreeWalker = _YXmlTreeWalker;
var _YXmlFragment = class _YXmlFragment extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const first = this._first;
    return first ? first.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  _copy() {
    return new _YXmlFragment();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlFragment}
   */
  clone() {
    const el = new _YXmlFragment();
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  get length() {
    var _a9;
    (_a9 = this.doc) != null ? _a9 : warnPrematureAccess();
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(filter2) {
    return new YXmlTreeWalker(this, filter2);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(query) {
    query = query.toUpperCase();
    const iterator3 = new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query);
    const next = iterator3.next();
    if (next.done) {
      return null;
    } else {
      return next.value;
    }
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(query) {
    query = query.toUpperCase();
    return from2(new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return typeListMap(this, (xml) => xml.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const fragment2 = _document.createDocumentFragment();
    if (binding !== void 0) {
      binding._createAssociation(fragment2, this);
    }
    typeListForEach(this, (xmlType) => {
      fragment2.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
    });
    return fragment2;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(transaction, this, index, content);
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(ref, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const refItem = ref && ref instanceof AbstractType ? ref._item : ref;
        typeListInsertGenericsAfter(transaction, this, refItem, content);
      });
    } else {
      const pc = (
        /** @type {Array<any>} */
        this._prelimContent
      );
      const index = ref === null ? 0 : pc.findIndex((el) => el === ref) + 1;
      if (index === 0 && ref !== null) {
        throw create3("Reference item not found");
      }
      pc.splice(index, 0, ...content);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(index, length2 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length2);
      });
    } else {
      this._prelimContent.splice(index, length2);
    }
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(content) {
    this.insert(this.length, content);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(index) {
    return typeListGet(this, index);
  }
  /**
   * Returns a portion of this YXmlFragment into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Executes a provided function on once on every child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    typeListForEach(this, f);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlFragmentRefID);
  }
};
__name(_YXmlFragment, "YXmlFragment");
var YXmlFragment = _YXmlFragment;
var readYXmlFragment = /* @__PURE__ */ __name((_decoder) => new YXmlFragment(), "readYXmlFragment");
var _YXmlElement = class _YXmlElement extends YXmlFragment {
  constructor(nodeName = "UNDEFINED") {
    super();
    this.nodeName = nodeName;
    this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n = this._item ? this._item.next : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n = this._item ? this._item.prev : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((value, key) => {
      this.setAttribute(key, value);
    });
    this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new _YXmlElement(this.nodeName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlElement<KV>}
   */
  clone() {
    const el = new _YXmlElement(this.nodeName);
    const attrs = this.getAttributes();
    forEach2(attrs, (value, key) => {
      if (typeof value === "string") {
        el.setAttribute(key, value);
      }
    });
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const attrs = this.getAttributes();
    const stringBuilder = [];
    const keys3 = [];
    for (const key in attrs) {
      keys3.push(key);
    }
    keys3.sort();
    const keysLen = keys3.length;
    for (let i = 0; i < keysLen; i++) {
      const key = keys3[i];
      stringBuilder.push(key + '="' + attrs[key] + '"');
    }
    const nodeName = this.nodeName.toLocaleLowerCase();
    const attrsString = stringBuilder.length > 0 ? " " + stringBuilder.join(" ") : "";
    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._prelimAttrs.delete(attributeName);
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._prelimAttrs.set(attributeName, attributeValue);
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapHas(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(snapshot) {
    return (
      /** @type {any} */
      snapshot ? typeMapGetAllSnapshot(this, snapshot) : typeMapGetAll(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const dom = _document.createElement(this.nodeName);
    const attrs = this.getAttributes();
    for (const key in attrs) {
      const value = attrs[key];
      if (typeof value === "string") {
        dom.setAttribute(key, value);
      }
    }
    typeListForEach(this, (yxml) => {
      dom.appendChild(yxml.toDOM(_document, hooks, binding));
    });
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlElementRefID);
    encoder.writeKey(this.nodeName);
  }
};
__name(_YXmlElement, "YXmlElement");
var YXmlElement = _YXmlElement;
var readYXmlElement = /* @__PURE__ */ __name((decoder) => new YXmlElement(decoder.readKey()), "readYXmlElement");
var _YXmlEvent = class _YXmlEvent extends YEvent {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with which the
   *                                  change was created.
   */
  constructor(target, subs, transaction) {
    super(target, transaction);
    this.childListChanged = false;
    this.attributesChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.attributesChanged.add(sub);
      }
    });
  }
};
__name(_YXmlEvent, "YXmlEvent");
var YXmlEvent = _YXmlEvent;
var _YXmlHook = class _YXmlHook extends YMap {
  /**
   * @param {string} hookName nodeName of the Dom Node.
   */
  constructor(hookName) {
    super();
    this.hookName = hookName;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   */
  _copy() {
    return new _YXmlHook(this.hookName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlHook}
   */
  clone() {
    const el = new _YXmlHook(this.hookName);
    this.forEach((value, key) => {
      el.set(key, value);
    });
    return el;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const hook = hooks[this.hookName];
    let dom;
    if (hook !== void 0) {
      dom = hook.createDom(this);
    } else {
      dom = document.createElement(this.hookName);
    }
    dom.setAttribute("data-yjs-hook", this.hookName);
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlHookRefID);
    encoder.writeKey(this.hookName);
  }
};
__name(_YXmlHook, "YXmlHook");
var YXmlHook = _YXmlHook;
var readYXmlHook = /* @__PURE__ */ __name((decoder) => new YXmlHook(decoder.readKey()), "readYXmlHook");
var _YXmlText = class _YXmlText extends YText {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n = this._item ? this._item.next : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n = this._item ? this._item.prev : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  _copy() {
    return new _YXmlText();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlText}
   */
  clone() {
    const text2 = new _YXmlText();
    text2.applyDelta(this.toDelta());
    return text2;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks, binding) {
    const dom = _document.createTextNode(this.toString());
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  toString() {
    return this.toDelta().map((delta) => {
      const nestedNodes = [];
      for (const nodeName in delta.attributes) {
        const attrs = [];
        for (const key in delta.attributes[nodeName]) {
          attrs.push({ key, value: delta.attributes[nodeName][key] });
        }
        attrs.sort((a, b) => a.key < b.key ? -1 : 1);
        nestedNodes.push({ nodeName, attrs });
      }
      nestedNodes.sort((a, b) => a.nodeName < b.nodeName ? -1 : 1);
      let str = "";
      for (let i = 0; i < nestedNodes.length; i++) {
        const node = nestedNodes[i];
        str += `<${node.nodeName}`;
        for (let j = 0; j < node.attrs.length; j++) {
          const attr = node.attrs[j];
          str += ` ${attr.key}="${attr.value}"`;
        }
        str += ">";
      }
      str += delta.insert;
      for (let i = nestedNodes.length - 1; i >= 0; i--) {
        str += `</${nestedNodes[i].nodeName}>`;
      }
      return str;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlTextRefID);
  }
};
__name(_YXmlText, "YXmlText");
var YXmlText = _YXmlText;
var readYXmlText = /* @__PURE__ */ __name((decoder) => new YXmlText(), "readYXmlText");
var _AbstractStruct = class _AbstractStruct {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(id2, length2) {
    this.id = id2;
    this.length = length2;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw methodUnimplemented();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} whether this merged with right
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(encoder, offset, encodingRef) {
    throw methodUnimplemented();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    throw methodUnimplemented();
  }
};
__name(_AbstractStruct, "AbstractStruct");
var AbstractStruct = _AbstractStruct;
var structGCRefNumber = 0;
var _GC = class _GC extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.length -= offset;
    }
    addStruct(transaction.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeInfo(structGCRefNumber);
    encoder.writeLen(this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
};
__name(_GC, "GC");
var GC = _GC;
var _ContentBinary = class _ContentBinary {
  /**
   * @param {Uint8Array} content
   */
  constructor(content) {
    this.content = content;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new _ContentBinary(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
};
__name(_ContentBinary, "ContentBinary");
var ContentBinary = _ContentBinary;
var readContentBinary = /* @__PURE__ */ __name((decoder) => new ContentBinary(decoder.readBuf()), "readContentBinary");
var _ContentDeleted = class _ContentDeleted {
  /**
   * @param {number} len
   */
  constructor(len) {
    this.len = len;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new _ContentDeleted(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(offset) {
    const right = new _ContentDeleted(this.len - offset);
    this.len = offset;
    return right;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.len += right.len;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
    item.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeLen(this.len - offset);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
};
__name(_ContentDeleted, "ContentDeleted");
var ContentDeleted = _ContentDeleted;
var readContentDeleted = /* @__PURE__ */ __name((decoder) => new ContentDeleted(decoder.readLen()), "readContentDeleted");
var createDocFromOpts = /* @__PURE__ */ __name((guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false }), "createDocFromOpts");
var _ContentDoc = class _ContentDoc {
  /**
   * @param {Doc} doc
   */
  constructor(doc2) {
    if (doc2._item) {
      console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid.");
    }
    this.doc = doc2;
    const opts = {};
    this.opts = opts;
    if (!doc2.gc) {
      opts.gc = false;
    }
    if (doc2.autoLoad) {
      opts.autoLoad = true;
    }
    if (doc2.meta !== null) {
      opts.meta = doc2.meta;
    }
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new _ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.doc._item = item;
    transaction.subdocsAdded.add(this.doc);
    if (this.doc.shouldLoad) {
      transaction.subdocsLoaded.add(this.doc);
    }
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (transaction.subdocsAdded.has(this.doc)) {
      transaction.subdocsAdded.delete(this.doc);
    } else {
      transaction.subdocsRemoved.add(this.doc);
    }
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeString(this.doc.guid);
    encoder.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
};
__name(_ContentDoc, "ContentDoc");
var ContentDoc = _ContentDoc;
var readContentDoc = /* @__PURE__ */ __name((decoder) => new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny())), "readContentDoc");
var _ContentEmbed = class _ContentEmbed {
  /**
   * @param {Object} embed
   */
  constructor(embed) {
    this.embed = embed;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new _ContentEmbed(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
};
__name(_ContentEmbed, "ContentEmbed");
var ContentEmbed = _ContentEmbed;
var readContentEmbed = /* @__PURE__ */ __name((decoder) => new ContentEmbed(decoder.readJSON()), "readContentEmbed");
var _ContentFormat = class _ContentFormat {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(key, value) {
    this.key = key;
    this.value = value;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new _ContentFormat(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(_offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(_right) {
    return false;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(_transaction, item) {
    const p = (
      /** @type {YText} */
      item.parent
    );
    p._searchMarker = null;
    p._hasFormatting = true;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeKey(this.key);
    encoder.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
};
__name(_ContentFormat, "ContentFormat");
var ContentFormat = _ContentFormat;
var readContentFormat = /* @__PURE__ */ __name((decoder) => new ContentFormat(decoder.readKey(), decoder.readJSON()), "readContentFormat");
var _ContentJSON = class _ContentJSON {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentJSON}
   */
  copy() {
    return new _ContentJSON(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentJSON}
   */
  splice(offset) {
    const right = new _ContentJSON(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentJSON} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i = offset; i < len; i++) {
      const c = this.arr[i];
      encoder.writeString(c === void 0 ? "undefined" : JSON.stringify(c));
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 2;
  }
};
__name(_ContentJSON, "ContentJSON");
var ContentJSON = _ContentJSON;
var readContentJSON = /* @__PURE__ */ __name((decoder) => {
  const len = decoder.readLen();
  const cs = [];
  for (let i = 0; i < len; i++) {
    const c = decoder.readString();
    if (c === "undefined") {
      cs.push(void 0);
    } else {
      cs.push(JSON.parse(c));
    }
  }
  return new ContentJSON(cs);
}, "readContentJSON");
var isDevMode = getVariable("node_env") === "development";
var _ContentAny = class _ContentAny {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
    isDevMode && deepFreeze(arr);
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new _ContentAny(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(offset) {
    const right = new _ContentAny(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i = offset; i < len; i++) {
      const c = this.arr[i];
      encoder.writeAny(c);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
};
__name(_ContentAny, "ContentAny");
var ContentAny = _ContentAny;
var readContentAny = /* @__PURE__ */ __name((decoder) => {
  const len = decoder.readLen();
  const cs = [];
  for (let i = 0; i < len; i++) {
    cs.push(decoder.readAny());
  }
  return new ContentAny(cs);
}, "readContentAny");
var _ContentString = class _ContentString {
  /**
   * @param {string} str
   */
  constructor(str) {
    this.str = str;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new _ContentString(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(offset) {
    const right = new _ContentString(this.str.slice(offset));
    this.str = this.str.slice(0, offset);
    const firstCharCode = this.str.charCodeAt(offset - 1);
    if (firstCharCode >= 55296 && firstCharCode <= 56319) {
      this.str = this.str.slice(0, offset - 1) + "\uFFFD";
      right.str = "\uFFFD" + right.str.slice(1);
    }
    return right;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.str += right.str;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
};
__name(_ContentString, "ContentString");
var ContentString = _ContentString;
var readContentString = /* @__PURE__ */ __name((decoder) => new ContentString(decoder.readString()), "readContentString");
var typeRefs = [
  readYArray,
  readYMap,
  readYText,
  readYXmlElement,
  readYXmlFragment,
  readYXmlHook,
  readYXmlText
];
var YArrayRefID = 0;
var YMapRefID = 1;
var YTextRefID = 2;
var YXmlElementRefID = 3;
var YXmlFragmentRefID = 4;
var YXmlHookRefID = 5;
var YXmlTextRefID = 6;
var _ContentType = class _ContentType {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(type) {
    this.type = type;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new _ContentType(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.type._integrate(transaction.doc, item);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    let item = this.type._start;
    while (item !== null) {
      if (!item.deleted) {
        item.delete(transaction);
      } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {
        transaction._mergeStructs.push(item);
      }
      item = item.right;
    }
    this.type._map.forEach((item2) => {
      if (!item2.deleted) {
        item2.delete(transaction);
      } else if (item2.id.clock < (transaction.beforeState.get(item2.id.client) || 0)) {
        transaction._mergeStructs.push(item2);
      }
    });
    transaction.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
    let item = this.type._start;
    while (item !== null) {
      item.gc(store, true);
      item = item.right;
    }
    this.type._start = null;
    this.type._map.forEach(
      /** @param {Item | null} item */
      (item2) => {
        while (item2 !== null) {
          item2.gc(store, true);
          item2 = item2.left;
        }
      }
    );
    this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    this.type._write(encoder);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
};
__name(_ContentType, "ContentType");
var ContentType = _ContentType;
var readContentType = /* @__PURE__ */ __name((decoder) => new ContentType(typeRefs[decoder.readTypeRef()](decoder)), "readContentType");
var followRedone = /* @__PURE__ */ __name((store, id2) => {
  let nextID = id2;
  let diff = 0;
  let item;
  do {
    if (diff > 0) {
      nextID = createID(nextID.client, nextID.clock + diff);
    }
    item = getItem(store, nextID);
    diff = nextID.clock - item.id.clock;
    nextID = item.redone;
  } while (nextID !== null && item instanceof Item);
  return {
    item,
    diff
  };
}, "followRedone");
var splitItem = /* @__PURE__ */ __name((transaction, leftItem, diff) => {
  const { client, clock } = leftItem.id;
  const rightItem = new Item(
    createID(client, clock + diff),
    leftItem,
    createID(client, clock + diff - 1),
    leftItem.right,
    leftItem.rightOrigin,
    leftItem.parent,
    leftItem.parentSub,
    leftItem.content.splice(diff)
  );
  if (leftItem.deleted) {
    rightItem.markDeleted();
  }
  if (leftItem.keep) {
    rightItem.keep = true;
  }
  if (leftItem.redone !== null) {
    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
  }
  leftItem.right = rightItem;
  if (rightItem.right !== null) {
    rightItem.right.left = rightItem;
  }
  transaction._mergeStructs.push(rightItem);
  if (rightItem.parentSub !== null && rightItem.right === null) {
    rightItem.parent._map.set(rightItem.parentSub, rightItem);
  }
  leftItem.length = diff;
  return rightItem;
}, "splitItem");
var _Item = class _Item extends AbstractStruct {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(id2, left, origin2, right, rightOrigin, parent, parentSub, content) {
    super(id2, content.getLength());
    this.origin = origin2;
    this.left = left;
    this.right = right;
    this.rightOrigin = rightOrigin;
    this.parent = parent;
    this.parentSub = parentSub;
    this.redone = null;
    this.content = content;
    this.info = this.content.isCountable() ? BIT2 : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(isMarked) {
    if ((this.info & BIT4) > 0 !== isMarked) {
      this.info ^= BIT4;
    }
  }
  get marker() {
    return (this.info & BIT4) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & BIT1) > 0;
  }
  set keep(doKeep) {
    if (this.keep !== doKeep) {
      this.info ^= BIT1;
    }
  }
  get countable() {
    return (this.info & BIT2) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & BIT3) > 0;
  }
  set deleted(doDelete) {
    if (this.deleted !== doDelete) {
      this.info ^= BIT3;
    }
  }
  markDeleted() {
    this.info |= BIT3;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {
      return this.origin.client;
    }
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {
      return this.rightOrigin.client;
    }
    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {
      return this.parent.client;
    }
    if (this.origin) {
      this.left = getItemCleanEnd(transaction, store, this.origin);
      this.origin = this.left.lastId;
    }
    if (this.rightOrigin) {
      this.right = getItemCleanStart(transaction, this.rightOrigin);
      this.rightOrigin = this.right.id;
    }
    if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {
      this.parent = null;
    } else if (!this.parent) {
      if (this.left && this.left.constructor === _Item) {
        this.parent = this.left.parent;
        this.parentSub = this.left.parentSub;
      } else if (this.right && this.right.constructor === _Item) {
        this.parent = this.right.parent;
        this.parentSub = this.right.parentSub;
      }
    } else if (this.parent.constructor === ID) {
      const parentItem = getItem(store, this.parent);
      if (parentItem.constructor === GC) {
        this.parent = null;
      } else {
        this.parent = /** @type {ContentType} */
        parentItem.content.type;
      }
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
      this.origin = this.left.lastId;
      this.content = this.content.splice(offset);
      this.length -= offset;
    }
    if (this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let left = this.left;
        let o;
        if (left !== null) {
          o = left.right;
        } else if (this.parentSub !== null) {
          o = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (o !== null && o.left !== null) {
            o = o.left;
          }
        } else {
          o = /** @type {AbstractType<any>} */
          this.parent._start;
        }
        const conflictingItems = /* @__PURE__ */ new Set();
        const itemsBeforeOrigin = /* @__PURE__ */ new Set();
        while (o !== null && o !== this.right) {
          itemsBeforeOrigin.add(o);
          conflictingItems.add(o);
          if (compareIDs(this.origin, o.origin)) {
            if (o.id.client < this.id.client) {
              left = o;
              conflictingItems.clear();
            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {
              break;
            }
          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) {
            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {
              left = o;
              conflictingItems.clear();
            }
          } else {
            break;
          }
          o = o.right;
        }
        this.left = left;
      }
      if (this.left !== null) {
        const right = this.left.right;
        this.right = right;
        this.left.right = this;
      } else {
        let r;
        if (this.parentSub !== null) {
          r = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (r !== null && r.left !== null) {
            r = r.left;
          }
        } else {
          r = /** @type {AbstractType<any>} */
          this.parent._start;
          this.parent._start = this;
        }
        this.right = r;
      }
      if (this.right !== null) {
        this.right.left = this;
      } else if (this.parentSub !== null) {
        this.parent._map.set(this.parentSub, this);
        if (this.left !== null) {
          this.left.delete(transaction);
        }
      }
      if (this.parentSub === null && this.countable && !this.deleted) {
        this.parent._length += this.length;
      }
      addStruct(transaction.doc.store, this);
      this.content.integrate(transaction, this);
      addChangedTypeToTransaction(
        transaction,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      );
      if (
        /** @type {AbstractType<any>} */
        this.parent._item !== null && /** @type {AbstractType<any>} */
        this.parent._item.deleted || this.parentSub !== null && this.right !== null
      ) {
        this.delete(transaction);
      }
    } else {
      new GC(this.id, this.length).integrate(transaction, 0);
    }
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let n = this.right;
    while (n !== null && n.deleted) {
      n = n.right;
    }
    return n;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let n = this.left;
    while (n !== null && n.deleted) {
      n = n.left;
    }
    return n;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
      const searchMarker = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      if (searchMarker) {
        searchMarker.forEach((marker) => {
          if (marker.p === right) {
            marker.p = this;
            if (!this.deleted && this.countable) {
              marker.index -= this.length;
            }
          }
        });
      }
      if (right.keep) {
        this.keep = true;
      }
      this.right = right.right;
      if (this.right !== null) {
        this.right.left = this;
      }
      this.length += right.length;
      return true;
    }
    return false;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (!this.deleted) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (this.countable && this.parentSub === null) {
        parent._length -= this.length;
      }
      this.markDeleted();
      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
      addChangedTypeToTransaction(transaction, parent, this.parentSub);
      this.content.delete(transaction);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(store, parentGCd) {
    if (!this.deleted) {
      throw unexpectedCase();
    }
    this.content.gc(store);
    if (parentGCd) {
      replaceStruct(store, this, new GC(this.id, this.length));
    } else {
      this.content = new ContentDeleted(this.length);
    }
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(encoder, offset) {
    const origin2 = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
    const rightOrigin = this.rightOrigin;
    const parentSub = this.parentSub;
    const info = this.content.getRef() & BITS5 | (origin2 === null ? 0 : BIT8) | // origin is defined
    (rightOrigin === null ? 0 : BIT7) | // right origin is defined
    (parentSub === null ? 0 : BIT6);
    encoder.writeInfo(info);
    if (origin2 !== null) {
      encoder.writeLeftID(origin2);
    }
    if (rightOrigin !== null) {
      encoder.writeRightID(rightOrigin);
    }
    if (origin2 === null && rightOrigin === null) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (parent._item !== void 0) {
        const parentItem = parent._item;
        if (parentItem === null) {
          const ykey = findRootTypeKey(parent);
          encoder.writeParentInfo(true);
          encoder.writeString(ykey);
        } else {
          encoder.writeParentInfo(false);
          encoder.writeLeftID(parentItem.id);
        }
      } else if (parent.constructor === String) {
        encoder.writeParentInfo(true);
        encoder.writeString(parent);
      } else if (parent.constructor === ID) {
        encoder.writeParentInfo(false);
        encoder.writeLeftID(parent);
      } else {
        unexpectedCase();
      }
      if (parentSub !== null) {
        encoder.writeString(parentSub);
      }
    }
    this.content.write(encoder, offset);
  }
};
__name(_Item, "Item");
var Item = _Item;
var readItemContent = /* @__PURE__ */ __name((decoder, info) => contentRefs[info & BITS5](decoder), "readItemContent");
var contentRefs = [
  () => {
    unexpectedCase();
  },
  // GC is not ItemContent
  readContentDeleted,
  // 1
  readContentJSON,
  // 2
  readContentBinary,
  // 3
  readContentString,
  // 4
  readContentEmbed,
  // 5
  readContentFormat,
  // 6
  readContentType,
  // 7
  readContentAny,
  // 8
  readContentDoc,
  // 9
  () => {
    unexpectedCase();
  }
  // 10 - Skip is not ItemContent
];
var structSkipRefNumber = 10;
var _Skip = class _Skip extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {Skip} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    unexpectedCase();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeInfo(structSkipRefNumber);
    writeVarUint(encoder.restEncoder, this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
};
__name(_Skip, "Skip");
var Skip = _Skip;
var glo = (
  /** @type {any} */
  typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {}
);
var importIdentifier = "__ $YJS$ __";
if (glo[importIdentifier] === true) {
  console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
}
glo[importIdentifier] = true;

// src/services/liveDocuments/notes/NoteHandler.ts
var CLOSED_FILE_SYNC_WAIT = 1e4;
var NOTE_YTEXT_NAME = "s.g:note:v0";
var _NoteHandler = class _NoteHandler extends LiveDocumentHandler {
  constructor(plugin, id2, collectionId, onLoad, lifecycle) {
    super(plugin, id2, collectionId, onLoad, lifecycle, "note");
    this._writeFileIfClosed = throttle_default2(
      () => this._writeFileIfClosedImpl(),
      CLOSED_FILE_SYNC_WAIT,
      { trailing: true, leading: false }
    );
    this._observer = this._observer.bind(this);
  }
  getDocContext() {
    return {
      kind: "note",
      collection_id: this.collectionId
    };
  }
  async hydrateYDocFromDisk() {
    const isAlreadyPersisted = await this.plugin.docs.docIsPersisted(this.id);
    if (isAlreadyPersisted) return;
    const pendingNote = await this.plugin.db.pendingLiveDocuments.get(this.id);
    if (!pendingNote) return;
    const file = this.plugin.app.vault.getFileByPath(pendingNote.path);
    if (!file) return;
    const contents = await this.plugin.app.vault.read(file);
    const ydoc = new Doc();
    const ytext = ydoc.getText(NOTE_YTEXT_NAME);
    ytext.insert(0, contents);
    const provider = this.plugin.docs.persistedDoc(this.id, ydoc);
    await new Promise((resolve) => {
      provider.on("synced", resolve);
    });
    this.log("hydrated from %s", pendingNote.path);
  }
  async beforeClose() {
    var _a9;
    this._writeFileIfClosed.flush();
    (_a9 = this.ytext) == null ? void 0 : _a9.unobserve(this._observer);
  }
  async onDocumentLoaded() {
    this.ytext = this.doc.ydoc.getText(NOTE_YTEXT_NAME);
    this.ytext.observe(this._observer);
  }
  async getYTextHandle() {
    const handle = await this.getYDocHandle();
    if (!handle) return null;
    return {
      ...handle,
      ytext: this.ytext
    };
  }
  /**
   * borrowYText returns the note's Y.Text for read-only purposes.
   * It does not attempt to acquire ownership of the Y.Text,
   * and the returned Y.Text should not be retained by the caller.
   * @returns Y.Text associated with the note's doc.
   */
  borrowYText() {
    return this.ytext;
  }
  async acceptExternalWrite(file) {
    if (this.mutex.isLocked()) return;
    const handle = await this.getYTextHandle();
    if (!handle) return;
    const ytext = handle.ytext;
    if (!ytext.doc) return;
    const yTextContents = ytext.toString();
    const diskContents = await this.plugin.app.vault.read(file);
    const diffMatchPatch = new diff_match_patch();
    const diffs = diffMatchPatch.diff_main(yTextContents, diskContents);
    diffMatchPatch.diff_cleanupEfficiency(diffs);
    if (diffs.length === 0) {
      this.log("external edit diff returned no changes; exiting.");
      return;
    }
    let position = 0;
    ytext.doc.transact(() => {
      for (const [op, chunk] of diffs) {
        if (op === DIFF_EQUAL) {
          position += chunk.length;
        } else if (op === DIFF_INSERT) {
          ytext.insert(position, chunk);
          position += chunk.length;
        } else if (op === DIFF_DELETE) {
          ytext.delete(position, chunk.length);
        }
      }
    });
    this.log(
      `Updated ${file.path} for external edit with ${diffs.length} diffs`
    );
    handle.release();
  }
  _observer(_event, _txn) {
    if (this.mutex.isLocked()) return;
    this._writeFileIfClosed();
  }
  async writeFileIfClosed() {
    await this._writeFileIfClosedImpl();
  }
  // Eventually this will be part of a system to shepherd out-of-Obsidian file-side
  // edits into the ytext. For now, the ytext always wins.
  async _writeFileIfClosedImpl() {
    var _a9;
    if (this.mutex.isLocked()) return;
    const file = this.plugin.app.vault.getFileByPath(this.path);
    if (!file) return;
    const fileContents = await this.plugin.app.vault.read(file);
    const yTextContents = this.ytext.toString();
    if (fileContents !== yTextContents) {
      (_a9 = this.plugin.collections.getHandler(this.collectionId)) == null ? void 0 : _a9.controlModify(this.path, async () => {
        await this.plugin.app.vault.modify(file, yTextContents, {
          mtime: (/* @__PURE__ */ new Date()).valueOf()
        });
      });
    }
  }
};
__name(_NoteHandler, "NoteHandler");
var NoteHandler = _NoteHandler;

// src/services/liveDocuments/LiveDocumentService.ts
var import_debug9 = __toESM(require_browser2());
var TABLE3 = "id,path,collection_id,needs_catchup";
var PENDING_TABLE = "id,path,collection_id";
var DEFAULT_POOL_SIZE = 10;
function handlerClassFor(pathOrFile) {
  const path = getPath(pathOrFile);
  if (path.endsWith(".md")) return NoteHandler;
  return null;
}
__name(handlerClassFor, "handlerClassFor");
function isLiveDocument(pathOrFile) {
  return handlerClassFor(pathOrFile) !== null;
}
__name(isLiveDocument, "isLiveDocument");
var log7 = (0, import_debug9.default)("screen.garden:liveDocuments");
var _LiveDocumentService = class _LiveDocumentService extends Service {
  constructor(plugin) {
    super(plugin);
    this.destroy = new Subject();
    this.pool = new HandlerPool(plugin, DEFAULT_POOL_SIZE);
  }
  async onunload() {
    this.pool.clear();
    this.destroy.next();
    this.destroy.complete();
  }
  get handlerChanges() {
    return this.pool.handlerChanges;
  }
  set poolSize(size2) {
    this.pool.poolSize = size2;
  }
  get poolStats() {
    return this.pool.stats;
  }
  /**
   * Creates or updates one or more live documents based on a list of how to create them.
   *
   * For each CreateLiveDocumentAttrs, we:
   * 1. Check if a document with that ID already exists.
   * 2. Schedule a handler for the document.
   * 3a. If the document existed, update its path and name in the db.
   * 3b. If the document did not exist, insert it into the db.
   * 4. If we're only creating a single document, return it for convenience.
   * @param newDocuments A list of documents to create (or update).
   * @returns A created document if `newDocuments` contains only one entry.
   */
  async create(newDocuments) {
    var _a9;
    for (const newDocument of newDocuments) {
      const { path, collectionId, id: id2, priority } = newDocument;
      const handlerClass = handlerClassFor(path);
      if (!handlerClass) {
        log7(
          `No handler class associated with ${path} during document creation, aborting.`
        );
        continue;
      }
      const existingDocument = (_a9 = await this.plugin.db.liveDocuments.get(id2)) != null ? _a9 : null;
      this.pool.schedule({
        handlerClass,
        id: id2,
        collectionId,
        path,
        priority
      });
      if (existingDocument) {
        await this.db.liveDocuments.update(id2, {
          title: getTitle(path),
          path
        });
      } else {
        await this.db.liveDocuments.put({
          id: id2,
          title: getTitle(path),
          path,
          collection_id: collectionId,
          needs_catchup: 0 /* No */
        });
      }
      if (newDocuments.length === 1) {
        const document2 = await this.db.liveDocuments.get(id2);
        return document2;
      }
    }
  }
  /**
   * Require a live document handler to be spun up with a class corresponding to the given path.
   * @param id LiveDocument ID to search for in the database.
   * @param collectionId Corresponding collection.
   * @param path Path to document on disk.
   * @returns LiveDocumentHandler or null if invalid.
   */
  require(id2, collectionId, path) {
    const handlerClass = handlerClassFor(path);
    if (!handlerClass) return null;
    this.pool.schedule({
      handlerClass,
      id: id2,
      collectionId,
      path,
      priority: "required"
    });
    return this.getHandler(id2);
  }
  /**
   * Require a live document handler to be spun up if the given ID corresponds to a valid path in the database.
   * @param id LiveDocument ID to search for in the database.
   * @param collectionId Corresponding collection.
   */
  async maybeRequireForID(id2, collectionId) {
    const liveDocument = await this.plugin.db.liveDocuments.get(id2);
    const path = liveDocument == null ? void 0 : liveDocument.path;
    if (!path) return;
    this.require(id2, collectionId, path);
  }
  catchup(id2, path, collectionId) {
    const handlerClass = handlerClassFor(path);
    if (!handlerClass) return;
    return this.pool.schedule({
      handlerClass,
      id: id2,
      collectionId,
      path,
      priority: "background"
    });
  }
  getHandler(id2) {
    return this.pool.get(id2);
  }
  /**
   * Returns a handler for a document ID if it exists and is of the specified type.
   * @param id Document ID for handler.
   * @param handlerClass The handler class to check for.
   * @returns Handler instance if one is running and matches the type, null otherwise.
   */
  getHandlerOfType(handlerClass, id2) {
    const handler = this.getHandler(id2);
    return handler instanceof handlerClass ? handler : null;
  }
  async get(id2) {
    const document2 = await this.db.liveDocuments.get(id2);
    return document2 != null ? document2 : null;
  }
  async delete(id2) {
    this.pool.delete(id2);
    await this.db.liveDocuments.delete(id2);
  }
  async downgrade(id2, priority) {
    this.pool.downgrade(id2, priority);
  }
  updatePresence(id2, meta) {
    var _a9;
    (_a9 = this.getHandler(id2)) == null ? void 0 : _a9.updatePresence(meta);
  }
  listPresences(id2) {
    var _a9, _b2;
    return (_b2 = (_a9 = this.getHandler(id2)) == null ? void 0 : _a9.listPresences()) != null ? _b2 : [];
  }
  async setAccessLevel(id2, collection_id, level) {
    var _a9;
    const resp = await ((_a9 = this.plugin.api.client) == null ? void 0 : _a9.put(
      `/collections/${collection_id}/notes/${id2}/access`,
      { level }
    ));
    if (!resp) return null;
    const { url } = resp.data;
    return url;
  }
  async getNotePasswords(id2, collection_id) {
    var _a9;
    const resp = await ((_a9 = this.plugin.api.client) == null ? void 0 : _a9.get(
      `/collections/${collection_id}/notes/${id2}/passwords`
    ));
    if (!resp) return null;
    return resp.data.data;
  }
  async createNotePassword(id2, collection_id, label, password) {
    var _a9;
    const resp = await ((_a9 = this.plugin.api.client) == null ? void 0 : _a9.post(
      `/collections/${collection_id}/notes/${id2}/passwords`,
      { label, password }
    ));
    if (!resp) return null;
    return resp.data;
  }
};
__name(_LiveDocumentService, "LiveDocumentService");
var LiveDocumentService = _LiveDocumentService;

// src/services/collections/FileOperationQueue.ts
init_process_shim();
var _FileOperationQueue = class _FileOperationQueue {
  constructor(collectionId, storage) {
    this.collectionId = collectionId;
    this.storage = storage;
  }
  async create(path) {
    const priorOp = await this.storage.getOperationBy(this.collectionId, path);
    if (!priorOp) {
      return this.enqueueOp(path, "create" /* CREATE */);
    }
    switch (priorOp.type) {
      case "create" /* CREATE */:
      case "update" /* UPDATE */:
        break;
      case "delete" /* DELETE */:
        return this.enqueueOp(path, "update" /* UPDATE */);
      case "move" /* MOVE */:
        await this.enqueueOp(path, "update" /* UPDATE */);
        return this.delete(priorOp.fromPath);
    }
  }
  async update(path) {
    const priorOp = await this.storage.getOperationBy(this.collectionId, path);
    if (!priorOp) {
      return this.enqueueOp(path, "update" /* UPDATE */);
    }
    switch (priorOp.type) {
      case "create" /* CREATE */:
      case "update" /* UPDATE */:
        break;
      case "delete" /* DELETE */:
        return this.enqueueOp(path, "update" /* UPDATE */);
    }
  }
  async move(fromPath, toPath) {
    const sourceOp = await this.storage.getOperationBy(
      this.collectionId,
      fromPath
    );
    const destOp = await this.storage.getOperationBy(this.collectionId, toPath);
    if (!sourceOp && !destOp) {
      return this.enqueueMove(fromPath, toPath);
    }
    if (sourceOp && sourceOp.type === "move" /* MOVE */ && !destOp) {
      const sourceFromPath = sourceOp.fromPath;
      await this.storage.deleteOperation(sourceOp);
      return this.enqueueMove(sourceFromPath, toPath);
    }
    await this.delete(fromPath);
    return this.create(toPath);
  }
  async delete(path) {
    const priorOp = await this.storage.getOperationBy(this.collectionId, path);
    if (!priorOp) {
      return this.enqueueOp(path, "delete" /* DELETE */);
    }
    switch (priorOp.type) {
      case "create" /* CREATE */:
        return this.storage.deleteOperation(priorOp);
      case "update" /* UPDATE */:
        return this.enqueueOp(path, "delete" /* DELETE */);
      case "move" /* MOVE */:
        const fromPath = priorOp.fromPath;
        await this.storage.deleteOperation(priorOp);
        return this.delete(fromPath);
    }
  }
  async enqueueOp(path, type) {
    return this.storage.enqueueOperation({
      collection_id: this.collectionId,
      path,
      type,
      timestamp: Date.now()
    });
  }
  enqueueMove(fromPath, toPath) {
    return this.storage.enqueueOperation({
      collection_id: this.collectionId,
      path: toPath,
      type: "move" /* MOVE */,
      fromPath,
      timestamp: Date.now()
    });
  }
};
__name(_FileOperationQueue, "FileOperationQueue");
var FileOperationQueue = _FileOperationQueue;

// src/services/collections/IDBQueueStorage.ts
init_process_shim();
var OPS_TABLE = "[collection_id+path],timestamp";
var _IDBQueueStorage = class _IDBQueueStorage {
  constructor(table) {
    this.table = table;
  }
  async enqueueOperation(op) {
    await this.table.put(op);
  }
  async deleteOperation(op) {
    return this.table.delete([op.collection_id, op.path]);
  }
  async getOperationBy(collectionId, path) {
    const res = await this.table.get([collectionId, path]);
    return res != null ? res : null;
  }
  async allOperations(collectionId) {
    return this.table.toCollection().sortBy("timestamp");
  }
};
__name(_IDBQueueStorage, "IDBQueueStorage");
var IDBQueueStorage = _IDBQueueStorage;

// src/services/collections/CollectionHandler.ts
var import_debug11 = __toESM(require_browser2());

// node_modules/file-type/core.js
init_process_shim();

// node_modules/token-types/lib/index.js
init_process_shim();
var ieee754 = __toESM(require_ieee754(), 1);
function dv(array) {
  return new DataView(array.buffer, array.byteOffset);
}
__name(dv, "dv");
var UINT8 = {
  len: 1,
  get(array, offset) {
    return dv(array).getUint8(offset);
  },
  put(array, offset, value) {
    dv(array).setUint8(offset, value);
    return offset + 1;
  }
};
var UINT16_LE = {
  len: 2,
  get(array, offset) {
    return dv(array).getUint16(offset, true);
  },
  put(array, offset, value) {
    dv(array).setUint16(offset, value, true);
    return offset + 2;
  }
};
var UINT16_BE = {
  len: 2,
  get(array, offset) {
    return dv(array).getUint16(offset);
  },
  put(array, offset, value) {
    dv(array).setUint16(offset, value);
    return offset + 2;
  }
};
var UINT32_LE = {
  len: 4,
  get(array, offset) {
    return dv(array).getUint32(offset, true);
  },
  put(array, offset, value) {
    dv(array).setUint32(offset, value, true);
    return offset + 4;
  }
};
var UINT32_BE = {
  len: 4,
  get(array, offset) {
    return dv(array).getUint32(offset);
  },
  put(array, offset, value) {
    dv(array).setUint32(offset, value);
    return offset + 4;
  }
};
var INT32_BE = {
  len: 4,
  get(array, offset) {
    return dv(array).getInt32(offset);
  },
  put(array, offset, value) {
    dv(array).setInt32(offset, value);
    return offset + 4;
  }
};
var UINT64_LE = {
  len: 8,
  get(array, offset) {
    return dv(array).getBigUint64(offset, true);
  },
  put(array, offset, value) {
    dv(array).setBigUint64(offset, value, true);
    return offset + 8;
  }
};
var _StringType = class _StringType {
  constructor(len, encoding) {
    this.len = len;
    this.encoding = encoding;
    this.textDecoder = new TextDecoder(encoding);
  }
  get(uint8Array, offset) {
    return this.textDecoder.decode(uint8Array.subarray(offset, offset + this.len));
  }
};
__name(_StringType, "StringType");
var StringType = _StringType;

// node_modules/strtok3/lib/core.js
init_process_shim();

// node_modules/peek-readable/lib/index.js
init_process_shim();

// node_modules/peek-readable/lib/Errors.js
init_process_shim();
var defaultMessages = "End-Of-Stream";
var _EndOfStreamError = class _EndOfStreamError extends Error {
  constructor() {
    super(defaultMessages);
    this.name = "EndOfStreamError";
  }
};
__name(_EndOfStreamError, "EndOfStreamError");
var EndOfStreamError = _EndOfStreamError;
var _AbortError = class _AbortError extends Error {
  constructor(message = "The operation was aborted") {
    super(message);
    this.name = "AbortError";
  }
};
__name(_AbortError, "AbortError");
var AbortError = _AbortError;

// node_modules/peek-readable/lib/StreamReader.js
init_process_shim();

// node_modules/peek-readable/lib/Deferred.js
init_process_shim();

// node_modules/peek-readable/lib/AbstractStreamReader.js
init_process_shim();
var _AbstractStreamReader = class _AbstractStreamReader {
  constructor() {
    this.endOfStream = false;
    this.interrupted = false;
    this.peekQueue = [];
  }
  async peek(uint8Array, mayBeLess = false) {
    const bytesRead = await this.read(uint8Array, mayBeLess);
    this.peekQueue.push(uint8Array.subarray(0, bytesRead));
    return bytesRead;
  }
  async read(buffer, mayBeLess = false) {
    if (buffer.length === 0) {
      return 0;
    }
    let bytesRead = this.readFromPeekBuffer(buffer);
    if (!this.endOfStream) {
      bytesRead += await this.readRemainderFromStream(buffer.subarray(bytesRead), mayBeLess);
    }
    if (bytesRead === 0) {
      throw new EndOfStreamError();
    }
    return bytesRead;
  }
  /**
   * Read chunk from stream
   * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
   * @returns Number of bytes read
   */
  readFromPeekBuffer(buffer) {
    let remaining = buffer.length;
    let bytesRead = 0;
    while (this.peekQueue.length > 0 && remaining > 0) {
      const peekData = this.peekQueue.pop();
      if (!peekData)
        throw new Error("peekData should be defined");
      const lenCopy = Math.min(peekData.length, remaining);
      buffer.set(peekData.subarray(0, lenCopy), bytesRead);
      bytesRead += lenCopy;
      remaining -= lenCopy;
      if (lenCopy < peekData.length) {
        this.peekQueue.push(peekData.subarray(lenCopy));
      }
    }
    return bytesRead;
  }
  async readRemainderFromStream(buffer, mayBeLess) {
    let bytesRead = 0;
    while (bytesRead < buffer.length && !this.endOfStream) {
      if (this.interrupted) {
        throw new AbortError();
      }
      const chunkLen = await this.readFromStream(buffer.subarray(bytesRead), mayBeLess);
      if (chunkLen === 0)
        break;
      bytesRead += chunkLen;
    }
    if (!mayBeLess && bytesRead < buffer.length) {
      throw new EndOfStreamError();
    }
    return bytesRead;
  }
};
__name(_AbstractStreamReader, "AbstractStreamReader");
var AbstractStreamReader = _AbstractStreamReader;

// node_modules/peek-readable/lib/WebStreamByobReader.js
init_process_shim();

// node_modules/peek-readable/lib/WebStreamReader.js
init_process_shim();
var _WebStreamReader = class _WebStreamReader extends AbstractStreamReader {
  constructor(reader) {
    super();
    this.reader = reader;
  }
  async abort() {
    return this.close();
  }
  async close() {
    this.reader.releaseLock();
  }
};
__name(_WebStreamReader, "WebStreamReader");
var WebStreamReader = _WebStreamReader;

// node_modules/peek-readable/lib/WebStreamByobReader.js
var _WebStreamByobReader = class _WebStreamByobReader extends WebStreamReader {
  /**
   * Read from stream
   * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
   * @param mayBeLess - If true, may fill the buffer partially
   * @protected Bytes read
   */
  async readFromStream(buffer, mayBeLess) {
    if (buffer.length === 0)
      return 0;
    const result = await this.reader.read(new Uint8Array(buffer.length), { min: mayBeLess ? void 0 : buffer.length });
    if (result.done) {
      this.endOfStream = result.done;
    }
    if (result.value) {
      buffer.set(result.value);
      return result.value.length;
    }
    return 0;
  }
};
__name(_WebStreamByobReader, "WebStreamByobReader");
var WebStreamByobReader = _WebStreamByobReader;

// node_modules/peek-readable/lib/WebStreamDefaultReader.js
init_process_shim();
var _WebStreamDefaultReader = class _WebStreamDefaultReader extends AbstractStreamReader {
  constructor(reader) {
    super();
    this.reader = reader;
    this.buffer = null;
  }
  /**
   * Copy chunk to target, and store the remainder in this.buffer
   */
  writeChunk(target, chunk) {
    const written = Math.min(chunk.length, target.length);
    target.set(chunk.subarray(0, written));
    if (written < chunk.length) {
      this.buffer = chunk.subarray(written);
    } else {
      this.buffer = null;
    }
    return written;
  }
  /**
   * Read from stream
   * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
   * @param mayBeLess - If true, may fill the buffer partially
   * @protected Bytes read
   */
  async readFromStream(buffer, mayBeLess) {
    if (buffer.length === 0)
      return 0;
    let totalBytesRead = 0;
    if (this.buffer) {
      totalBytesRead += this.writeChunk(buffer, this.buffer);
    }
    while (totalBytesRead < buffer.length && !this.endOfStream) {
      const result = await this.reader.read();
      if (result.done) {
        this.endOfStream = true;
        break;
      }
      if (result.value) {
        totalBytesRead += this.writeChunk(buffer.subarray(totalBytesRead), result.value);
      }
    }
    if (totalBytesRead === 0 && this.endOfStream) {
      throw new EndOfStreamError();
    }
    return totalBytesRead;
  }
  abort() {
    this.interrupted = true;
    return this.reader.cancel();
  }
  async close() {
    await this.abort();
    this.reader.releaseLock();
  }
};
__name(_WebStreamDefaultReader, "WebStreamDefaultReader");
var WebStreamDefaultReader = _WebStreamDefaultReader;

// node_modules/peek-readable/lib/WebStreamReaderFactory.js
init_process_shim();
function makeWebStreamReader(stream) {
  try {
    const reader = stream.getReader({ mode: "byob" });
    if (reader instanceof ReadableStreamDefaultReader) {
      return new WebStreamDefaultReader(reader);
    }
    return new WebStreamByobReader(reader);
  } catch (error) {
    if (error instanceof TypeError) {
      return new WebStreamDefaultReader(stream.getReader());
    }
    throw error;
  }
}
__name(makeWebStreamReader, "makeWebStreamReader");

// node_modules/strtok3/lib/ReadStreamTokenizer.js
init_process_shim();

// node_modules/strtok3/lib/AbstractTokenizer.js
init_process_shim();
var _AbstractTokenizer = class _AbstractTokenizer {
  /**
   * Constructor
   * @param options Tokenizer options
   * @protected
   */
  constructor(options) {
    this.numBuffer = new Uint8Array(8);
    this.position = 0;
    this.onClose = options == null ? void 0 : options.onClose;
    if (options == null ? void 0 : options.abortSignal) {
      options.abortSignal.addEventListener("abort", () => {
        this.abort();
      });
    }
  }
  /**
   * Read a token from the tokenizer-stream
   * @param token - The token to read
   * @param position - If provided, the desired position in the tokenizer-stream
   * @returns Promise with token data
   */
  async readToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.readBuffer(uint8Array, { position });
    if (len < token.len)
      throw new EndOfStreamError();
    return token.get(uint8Array, 0);
  }
  /**
   * Peek a token from the tokenizer-stream.
   * @param token - Token to peek from the tokenizer-stream.
   * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
   * @returns Promise with token data
   */
  async peekToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.peekBuffer(uint8Array, { position });
    if (len < token.len)
      throw new EndOfStreamError();
    return token.get(uint8Array, 0);
  }
  /**
   * Read a numeric token from the stream
   * @param token - Numeric token
   * @returns Promise with number
   */
  async readNumber(token) {
    const len = await this.readBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new EndOfStreamError();
    return token.get(this.numBuffer, 0);
  }
  /**
   * Read a numeric token from the stream
   * @param token - Numeric token
   * @returns Promise with number
   */
  async peekNumber(token) {
    const len = await this.peekBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new EndOfStreamError();
    return token.get(this.numBuffer, 0);
  }
  /**
   * Ignore number of bytes, advances the pointer in under tokenizer-stream.
   * @param length - Number of bytes to ignore
   * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
   */
  async ignore(length2) {
    if (this.fileInfo.size !== void 0) {
      const bytesLeft = this.fileInfo.size - this.position;
      if (length2 > bytesLeft) {
        this.position += bytesLeft;
        return bytesLeft;
      }
    }
    this.position += length2;
    return length2;
  }
  async close() {
    var _a9;
    await this.abort();
    await ((_a9 = this.onClose) == null ? void 0 : _a9.call(this));
  }
  normalizeOptions(uint8Array, options) {
    if (!this.supportsRandomAccess() && options && options.position !== void 0 && options.position < this.position) {
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    }
    return {
      ...{
        mayBeLess: false,
        offset: 0,
        length: uint8Array.length,
        position: this.position
      },
      ...options
    };
  }
  abort() {
    return Promise.resolve();
  }
};
__name(_AbstractTokenizer, "AbstractTokenizer");
var AbstractTokenizer = _AbstractTokenizer;

// node_modules/strtok3/lib/ReadStreamTokenizer.js
var maxBufferSize = 256e3;
var _ReadStreamTokenizer = class _ReadStreamTokenizer extends AbstractTokenizer {
  /**
   * Constructor
   * @param streamReader stream-reader to read from
   * @param options Tokenizer options
   */
  constructor(streamReader, options) {
    var _a9;
    super(options);
    this.streamReader = streamReader;
    this.fileInfo = (_a9 = options == null ? void 0 : options.fileInfo) != null ? _a9 : {};
  }
  /**
   * Read buffer from tokenizer
   * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
   * @param options - Read behaviour options
   * @returns Promise with number of bytes read
   */
  async readBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    const skipBytes = normOptions.position - this.position;
    if (skipBytes > 0) {
      await this.ignore(skipBytes);
      return this.readBuffer(uint8Array, options);
    }
    if (skipBytes < 0) {
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    }
    if (normOptions.length === 0) {
      return 0;
    }
    const bytesRead = await this.streamReader.read(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
    this.position += bytesRead;
    if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
      throw new EndOfStreamError();
    }
    return bytesRead;
  }
  /**
   * Peek (read ahead) buffer from tokenizer
   * @param uint8Array - Uint8Array (or Buffer) to write data to
   * @param options - Read behaviour options
   * @returns Promise with number of bytes peeked
   */
  async peekBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    let bytesRead = 0;
    if (normOptions.position) {
      const skipBytes = normOptions.position - this.position;
      if (skipBytes > 0) {
        const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
        bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
        uint8Array.set(skipBuffer.subarray(skipBytes));
        return bytesRead - skipBytes;
      }
      if (skipBytes < 0) {
        throw new Error("Cannot peek from a negative offset in a stream");
      }
    }
    if (normOptions.length > 0) {
      try {
        bytesRead = await this.streamReader.peek(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
      } catch (err2) {
        if ((options == null ? void 0 : options.mayBeLess) && err2 instanceof EndOfStreamError) {
          return 0;
        }
        throw err2;
      }
      if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
        throw new EndOfStreamError();
      }
    }
    return bytesRead;
  }
  async ignore(length2) {
    const bufSize = Math.min(maxBufferSize, length2);
    const buf = new Uint8Array(bufSize);
    let totBytesRead = 0;
    while (totBytesRead < length2) {
      const remaining = length2 - totBytesRead;
      const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
      if (bytesRead < 0) {
        return bytesRead;
      }
      totBytesRead += bytesRead;
    }
    return totBytesRead;
  }
  abort() {
    return this.streamReader.abort();
  }
  async close() {
    return this.streamReader.close();
  }
  supportsRandomAccess() {
    return false;
  }
};
__name(_ReadStreamTokenizer, "ReadStreamTokenizer");
var ReadStreamTokenizer = _ReadStreamTokenizer;

// node_modules/strtok3/lib/BufferTokenizer.js
init_process_shim();
var _BufferTokenizer = class _BufferTokenizer extends AbstractTokenizer {
  /**
   * Construct BufferTokenizer
   * @param uint8Array - Uint8Array to tokenize
   * @param options Tokenizer options
   */
  constructor(uint8Array, options) {
    var _a9;
    super(options);
    this.uint8Array = uint8Array;
    this.fileInfo = { ...(_a9 = options == null ? void 0 : options.fileInfo) != null ? _a9 : {}, ...{ size: uint8Array.length } };
  }
  /**
   * Read buffer from tokenizer
   * @param uint8Array - Uint8Array to tokenize
   * @param options - Read behaviour options
   * @returns {Promise<number>}
   */
  async readBuffer(uint8Array, options) {
    if (options == null ? void 0 : options.position) {
      this.position = options.position;
    }
    const bytesRead = await this.peekBuffer(uint8Array, options);
    this.position += bytesRead;
    return bytesRead;
  }
  /**
   * Peek (read ahead) buffer from tokenizer
   * @param uint8Array
   * @param options - Read behaviour options
   * @returns {Promise<number>}
   */
  async peekBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
    if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
      throw new EndOfStreamError();
    }
    uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read));
    return bytes2read;
  }
  close() {
    return super.close();
  }
  supportsRandomAccess() {
    return true;
  }
  setPosition(position) {
    this.position = position;
  }
};
__name(_BufferTokenizer, "BufferTokenizer");
var BufferTokenizer = _BufferTokenizer;

// node_modules/strtok3/lib/core.js
function fromWebStream(webStream, options) {
  const webStreamReader = makeWebStreamReader(webStream);
  const _options = options != null ? options : {};
  const chainedClose = _options.onClose;
  _options.onClose = async () => {
    await webStreamReader.close();
    if (chainedClose) {
      return chainedClose();
    }
  };
  return new ReadStreamTokenizer(webStreamReader, _options);
}
__name(fromWebStream, "fromWebStream");
function fromBuffer(uint8Array, options) {
  return new BufferTokenizer(uint8Array, options);
}
__name(fromBuffer, "fromBuffer");

// node_modules/@tokenizer/inflate/lib/index.js
init_process_shim();

// node_modules/fflate/esm/browser.js
init_process_shim();
var u8 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = /* @__PURE__ */ __name(function(eb, start) {
  var b = new u16(31);
  for (var i = 0; i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  }
  var r = new i32(b[30]);
  for (var i = 1; i < 30; ++i) {
    for (var j = b[i]; j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return { b, r };
}, "freb");
var _a8 = freb(fleb, 2);
var fl = _a8.b;
var revfl = _a8.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b.b;
var revfd = _b.r;
var rev = new u16(32768);
for (i = 0; i < 32768; ++i) {
  x = (i & 43690) >> 1 | (i & 21845) << 1;
  x = (x & 52428) >> 2 | (x & 13107) << 2;
  x = (x & 61680) >> 4 | (x & 3855) << 4;
  rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
}
var x;
var i;
var hMap = /* @__PURE__ */ __name(function(cd, mb, r) {
  var s = cd.length;
  var i = 0;
  var l = new u16(mb);
  for (; i < s; ++i) {
    if (cd[i])
      ++l[cd[i] - 1];
  }
  var le = new u16(mb);
  for (i = 1; i < mb; ++i) {
    le[i] = le[i - 1] + l[i - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        var sv = i << 4 | cd[i];
        var r_1 = mb - cd[i];
        var v = le[cd[i] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
          co[rev[v] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
      }
    }
  }
  return co;
}, "hMap");
var flt = new u8(288);
for (i = 0; i < 144; ++i)
  flt[i] = 8;
var i;
for (i = 144; i < 256; ++i)
  flt[i] = 9;
var i;
for (i = 256; i < 280; ++i)
  flt[i] = 7;
var i;
for (i = 280; i < 288; ++i)
  flt[i] = 8;
var i;
var fdt = new u8(32);
for (i = 0; i < 32; ++i)
  fdt[i] = 5;
var i;
var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max2 = /* @__PURE__ */ __name(function(a) {
  var m = a[0];
  for (var i = 1; i < a.length; ++i) {
    if (a[i] > m)
      m = a[i];
  }
  return m;
}, "max");
var bits = /* @__PURE__ */ __name(function(d2, p, m) {
  var o = p / 8 | 0;
  return (d2[o] | d2[o + 1] << 8) >> (p & 7) & m;
}, "bits");
var bits16 = /* @__PURE__ */ __name(function(d2, p) {
  var o = p / 8 | 0;
  return (d2[o] | d2[o + 1] << 8 | d2[o + 2] << 16) >> (p & 7);
}, "bits16");
var shft = /* @__PURE__ */ __name(function(p) {
  return (p + 7) / 8 | 0;
}, "shft");
var slc = /* @__PURE__ */ __name(function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  return new u8(v.subarray(s, e));
}, "slc");
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err = /* @__PURE__ */ __name(function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
}, "err");
var inflt = /* @__PURE__ */ __name(function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = /* @__PURE__ */ __name(function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  }, "cbuf");
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
        if (t > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t), bt);
        st.b = bt += l, st.p = pos = t * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i = 0; i < hcLen; ++i) {
          clt[clim[i]] = bits(dat, pos + i * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max2(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i = 0; i < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >> 4;
          if (s < 16) {
            ldt[i++] = s;
          } else {
            var c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max2(lt);
        dbt = max2(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add2 = sym - 254;
        if (sym > 264) {
          var i = sym - 257, b = fleb[i];
          add2 = bits(dat, pos, (1 << b) - 1) + fl[i];
          pos += b;
        }
        var d2 = dm[bits16(dat, pos) & dms], dsym = d2 >> 4;
        if (!d2)
          err(3);
        pos += d2 & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add2;
        if (bt < dt) {
          var shift = dl - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err(3);
          for (; bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (; bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
}, "inflt");
var et = /* @__PURE__ */ new u8(0);
var gzs = /* @__PURE__ */ __name(function(d2) {
  if (d2[0] != 31 || d2[1] != 139 || d2[2] != 8)
    err(6, "invalid gzip data");
  var flg = d2[3];
  var st = 10;
  if (flg & 4)
    st += (d2[10] | d2[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d2[st++])
    ;
  return st + (flg & 2);
}, "gzs");
var gzl = /* @__PURE__ */ __name(function(d2) {
  var l = d2.length;
  return (d2[l - 4] | d2[l - 3] << 8 | d2[l - 2] << 16 | d2[l - 1] << 24) >>> 0;
}, "gzl");
var zls = /* @__PURE__ */ __name(function(d2, dict) {
  if ((d2[0] & 15) != 8 || d2[0] >> 4 > 7 || (d2[0] << 8 | d2[1]) % 31)
    err(6, "invalid zlib data");
  if ((d2[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d2[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d2[1] >> 3 & 4) + 2;
}, "zls");
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
__name(inflateSync, "inflateSync");
function gunzipSync(data, opts) {
  var st = gzs(data);
  if (st + 8 > data.length)
    err(6, "invalid gzip data");
  return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
}
__name(gunzipSync, "gunzipSync");
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
__name(unzlibSync, "unzlibSync");
function decompressSync(data, opts) {
  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
}
__name(decompressSync, "decompressSync");
var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e) {
}

// node_modules/@tokenizer/inflate/lib/index.js
var import_debug10 = __toESM(require_browser2(), 1);

// node_modules/@tokenizer/inflate/lib/ZipToken.js
init_process_shim();
var Signature = {
  LocalFileHeader: 67324752,
  DataDescriptor: 134695760,
  CentralFileHeader: 33639248,
  EndOfCentralDirectory: 101010256
};
var DataDescriptor = {
  get(array) {
    const flags = UINT16_LE.get(array, 6);
    return {
      signature: UINT32_LE.get(array, 0),
      compressedSize: UINT32_LE.get(array, 8),
      uncompressedSize: UINT32_LE.get(array, 12)
    };
  },
  len: 16
};
var LocalFileHeaderToken = {
  get(array) {
    const flags = UINT16_LE.get(array, 6);
    return {
      signature: UINT32_LE.get(array, 0),
      minVersion: UINT16_LE.get(array, 4),
      dataDescriptor: !!(flags & 8),
      compressedMethod: UINT16_LE.get(array, 8),
      compressedSize: UINT32_LE.get(array, 18),
      uncompressedSize: UINT32_LE.get(array, 22),
      filenameLength: UINT16_LE.get(array, 26),
      extraFieldLength: UINT16_LE.get(array, 28),
      filename: null
    };
  },
  len: 30
};
var EndOfCentralDirectoryRecordToken = {
  get(array) {
    return {
      signature: UINT32_LE.get(array, 0),
      nrOfThisDisk: UINT16_LE.get(array, 4),
      nrOfThisDiskWithTheStart: UINT16_LE.get(array, 6),
      nrOfEntriesOnThisDisk: UINT16_LE.get(array, 8),
      nrOfEntriesOfSize: UINT16_LE.get(array, 10),
      sizeOfCd: UINT32_LE.get(array, 12),
      offsetOfStartOfCd: UINT32_LE.get(array, 16),
      zipFileCommentLength: UINT16_LE.get(array, 20)
    };
  },
  len: 22
};
var FileHeader = {
  get(array) {
    const flags = UINT16_LE.get(array, 8);
    return {
      signature: UINT32_LE.get(array, 0),
      minVersion: UINT16_LE.get(array, 6),
      dataDescriptor: !!(flags & 8),
      compressedMethod: UINT16_LE.get(array, 10),
      compressedSize: UINT32_LE.get(array, 20),
      uncompressedSize: UINT32_LE.get(array, 24),
      filenameLength: UINT16_LE.get(array, 28),
      extraFieldLength: UINT16_LE.get(array, 30),
      fileCommentLength: UINT16_LE.get(array, 32),
      relativeOffsetOfLocalHeader: UINT32_LE.get(array, 42),
      filename: null
    };
  },
  len: 46
};

// node_modules/@tokenizer/inflate/lib/index.js
function signatureToArray(signature) {
  const signatureBytes = new Uint8Array(UINT32_LE.len);
  UINT32_LE.put(signatureBytes, 0, signature);
  return signatureBytes;
}
__name(signatureToArray, "signatureToArray");
var debug10 = (0, import_debug10.default)("tokenizer:inflate");
var syncBufferSize = 256 * 1024;
var ddSignatureArray = signatureToArray(Signature.DataDescriptor);
var eocdSignatureBytes = signatureToArray(Signature.EndOfCentralDirectory);
var _ZipHandler = class _ZipHandler {
  constructor(tokenizer) {
    this.tokenizer = tokenizer;
    this.syncBuffer = new Uint8Array(syncBufferSize);
  }
  async isZip() {
    return await this.peekSignature() === Signature.LocalFileHeader;
  }
  peekSignature() {
    return this.tokenizer.peekToken(UINT32_LE);
  }
  async findEndOfCentralDirectoryLocator() {
    const randomReadTokenizer = this.tokenizer;
    const chunkLength = Math.min(16 * 1024, randomReadTokenizer.fileInfo.size);
    const buffer = this.syncBuffer.subarray(0, chunkLength);
    await this.tokenizer.readBuffer(buffer, { position: randomReadTokenizer.fileInfo.size - chunkLength });
    for (let i = buffer.length - 4; i >= 0; i--) {
      if (buffer[i] === eocdSignatureBytes[0] && buffer[i + 1] === eocdSignatureBytes[1] && buffer[i + 2] === eocdSignatureBytes[2] && buffer[i + 3] === eocdSignatureBytes[3]) {
        return randomReadTokenizer.fileInfo.size - chunkLength + i;
      }
    }
    return -1;
  }
  async readCentralDirectory() {
    if (!this.tokenizer.supportsRandomAccess()) {
      debug10("Cannot reading central-directory without random-read support");
      return;
    }
    debug10("Reading central-directory...");
    const pos = this.tokenizer.position;
    const offset = await this.findEndOfCentralDirectoryLocator();
    if (offset > 0) {
      debug10("Central-directory 32-bit signature found");
      const eocdHeader = await this.tokenizer.readToken(EndOfCentralDirectoryRecordToken, offset);
      const files = [];
      this.tokenizer.setPosition(eocdHeader.offsetOfStartOfCd);
      for (let n = 0; n < eocdHeader.nrOfEntriesOfSize; ++n) {
        const entry = await this.tokenizer.readToken(FileHeader);
        if (entry.signature !== Signature.CentralFileHeader) {
          throw new Error("Expected Central-File-Header signature");
        }
        entry.filename = await this.tokenizer.readToken(new StringType(entry.filenameLength, "utf-8"));
        await this.tokenizer.ignore(entry.extraFieldLength);
        await this.tokenizer.ignore(entry.fileCommentLength);
        files.push(entry);
        debug10(`Add central-directory file-entry: n=${n + 1}/${files.length}: filename=${files[n].filename}`);
      }
      this.tokenizer.setPosition(pos);
      return files;
    }
    this.tokenizer.setPosition(pos);
  }
  async unzip(fileCb) {
    const entries = await this.readCentralDirectory();
    if (entries) {
      return this.iterateOverCentralDirectory(entries, fileCb);
    }
    let stop = false;
    do {
      const zipHeader = await this.readLocalFileHeader();
      if (!zipHeader)
        break;
      const next = fileCb(zipHeader);
      stop = !!next.stop;
      let fileData = void 0;
      await this.tokenizer.ignore(zipHeader.extraFieldLength);
      if (zipHeader.dataDescriptor && zipHeader.compressedSize === 0) {
        const chunks = [];
        let len = syncBufferSize;
        debug10("Compressed-file-size unknown, scanning for next data-descriptor-signature....");
        let nextHeaderIndex = -1;
        while (nextHeaderIndex < 0 && len === syncBufferSize) {
          len = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: true });
          nextHeaderIndex = indexOf(this.syncBuffer.subarray(0, len), ddSignatureArray);
          const size2 = nextHeaderIndex >= 0 ? nextHeaderIndex : len;
          if (next.handler) {
            const data = new Uint8Array(size2);
            await this.tokenizer.readBuffer(data);
            chunks.push(data);
          } else {
            await this.tokenizer.ignore(size2);
          }
        }
        debug10(`Found data-descriptor-signature at pos=${this.tokenizer.position}`);
        if (next.handler) {
          await this.inflate(zipHeader, mergeArrays(chunks), next.handler);
        }
      } else {
        if (next.handler) {
          debug10(`Reading compressed-file-data: ${zipHeader.compressedSize} bytes`);
          fileData = new Uint8Array(zipHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next.handler);
        } else {
          debug10(`Ignoring compressed-file-data: ${zipHeader.compressedSize} bytes`);
          await this.tokenizer.ignore(zipHeader.compressedSize);
        }
      }
      debug10(`Reading data-descriptor at pos=${this.tokenizer.position}`);
      if (zipHeader.dataDescriptor) {
        const dataDescriptor = await this.tokenizer.readToken(DataDescriptor);
        if (dataDescriptor.signature !== 134695760) {
          throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - DataDescriptor.len}`);
        }
      }
    } while (!stop);
  }
  async iterateOverCentralDirectory(entries, fileCb) {
    for (const fileHeader of entries) {
      const next = fileCb(fileHeader);
      if (next.handler) {
        this.tokenizer.setPosition(fileHeader.relativeOffsetOfLocalHeader);
        const zipHeader = await this.readLocalFileHeader();
        if (zipHeader) {
          await this.tokenizer.ignore(zipHeader.extraFieldLength);
          const fileData = new Uint8Array(fileHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next.handler);
        }
      }
      if (next.stop)
        break;
    }
  }
  inflate(zipHeader, fileData, cb) {
    if (zipHeader.compressedMethod === 0) {
      return cb(fileData);
    }
    debug10(`Decompress filename=${zipHeader.filename}, compressed-size=${fileData.length}`);
    const uncompressedData = decompressSync(fileData);
    return cb(uncompressedData);
  }
  async readLocalFileHeader() {
    const signature = await this.tokenizer.peekToken(UINT32_LE);
    if (signature === Signature.LocalFileHeader) {
      const header = await this.tokenizer.readToken(LocalFileHeaderToken);
      header.filename = await this.tokenizer.readToken(new StringType(header.filenameLength, "utf-8"));
      return header;
    }
    if (signature === Signature.CentralFileHeader) {
      return false;
    }
    if (signature === 3759263696) {
      throw new Error("Encrypted ZIP");
    }
    throw new Error("Unexpected signature");
  }
};
__name(_ZipHandler, "ZipHandler");
var ZipHandler = _ZipHandler;
function indexOf(buffer, portion) {
  const bufferLength = buffer.length;
  const portionLength = portion.length;
  if (portionLength > bufferLength)
    return -1;
  for (let i = 0; i <= bufferLength - portionLength; i++) {
    let found = true;
    for (let j = 0; j < portionLength; j++) {
      if (buffer[i + j] !== portion[j]) {
        found = false;
        break;
      }
    }
    if (found) {
      return i;
    }
  }
  return -1;
}
__name(indexOf, "indexOf");
function mergeArrays(chunks) {
  const totalLength = chunks.reduce((acc, curr) => acc + curr.length, 0);
  const mergedArray = new Uint8Array(totalLength);
  let offset = 0;
  for (const chunk of chunks) {
    mergedArray.set(chunk, offset);
    offset += chunk.length;
  }
  return mergedArray;
}
__name(mergeArrays, "mergeArrays");

// node_modules/uint8array-extras/index.js
init_process_shim();
var cachedDecoders = {
  utf8: new globalThis.TextDecoder("utf8")
};
var cachedEncoder = new globalThis.TextEncoder();
var byteToHexLookupTable = Array.from({ length: 256 }, (_, index) => index.toString(16).padStart(2, "0"));
function getUintBE(view) {
  const { byteLength } = view;
  if (byteLength === 6) {
    return view.getUint16(0) * 2 ** 32 + view.getUint32(2);
  }
  if (byteLength === 5) {
    return view.getUint8(0) * 2 ** 32 + view.getUint32(1);
  }
  if (byteLength === 4) {
    return view.getUint32(0);
  }
  if (byteLength === 3) {
    return view.getUint8(0) * 2 ** 16 + view.getUint16(1);
  }
  if (byteLength === 2) {
    return view.getUint16(0);
  }
  if (byteLength === 1) {
    return view.getUint8(0);
  }
}
__name(getUintBE, "getUintBE");

// node_modules/file-type/util.js
init_process_shim();
function stringToBytes(string) {
  return [...string].map((character) => character.charCodeAt(0));
}
__name(stringToBytes, "stringToBytes");
function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
  const readSum = Number.parseInt(new StringType(6).get(arrayBuffer, 148).replace(/\0.*$/, "").trim(), 8);
  if (Number.isNaN(readSum)) {
    return false;
  }
  let sum = 8 * 32;
  for (let index = offset; index < offset + 148; index++) {
    sum += arrayBuffer[index];
  }
  for (let index = offset + 156; index < offset + 512; index++) {
    sum += arrayBuffer[index];
  }
  return readSum === sum;
}
__name(tarHeaderChecksumMatches, "tarHeaderChecksumMatches");
var uint32SyncSafeToken = {
  get: /* @__PURE__ */ __name((buffer, offset) => buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21, "get"),
  len: 4
};

// node_modules/file-type/supported.js
init_process_shim();
var extensions = [
  "jpg",
  "png",
  "apng",
  "gif",
  "webp",
  "flif",
  "xcf",
  "cr2",
  "cr3",
  "orf",
  "arw",
  "dng",
  "nef",
  "rw2",
  "raf",
  "tif",
  "bmp",
  "icns",
  "jxr",
  "psd",
  "indd",
  "zip",
  "tar",
  "rar",
  "gz",
  "bz2",
  "7z",
  "dmg",
  "mp4",
  "mid",
  "mkv",
  "webm",
  "mov",
  "avi",
  "mpg",
  "mp2",
  "mp3",
  "m4a",
  "oga",
  "ogg",
  "ogv",
  "opus",
  "flac",
  "wav",
  "spx",
  "amr",
  "pdf",
  "epub",
  "elf",
  "macho",
  "exe",
  "swf",
  "rtf",
  "wasm",
  "woff",
  "woff2",
  "eot",
  "ttf",
  "otf",
  "ttc",
  "ico",
  "flv",
  "ps",
  "xz",
  "sqlite",
  "nes",
  "crx",
  "xpi",
  "cab",
  "deb",
  "ar",
  "rpm",
  "Z",
  "lz",
  "cfb",
  "mxf",
  "mts",
  "blend",
  "bpg",
  "docx",
  "pptx",
  "xlsx",
  "3gp",
  "3g2",
  "j2c",
  "jp2",
  "jpm",
  "jpx",
  "mj2",
  "aif",
  "qcp",
  "odt",
  "ods",
  "odp",
  "xml",
  "mobi",
  "heic",
  "cur",
  "ktx",
  "ape",
  "wv",
  "dcm",
  "ics",
  "glb",
  "pcap",
  "dsf",
  "lnk",
  "alias",
  "voc",
  "ac3",
  "m4v",
  "m4p",
  "m4b",
  "f4v",
  "f4p",
  "f4b",
  "f4a",
  "mie",
  "asf",
  "ogm",
  "ogx",
  "mpc",
  "arrow",
  "shp",
  "aac",
  "mp1",
  "it",
  "s3m",
  "xm",
  "skp",
  "avif",
  "eps",
  "lzh",
  "pgp",
  "asar",
  "stl",
  "chm",
  "3mf",
  "zst",
  "jxl",
  "vcf",
  "jls",
  "pst",
  "dwg",
  "parquet",
  "class",
  "arj",
  "cpio",
  "ace",
  "avro",
  "icc",
  "fbx",
  "vsdx",
  "vtt",
  "apk",
  "drc",
  "lz4",
  "potx",
  "xltx",
  "dotx",
  "xltm",
  "ott",
  "ots",
  "otp",
  "odg",
  "otg",
  "xlsm",
  "docm",
  "dotm",
  "potm",
  "pptm",
  "jar",
  "rm",
  "ppsm",
  "ppsx"
];
var mimeTypes = [
  "image/jpeg",
  "image/png",
  "image/gif",
  "image/webp",
  "image/flif",
  "image/x-xcf",
  "image/x-canon-cr2",
  "image/x-canon-cr3",
  "image/tiff",
  "image/bmp",
  "image/vnd.ms-photo",
  "image/vnd.adobe.photoshop",
  "application/x-indesign",
  "application/epub+zip",
  "application/x-xpinstall",
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
  "application/vnd.oasis.opendocument.text",
  "application/vnd.oasis.opendocument.spreadsheet",
  "application/vnd.oasis.opendocument.presentation",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  "application/vnd.openxmlformats-officedocument.presentationml.presentation",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
  "application/zip",
  "application/x-tar",
  "application/x-rar-compressed",
  "application/gzip",
  "application/x-bzip2",
  "application/x-7z-compressed",
  "application/x-apple-diskimage",
  "application/vnd.apache.arrow.file",
  "video/mp4",
  "audio/midi",
  "video/matroska",
  "video/webm",
  "video/quicktime",
  "video/vnd.avi",
  "audio/wav",
  "audio/qcelp",
  "audio/x-ms-asf",
  "video/x-ms-asf",
  "application/vnd.ms-asf",
  "video/mpeg",
  "video/3gpp",
  "audio/mpeg",
  "audio/mp4",
  // RFC 4337
  "video/ogg",
  "audio/ogg",
  "audio/ogg; codecs=opus",
  "application/ogg",
  "audio/flac",
  "audio/ape",
  "audio/wavpack",
  "audio/amr",
  "application/pdf",
  "application/x-elf",
  "application/x-mach-binary",
  "application/x-msdownload",
  "application/x-shockwave-flash",
  "application/rtf",
  "application/wasm",
  "font/woff",
  "font/woff2",
  "application/vnd.ms-fontobject",
  "font/ttf",
  "font/otf",
  "font/collection",
  "image/x-icon",
  "video/x-flv",
  "application/postscript",
  "application/eps",
  "application/x-xz",
  "application/x-sqlite3",
  "application/x-nintendo-nes-rom",
  "application/x-google-chrome-extension",
  "application/vnd.ms-cab-compressed",
  "application/x-deb",
  "application/x-unix-archive",
  "application/x-rpm",
  "application/x-compress",
  "application/x-lzip",
  "application/x-cfb",
  "application/x-mie",
  "application/mxf",
  "video/mp2t",
  "application/x-blender",
  "image/bpg",
  "image/j2c",
  "image/jp2",
  "image/jpx",
  "image/jpm",
  "image/mj2",
  "audio/aiff",
  "application/xml",
  "application/x-mobipocket-ebook",
  "image/heif",
  "image/heif-sequence",
  "image/heic",
  "image/heic-sequence",
  "image/icns",
  "image/ktx",
  "application/dicom",
  "audio/x-musepack",
  "text/calendar",
  "text/vcard",
  "text/vtt",
  "model/gltf-binary",
  "application/vnd.tcpdump.pcap",
  "audio/x-dsf",
  // Non-standard
  "application/x.ms.shortcut",
  // Invented by us
  "application/x.apple.alias",
  // Invented by us
  "audio/x-voc",
  "audio/vnd.dolby.dd-raw",
  "audio/x-m4a",
  "image/apng",
  "image/x-olympus-orf",
  "image/x-sony-arw",
  "image/x-adobe-dng",
  "image/x-nikon-nef",
  "image/x-panasonic-rw2",
  "image/x-fujifilm-raf",
  "video/x-m4v",
  "video/3gpp2",
  "application/x-esri-shape",
  "audio/aac",
  "audio/x-it",
  "audio/x-s3m",
  "audio/x-xm",
  "video/MP1S",
  "video/MP2P",
  "application/vnd.sketchup.skp",
  "image/avif",
  "application/x-lzh-compressed",
  "application/pgp-encrypted",
  "application/x-asar",
  "model/stl",
  "application/vnd.ms-htmlhelp",
  "model/3mf",
  "image/jxl",
  "application/zstd",
  "image/jls",
  "application/vnd.ms-outlook",
  "image/vnd.dwg",
  "application/vnd.apache.parquet",
  "application/java-vm",
  "application/x-arj",
  "application/x-cpio",
  "application/x-ace-compressed",
  "application/avro",
  "application/vnd.iccprofile",
  "application/x.autodesk.fbx",
  // Invented by us
  "application/vnd.visio",
  "application/vnd.android.package-archive",
  "application/vnd.google.draco",
  // Invented by us
  "application/x-lz4",
  // Invented by us
  "application/vnd.openxmlformats-officedocument.presentationml.template",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
  "application/vnd.ms-excel.template.macroenabled.12",
  "application/vnd.oasis.opendocument.text-template",
  "application/vnd.oasis.opendocument.spreadsheet-template",
  "application/vnd.oasis.opendocument.presentation-template",
  "application/vnd.oasis.opendocument.graphics",
  "application/vnd.oasis.opendocument.graphics-template",
  "application/vnd.ms-excel.sheet.macroenabled.12",
  "application/vnd.ms-word.document.macroenabled.12",
  "application/vnd.ms-word.template.macroenabled.12",
  "application/vnd.ms-powerpoint.template.macroenabled.12",
  "application/vnd.ms-powerpoint.presentation.macroenabled.12",
  "application/java-archive",
  "application/vnd.rn-realmedia"
];

// node_modules/file-type/core.js
var reasonableDetectionSizeInBytes = 4100;
async function fileTypeFromBuffer(input, options) {
  return new FileTypeParser(options).fromBuffer(input);
}
__name(fileTypeFromBuffer, "fileTypeFromBuffer");
function getFileTypeFromMimeType(mimeType) {
  mimeType = mimeType.toLowerCase();
  switch (mimeType) {
    case "application/epub+zip":
      return {
        ext: "epub",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.text":
      return {
        ext: "odt",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.text-template":
      return {
        ext: "ott",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.spreadsheet":
      return {
        ext: "ods",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.spreadsheet-template":
      return {
        ext: "ots",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.presentation":
      return {
        ext: "odp",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.presentation-template":
      return {
        ext: "otp",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.graphics":
      return {
        ext: "odg",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.graphics-template":
      return {
        ext: "otg",
        mime: mimeType
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
      return {
        ext: "ppsx",
        mime: mimeType
      };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
      return {
        ext: "xlsx",
        mime: mimeType
      };
    case "application/vnd.ms-excel.sheet.macroenabled":
      return {
        ext: "xlsm",
        mime: "application/vnd.ms-excel.sheet.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
      return {
        ext: "xltx",
        mime: mimeType
      };
    case "application/vnd.ms-excel.template.macroenabled":
      return {
        ext: "xltm",
        mime: "application/vnd.ms-excel.template.macroenabled.12"
      };
    case "application/vnd.ms-powerpoint.slideshow.macroenabled":
      return {
        ext: "ppsm",
        mime: "application/vnd.ms-powerpoint.slideshow.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
      return {
        ext: "docx",
        mime: mimeType
      };
    case "application/vnd.ms-word.document.macroenabled":
      return {
        ext: "docm",
        mime: "application/vnd.ms-word.document.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
      return {
        ext: "dotx",
        mime: mimeType
      };
    case "application/vnd.ms-word.template.macroenabledtemplate":
      return {
        ext: "dotm",
        mime: "application/vnd.ms-word.template.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.template":
      return {
        ext: "potx",
        mime: mimeType
      };
    case "application/vnd.ms-powerpoint.template.macroenabled":
      return {
        ext: "potm",
        mime: "application/vnd.ms-powerpoint.template.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
      return {
        ext: "pptx",
        mime: mimeType
      };
    case "application/vnd.ms-powerpoint.presentation.macroenabled":
      return {
        ext: "pptm",
        mime: "application/vnd.ms-powerpoint.presentation.macroenabled.12"
      };
    case "application/vnd.ms-visio.drawing":
      return {
        ext: "vsdx",
        mime: "application/vnd.visio"
      };
    case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
      return {
        ext: "3mf",
        mime: "model/3mf"
      };
    default:
  }
}
__name(getFileTypeFromMimeType, "getFileTypeFromMimeType");
function _check(buffer, headers, options) {
  options = {
    offset: 0,
    ...options
  };
  for (const [index, header] of headers.entries()) {
    if (options.mask) {
      if (header !== (options.mask[index] & buffer[index + options.offset])) {
        return false;
      }
    } else if (header !== buffer[index + options.offset]) {
      return false;
    }
  }
  return true;
}
__name(_check, "_check");
var _FileTypeParser = class _FileTypeParser {
  constructor(options) {
    // Detections with a high degree of certainty in identifying the correct file type
    __publicField(this, "detectConfident", /* @__PURE__ */ __name(async (tokenizer) => {
      this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
      if (tokenizer.fileInfo.size === void 0) {
        tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
      }
      this.tokenizer = tokenizer;
      await tokenizer.peekBuffer(this.buffer, { length: 12, mayBeLess: true });
      if (this.check([66, 77])) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (this.check([11, 119])) {
        return {
          ext: "ac3",
          mime: "audio/vnd.dolby.dd-raw"
        };
      }
      if (this.check([120, 1])) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (this.check([77, 90])) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if (this.check([37, 33])) {
        await tokenizer.peekBuffer(this.buffer, { length: 24, mayBeLess: true });
        if (this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 })) {
          return {
            ext: "eps",
            mime: "application/eps"
          };
        }
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (this.check([31, 160]) || this.check([31, 157])) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (this.check([199, 113])) {
        return {
          ext: "cpio",
          mime: "application/x-cpio"
        };
      }
      if (this.check([96, 234])) {
        return {
          ext: "arj",
          mime: "application/x-arj"
        };
      }
      if (this.check([239, 187, 191])) {
        this.tokenizer.ignore(3);
        return this.detectConfident(tokenizer);
      }
      if (this.check([71, 73, 70])) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (this.check([73, 73, 188])) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (this.check([31, 139, 8])) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (this.check([66, 90, 104])) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (this.checkString("ID3")) {
        await tokenizer.ignore(6);
        const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
        if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
        await tokenizer.ignore(id3HeaderLength);
        return this.fromTokenizer(tokenizer);
      }
      if (this.checkString("MP+")) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (this.check([255, 216, 255])) {
        if (this.check([247], { offset: 3 })) {
          return {
            ext: "jls",
            mime: "image/jls"
          };
        }
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (this.check([79, 98, 106, 1])) {
        return {
          ext: "avro",
          mime: "application/avro"
        };
      }
      if (this.checkString("FLIF")) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if (this.checkString("8BPS")) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (this.checkString("MPCK")) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if (this.checkString("FORM")) {
        return {
          ext: "aif",
          mime: "audio/aiff"
        };
      }
      if (this.checkString("icns", { offset: 0 })) {
        return {
          ext: "icns",
          mime: "image/icns"
        };
      }
      if (this.check([80, 75, 3, 4])) {
        let fileType;
        await new ZipHandler(tokenizer).unzip((zipHeader) => {
          switch (zipHeader.filename) {
            case "META-INF/mozilla.rsa":
              fileType = {
                ext: "xpi",
                mime: "application/x-xpinstall"
              };
              return {
                stop: true
              };
            case "META-INF/MANIFEST.MF":
              fileType = {
                ext: "jar",
                mime: "application/java-archive"
              };
              return {
                stop: true
              };
            case "mimetype":
              return {
                async handler(fileData) {
                  const mimeType = new TextDecoder("utf-8").decode(fileData).trim();
                  fileType = getFileTypeFromMimeType(mimeType);
                },
                stop: true
              };
            case "[Content_Types].xml":
              return {
                async handler(fileData) {
                  let xmlContent = new TextDecoder("utf-8").decode(fileData);
                  const endPos = xmlContent.indexOf('.main+xml"');
                  if (endPos === -1) {
                    const mimeType = "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
                    if (xmlContent.includes(`ContentType="${mimeType}"`)) {
                      fileType = getFileTypeFromMimeType(mimeType);
                    }
                  } else {
                    xmlContent = xmlContent.slice(0, Math.max(0, endPos));
                    const firstPos = xmlContent.lastIndexOf('"');
                    const mimeType = xmlContent.slice(Math.max(0, firstPos + 1));
                    fileType = getFileTypeFromMimeType(mimeType);
                  }
                },
                stop: true
              };
            default:
              if (/classes\d*\.dex/.test(zipHeader.filename)) {
                fileType = {
                  ext: "apk",
                  mime: "application/vnd.android.package-archive"
                };
                return { stop: true };
              }
              return {};
          }
        });
        return fileType != null ? fileType : {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (this.checkString("OggS")) {
        await tokenizer.ignore(28);
        const type = new Uint8Array(8);
        await tokenizer.readBuffer(type);
        if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
          return {
            ext: "opus",
            mime: "audio/ogg; codecs=opus"
          };
        }
        if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
          return {
            ext: "ogv",
            mime: "video/ogg"
          };
        }
        if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
          return {
            ext: "ogm",
            mime: "video/ogg"
          };
        }
        if (_check(type, [127, 70, 76, 65, 67])) {
          return {
            ext: "oga",
            mime: "audio/ogg"
          };
        }
        if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
          return {
            ext: "spx",
            mime: "audio/ogg"
          };
        }
        if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
          return {
            ext: "ogg",
            mime: "audio/ogg"
          };
        }
        return {
          ext: "ogx",
          mime: "application/ogg"
        };
      }
      if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (this.checkString("MThd")) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
        return {
          ext: "woff",
          mime: "font/woff"
        };
      }
      if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
        return {
          ext: "woff2",
          mime: "font/woff2"
        };
      }
      if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) {
        return {
          ext: "pcap",
          mime: "application/vnd.tcpdump.pcap"
        };
      }
      if (this.checkString("DSD ")) {
        return {
          ext: "dsf",
          mime: "audio/x-dsf"
          // Non-standard
        };
      }
      if (this.checkString("LZIP")) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (this.checkString("fLaC")) {
        return {
          ext: "flac",
          mime: "audio/flac"
        };
      }
      if (this.check([66, 80, 71, 251])) {
        return {
          ext: "bpg",
          mime: "image/bpg"
        };
      }
      if (this.checkString("wvpk")) {
        return {
          ext: "wv",
          mime: "audio/wavpack"
        };
      }
      if (this.checkString("%PDF")) {
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (this.check([0, 97, 115, 109])) {
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      }
      if (this.check([73, 73])) {
        const fileType = await this.readTiffHeader(false);
        if (fileType) {
          return fileType;
        }
      }
      if (this.check([77, 77])) {
        const fileType = await this.readTiffHeader(true);
        if (fileType) {
          return fileType;
        }
      }
      if (this.checkString("MAC ")) {
        return {
          ext: "ape",
          mime: "audio/ape"
        };
      }
      if (this.check([26, 69, 223, 163])) {
        async function readField() {
          const msb = await tokenizer.peekNumber(UINT8);
          let mask = 128;
          let ic = 0;
          while ((msb & mask) === 0 && mask !== 0) {
            ++ic;
            mask >>= 1;
          }
          const id2 = new Uint8Array(ic + 1);
          await tokenizer.readBuffer(id2);
          return id2;
        }
        __name(readField, "readField");
        async function readElement() {
          const idField = await readField();
          const lengthField = await readField();
          lengthField[0] ^= 128 >> lengthField.length - 1;
          const nrLength = Math.min(6, lengthField.length);
          const idView = new DataView(idField.buffer);
          const lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);
          return {
            id: getUintBE(idView),
            len: getUintBE(lengthView)
          };
        }
        __name(readElement, "readElement");
        async function readChildren(children) {
          while (children > 0) {
            const element2 = await readElement();
            if (element2.id === 17026) {
              const rawValue = await tokenizer.readToken(new StringType(element2.len));
              return rawValue.replaceAll(/\00.*$/g, "");
            }
            await tokenizer.ignore(element2.len);
            --children;
          }
        }
        __name(readChildren, "readChildren");
        const re = await readElement();
        const documentType = await readChildren(re.len);
        switch (documentType) {
          case "webm":
            return {
              ext: "webm",
              mime: "video/webm"
            };
          case "matroska":
            return {
              ext: "mkv",
              mime: "video/matroska"
            };
          default:
            return;
        }
      }
      if (this.checkString("SQLi")) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (this.check([78, 69, 83, 26])) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (this.checkString("Cr24")) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (this.checkString("MSCF") || this.checkString("ISc(")) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (this.check([237, 171, 238, 219])) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (this.check([197, 208, 211, 198])) {
        return {
          ext: "eps",
          mime: "application/eps"
        };
      }
      if (this.check([40, 181, 47, 253])) {
        return {
          ext: "zst",
          mime: "application/zstd"
        };
      }
      if (this.check([127, 69, 76, 70])) {
        return {
          ext: "elf",
          mime: "application/x-elf"
        };
      }
      if (this.check([33, 66, 68, 78])) {
        return {
          ext: "pst",
          mime: "application/vnd.ms-outlook"
        };
      }
      if (this.checkString("PAR1") || this.checkString("PARE")) {
        return {
          ext: "parquet",
          mime: "application/vnd.apache.parquet"
        };
      }
      if (this.checkString("ttcf")) {
        return {
          ext: "ttc",
          mime: "font/collection"
        };
      }
      if (this.check([207, 250, 237, 254])) {
        return {
          ext: "macho",
          mime: "application/x-mach-binary"
        };
      }
      if (this.check([4, 34, 77, 24])) {
        return {
          ext: "lz4",
          mime: "application/x-lz4"
          // Invented by us
        };
      }
      if (this.check([79, 84, 84, 79, 0])) {
        return {
          ext: "otf",
          mime: "font/otf"
        };
      }
      if (this.checkString("#!AMR")) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (this.checkString("{\\rtf")) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (this.check([70, 76, 86, 1])) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (this.checkString("IMPM")) {
        return {
          ext: "it",
          mime: "audio/x-it"
        };
      }
      if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 })) {
        return {
          ext: "lzh",
          mime: "application/x-lzh-compressed"
        };
      }
      if (this.check([0, 0, 1, 186])) {
        if (this.check([33], { offset: 4, mask: [241] })) {
          return {
            ext: "mpg",
            // May also be .ps, .mpeg
            mime: "video/MP1S"
          };
        }
        if (this.check([68], { offset: 4, mask: [196] })) {
          return {
            ext: "mpg",
            // May also be .mpg, .m2p, .vob or .sub
            mime: "video/MP2P"
          };
        }
      }
      if (this.checkString("ITSF")) {
        return {
          ext: "chm",
          mime: "application/vnd.ms-htmlhelp"
        };
      }
      if (this.check([202, 254, 186, 190])) {
        return {
          ext: "class",
          mime: "application/java-vm"
        };
      }
      if (this.checkString(".RMF")) {
        return {
          ext: "rm",
          mime: "application/vnd.rn-realmedia"
        };
      }
      if (this.checkString("DRACO")) {
        return {
          ext: "drc",
          mime: "application/vnd.google.draco"
          // Invented by us
        };
      }
      if (this.check([253, 55, 122, 88, 90, 0])) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (this.checkString("<?xml ")) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (this.check([55, 122, 188, 175, 39, 28])) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (this.checkString("solid ")) {
        return {
          ext: "stl",
          mime: "model/stl"
        };
      }
      if (this.checkString("AC")) {
        const version = new StringType(4, "latin1").get(this.buffer, 2);
        if (version.match("^d*") && version >= 1e3 && version <= 1050) {
          return {
            ext: "dwg",
            mime: "image/vnd.dwg"
          };
        }
      }
      if (this.checkString("070707")) {
        return {
          ext: "cpio",
          mime: "application/x-cpio"
        };
      }
      if (this.checkString("BLENDER")) {
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      }
      if (this.checkString("!<arch>")) {
        await tokenizer.ignore(8);
        const string = await tokenizer.readToken(new StringType(13, "ascii"));
        if (string === "debian-binary") {
          return {
            ext: "deb",
            mime: "application/x-deb"
          };
        }
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (this.checkString("WEBVTT") && // One of LF, CR, tab, space, or end of file must follow "WEBVTT" per the spec (see `fixture/fixture-vtt-*.vtt` for examples). Note that `\0` is technically the null character (there is no such thing as an EOF character). However, checking for `\0` gives us the same result as checking for the end of the stream.
      ["\n", "\r", "	", " ", "\0"].some((char7) => this.checkString(char7, { offset: 6 }))) {
        return {
          ext: "vtt",
          mime: "text/vtt"
        };
      }
      if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
        await tokenizer.ignore(8);
        async function readChunkHeader() {
          return {
            length: await tokenizer.readToken(INT32_BE),
            type: await tokenizer.readToken(new StringType(4, "latin1"))
          };
        }
        __name(readChunkHeader, "readChunkHeader");
        do {
          const chunk = await readChunkHeader();
          if (chunk.length < 0) {
            return;
          }
          switch (chunk.type) {
            case "IDAT":
              return {
                ext: "png",
                mime: "image/png"
              };
            case "acTL":
              return {
                ext: "apng",
                mime: "image/apng"
              };
            default:
              await tokenizer.ignore(chunk.length + 4);
          }
        } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) {
        return {
          ext: "arrow",
          mime: "application/vnd.apache.arrow.file"
        };
      }
      if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) {
        return {
          ext: "glb",
          mime: "model/gltf-binary"
        };
      }
      if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 })) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
        return {
          ext: "orf",
          mime: "image/x-olympus-orf"
        };
      }
      if (this.checkString("gimp xcf ")) {
        return {
          ext: "xcf",
          mime: "image/x-xcf"
        };
      }
      if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
        const brandMajor = new StringType(4, "latin1").get(this.buffer, 8).replace("\0", " ").trim();
        switch (brandMajor) {
          case "avif":
          case "avis":
            return { ext: "avif", mime: "image/avif" };
          case "mif1":
            return { ext: "heic", mime: "image/heif" };
          case "msf1":
            return { ext: "heic", mime: "image/heif-sequence" };
          case "heic":
          case "heix":
            return { ext: "heic", mime: "image/heic" };
          case "hevc":
          case "hevx":
            return { ext: "heic", mime: "image/heic-sequence" };
          case "qt":
            return { ext: "mov", mime: "video/quicktime" };
          case "M4V":
          case "M4VH":
          case "M4VP":
            return { ext: "m4v", mime: "video/x-m4v" };
          case "M4P":
            return { ext: "m4p", mime: "video/mp4" };
          case "M4B":
            return { ext: "m4b", mime: "audio/mp4" };
          case "M4A":
            return { ext: "m4a", mime: "audio/x-m4a" };
          case "F4V":
            return { ext: "f4v", mime: "video/mp4" };
          case "F4P":
            return { ext: "f4p", mime: "video/mp4" };
          case "F4A":
            return { ext: "f4a", mime: "audio/mp4" };
          case "F4B":
            return { ext: "f4b", mime: "audio/mp4" };
          case "crx":
            return { ext: "cr3", mime: "image/x-canon-cr3" };
          default:
            if (brandMajor.startsWith("3g")) {
              if (brandMajor.startsWith("3g2")) {
                return { ext: "3g2", mime: "video/3gpp2" };
              }
              return { ext: "3gp", mime: "video/3gpp" };
            }
            return { ext: "mp4", mime: "video/mp4" };
        }
      }
      if (this.check([82, 73, 70, 70])) {
        if (this.checkString("WEBP", { offset: 8 })) {
          return {
            ext: "webp",
            mime: "image/webp"
          };
        }
        if (this.check([65, 86, 73], { offset: 8 })) {
          return {
            ext: "avi",
            mime: "video/vnd.avi"
          };
        }
        if (this.check([87, 65, 86, 69], { offset: 8 })) {
          return {
            ext: "wav",
            mime: "audio/wav"
          };
        }
        if (this.check([81, 76, 67, 77], { offset: 8 })) {
          return {
            ext: "qcp",
            mime: "audio/qcelp"
          };
        }
      }
      if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
        return {
          ext: "rw2",
          mime: "image/x-panasonic-rw2"
        };
      }
      if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        async function readHeader() {
          const guid = new Uint8Array(16);
          await tokenizer.readBuffer(guid);
          return {
            id: guid,
            size: Number(await tokenizer.readToken(UINT64_LE))
          };
        }
        __name(readHeader, "readHeader");
        await tokenizer.ignore(30);
        while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
          const header = await readHeader();
          let payload = header.size - 24;
          if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
            const typeId = new Uint8Array(16);
            payload -= await tokenizer.readBuffer(typeId);
            if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
              return {
                ext: "asf",
                mime: "audio/x-ms-asf"
              };
            }
            if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
              return {
                ext: "asf",
                mime: "video/x-ms-asf"
              };
            }
            break;
          }
          await tokenizer.ignore(payload);
        }
        return {
          ext: "asf",
          mime: "application/vnd.ms-asf"
        };
      }
      if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
        return {
          ext: "ktx",
          mime: "image/ktx"
        };
      }
      if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 })) {
        return {
          ext: "mie",
          mime: "application/x-mie"
        };
      }
      if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
        return {
          ext: "shp",
          mime: "application/x-esri-shape"
        };
      }
      if (this.check([255, 79, 255, 81])) {
        return {
          ext: "j2c",
          mime: "image/j2c"
        };
      }
      if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
        await tokenizer.ignore(20);
        const type = await tokenizer.readToken(new StringType(4, "ascii"));
        switch (type) {
          case "jp2 ":
            return {
              ext: "jp2",
              mime: "image/jp2"
            };
          case "jpx ":
            return {
              ext: "jpx",
              mime: "image/jpx"
            };
          case "jpm ":
            return {
              ext: "jpm",
              mime: "image/jpm"
            };
          case "mjp2":
            return {
              ext: "mj2",
              mime: "image/mj2"
            };
          default:
            return;
        }
      }
      if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
        return {
          ext: "jxl",
          mime: "image/jxl"
        };
      }
      if (this.check([254, 255])) {
        if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], { offset: 2 })) {
          return {
            ext: "xml",
            mime: "application/xml"
          };
        }
        return void 0;
      }
      if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) {
        return {
          ext: "cfb",
          mime: "application/x-cfb"
        };
      }
      await tokenizer.peekBuffer(this.buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
      if (this.check([97, 99, 115, 112], { offset: 36 })) {
        return {
          ext: "icc",
          mime: "application/vnd.iccprofile"
        };
      }
      if (this.checkString("**ACE", { offset: 7 }) && this.checkString("**", { offset: 12 })) {
        return {
          ext: "ace",
          mime: "application/x-ace-compressed"
        };
      }
      if (this.checkString("BEGIN:")) {
        if (this.checkString("VCARD", { offset: 6 })) {
          return {
            ext: "vcf",
            mime: "text/vcard"
          };
        }
        if (this.checkString("VCALENDAR", { offset: 6 })) {
          return {
            ext: "ics",
            mime: "text/calendar"
          };
        }
      }
      if (this.checkString("FUJIFILMCCD-RAW")) {
        return {
          ext: "raf",
          mime: "image/x-fujifilm-raf"
        };
      }
      if (this.checkString("Extended Module:")) {
        return {
          ext: "xm",
          mime: "audio/x-xm"
        };
      }
      if (this.checkString("Creative Voice File")) {
        return {
          ext: "voc",
          mime: "audio/x-voc"
        };
      }
      if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
        const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);
        if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
          try {
            const header = new TextDecoder().decode(this.buffer.subarray(16, jsonSize + 16));
            const json = JSON.parse(header);
            if (json.files) {
              return {
                ext: "asar",
                mime: "application/x-asar"
              };
            }
          } catch (e) {
          }
        }
      }
      if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      }
      if (this.checkString("SCRM", { offset: 44 })) {
        return {
          ext: "s3m",
          mime: "audio/x-s3m"
        };
      }
      if (this.check([71]) && this.check([71], { offset: 188 })) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
        return {
          ext: "mobi",
          mime: "application/x-mobipocket-ebook"
        };
      }
      if (this.check([68, 73, 67, 77], { offset: 128 })) {
        return {
          ext: "dcm",
          mime: "application/dicom"
        };
      }
      if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
        return {
          ext: "lnk",
          mime: "application/x.ms.shortcut"
          // Invented by us
        };
      }
      if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
        return {
          ext: "alias",
          mime: "application/x.apple.alias"
          // Invented by us
        };
      }
      if (this.checkString("Kaydara FBX Binary  \0")) {
        return {
          ext: "fbx",
          mime: "application/x.autodesk.fbx"
          // Invented by us
        };
      }
      if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 }))) {
        return {
          ext: "eot",
          mime: "application/vnd.ms-fontobject"
        };
      }
      if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
        return {
          ext: "indd",
          mime: "application/x-indesign"
        };
      }
      await tokenizer.peekBuffer(this.buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
      if (this.checkString("ustar", { offset: 257 }) && (this.checkString("\0", { offset: 262 }) || this.checkString(" ", { offset: 262 })) || this.check([0, 0, 0, 0, 0, 0], { offset: 257 }) && tarHeaderChecksumMatches(this.buffer)) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (this.check([255, 254])) {
        if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], { offset: 2 })) {
          return {
            ext: "xml",
            mime: "application/xml"
          };
        }
        if (this.check([255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0], { offset: 2 })) {
          return {
            ext: "skp",
            mime: "application/vnd.sketchup.skp"
          };
        }
        return void 0;
      }
      if (this.checkString("-----BEGIN PGP MESSAGE-----")) {
        return {
          ext: "pgp",
          mime: "application/pgp-encrypted"
        };
      }
    }, "detectConfident"));
    // Detections with limited supporting data, resulting in a higher likelihood of false positives
    __publicField(this, "detectImprecise", /* @__PURE__ */ __name(async (tokenizer) => {
      this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
      await tokenizer.peekBuffer(this.buffer, { length: Math.min(8, tokenizer.fileInfo.size), mayBeLess: true });
      if (this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      if (this.check([0, 1, 0, 0, 0])) {
        return {
          ext: "ttf",
          mime: "font/ttf"
        };
      }
      if (this.check([0, 0, 1, 0])) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (this.check([0, 0, 2, 0])) {
        return {
          ext: "cur",
          mime: "image/x-icon"
        };
      }
      await tokenizer.peekBuffer(this.buffer, { length: Math.min(2 + this.options.mpegOffsetTolerance, tokenizer.fileInfo.size), mayBeLess: true });
      if (this.buffer.length >= 2 + this.options.mpegOffsetTolerance) {
        for (let depth = 0; depth <= this.options.mpegOffsetTolerance; ++depth) {
          const type = this.scanMpeg(depth);
          if (type) {
            return type;
          }
        }
      }
    }, "detectImprecise"));
    var _a9;
    this.options = {
      mpegOffsetTolerance: 0,
      ...options
    };
    this.detectors = [
      ...(_a9 = options == null ? void 0 : options.customDetectors) != null ? _a9 : [],
      { id: "core", detect: this.detectConfident },
      { id: "core.imprecise", detect: this.detectImprecise }
    ];
    this.tokenizerOptions = {
      abortSignal: options == null ? void 0 : options.signal
    };
  }
  async fromTokenizer(tokenizer) {
    const initialPosition = tokenizer.position;
    for (const detector of this.detectors) {
      const fileType = await detector.detect(tokenizer);
      if (fileType) {
        return fileType;
      }
      if (initialPosition !== tokenizer.position) {
        return void 0;
      }
    }
  }
  async fromBuffer(input) {
    if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
      throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``);
    }
    const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
    if (!((buffer == null ? void 0 : buffer.length) > 1)) {
      return;
    }
    return this.fromTokenizer(fromBuffer(buffer, this.tokenizerOptions));
  }
  async fromBlob(blob) {
    return this.fromStream(blob.stream());
  }
  async fromStream(stream) {
    const tokenizer = await fromWebStream(stream, this.tokenizerOptions);
    try {
      return await this.fromTokenizer(tokenizer);
    } finally {
      await tokenizer.close();
    }
  }
  async toDetectionStream(stream, options) {
    const { sampleSize = reasonableDetectionSizeInBytes } = options;
    let detectedFileType;
    let firstChunk;
    const reader = stream.getReader({ mode: "byob" });
    try {
      const { value: chunk, done } = await reader.read(new Uint8Array(sampleSize));
      firstChunk = chunk;
      if (!done && chunk) {
        try {
          detectedFileType = await this.fromBuffer(chunk.subarray(0, sampleSize));
        } catch (error) {
          if (!(error instanceof EndOfStreamError)) {
            throw error;
          }
          detectedFileType = void 0;
        }
      }
      firstChunk = chunk;
    } finally {
      reader.releaseLock();
    }
    const transformStream = new TransformStream({
      async start(controller) {
        controller.enqueue(firstChunk);
      },
      transform(chunk, controller) {
        controller.enqueue(chunk);
      }
    });
    const newStream = stream.pipeThrough(transformStream);
    newStream.fileType = detectedFileType;
    return newStream;
  }
  check(header, options) {
    return _check(this.buffer, header, options);
  }
  checkString(header, options) {
    return this.check(stringToBytes(header), options);
  }
  async readTiffTag(bigEndian) {
    const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
    this.tokenizer.ignore(10);
    switch (tagId) {
      case 50341:
        return {
          ext: "arw",
          mime: "image/x-sony-arw"
        };
      case 50706:
        return {
          ext: "dng",
          mime: "image/x-adobe-dng"
        };
      default:
    }
  }
  async readTiffIFD(bigEndian) {
    const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
    for (let n = 0; n < numberOfTags; ++n) {
      const fileType = await this.readTiffTag(bigEndian);
      if (fileType) {
        return fileType;
      }
    }
  }
  async readTiffHeader(bigEndian) {
    const version = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
    const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);
    if (version === 42) {
      if (ifdOffset >= 6) {
        if (this.checkString("CR", { offset: 8 })) {
          return {
            ext: "cr2",
            mime: "image/x-canon-cr2"
          };
        }
        if (ifdOffset >= 8) {
          const someId1 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 8);
          const someId2 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 10);
          if (someId1 === 28 && someId2 === 254 || someId1 === 31 && someId2 === 11) {
            return {
              ext: "nef",
              mime: "image/x-nikon-nef"
            };
          }
        }
      }
      await this.tokenizer.ignore(ifdOffset);
      const fileType = await this.readTiffIFD(bigEndian);
      return fileType != null ? fileType : {
        ext: "tif",
        mime: "image/tiff"
      };
    }
    if (version === 43) {
      return {
        ext: "tif",
        mime: "image/tiff"
      };
    }
  }
  /**
  	Scan check MPEG 1 or 2 Layer 3 header, or 'layer 0' for ADTS (MPEG sync-word 0xFFE).
  
  	@param offset - Offset to scan for sync-preamble.
  	@returns {{ext: string, mime: string}}
  	*/
  scanMpeg(offset) {
    if (this.check([255, 224], { offset, mask: [255, 224] })) {
      if (this.check([16], { offset: offset + 1, mask: [22] })) {
        if (this.check([8], { offset: offset + 1, mask: [8] })) {
          return {
            ext: "aac",
            mime: "audio/aac"
          };
        }
        return {
          ext: "aac",
          mime: "audio/aac"
        };
      }
      if (this.check([2], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      if (this.check([4], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp2",
          mime: "audio/mpeg"
        };
      }
      if (this.check([6], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp1",
          mime: "audio/mpeg"
        };
      }
    }
  }
};
__name(_FileTypeParser, "FileTypeParser");
var FileTypeParser = _FileTypeParser;
var supportedExtensions = new Set(extensions);
var supportedMimeTypes = new Set(mimeTypes);

// src/services/collections/CollectionHandler.ts
var import_js_md5 = __toESM(require_md5());
var import_obsidian9 = require("obsidian");
function collectionHandlerReadyEvent(id2) {
  return `collections:${id2}:ready`;
}
__name(collectionHandlerReadyEvent, "collectionHandlerReadyEvent");
var ETAGS_TABLE = "[collection_id+path],etag";
var YMAP_KEY = "s.g:collection:v0";
var PENDING_KEY = "s.g:pending:v0";
var TRASH_KEY = "s.g:trash:v0";
var FILES_KEY = "s.g:files:v0";
var ADDITIONS_BUFFER_MS = 2e3;
var DELETIONS_BUFFER_MS = 400;
var MOUNT_RENAMES_BUFFER_MS = 2e3;
var COLLECTION_PRESENCE_DEBOUNCE_MS = 3e3;
var EXTERNAL_EDIT_TIMEOUT_MS = 5e3;
var BINARY_FILE_SIZE_LIMIT_BYTES = 200 * (1 << 20);
var MULTI_PART_THRESHOLD_BYTES = 15 * (1 << 20);
var MULTI_PART_CHUNK_SIZE_BYTES = 15 * (1 << 20);
var DEFAULT_FILE_OP_DELAY_MS = 200;
var MAX_FILE_OP_DELAY_MS = 1e3 * 60 * 30;
function stringIDFor(mapValue) {
  return typeof mapValue == "string" ? mapValue : null;
}
__name(stringIDFor, "stringIDFor");
var _CollectionHandler = class _CollectionHandler {
  constructor(plugin, id2, path) {
    this.plugin = plugin;
    this.id = id2;
    this.path = path;
    this.loaded = false;
    this.pendingAdditions = [];
    this.deletions = /* @__PURE__ */ new Set();
    this.deletionTimeoutId = -1;
    this.closing = false;
    this.presenceListener = null;
    this.lastPresenceMeta = null;
    this.previousMountPaths = [];
    this.previousMountPathTouches = /* @__PURE__ */ new Map();
    this.fileOpTimeout = null;
    this.fileOpDelay = DEFAULT_FILE_OP_DELAY_MS;
    /**
     * Set of paths that are being modified by the plugin itself in the background
     * and thus should not be counted as being externally modified.
     */
    this.controlledModifies = /* @__PURE__ */ new Set();
    this.log = (0, import_debug11.default)(`screen.garden:collection:${id2}`);
    this.log("initalizing, path: %s", path);
    this.plugin.externalProviders.ignorePath(this.path);
    this.onload();
    this.observer = this.observer.bind(this);
    this.filesObserver = this.filesObserver.bind(this);
    this.fileOpQueue = new FileOperationQueue(
      this.id,
      new IDBQueueStorage(this.plugin.db.fileOps)
    );
    this.onPresenceSync = throttle_default2(
      this.handlePresenceSync.bind(this),
      COLLECTION_PRESENCE_DEBOUNCE_MS,
      { leading: true, trailing: true }
    );
    this.addPendingAdditions = throttle_default2(
      this._addPendingAdditions.bind(this),
      ADDITIONS_BUFFER_MS
    );
  }
  async onload() {
    const lifecycle = {
      onJoin: /* @__PURE__ */ __name((_dc, joinReply) => {
        if (joinReply && "pool_size" in joinReply) {
          this.plugin.liveDocuments.poolSize = joinReply["pool_size"];
        }
      }, "onJoin"),
      afterSync: /* @__PURE__ */ __name(async (h) => {
        try {
          const cs = await this.plugin.db.collectionSettings.get(this.id);
          if (!cs) return;
          const noteIDs = await h.push("catchup-collection", {
            since: cs.last_sync.toISOString()
          });
          const updates = noteIDs.map((id2) => ({
            key: id2,
            changes: { needs_catchup: 1 /* Yes */ }
          }));
          await this.plugin.db.liveDocuments.bulkUpdate(updates);
          const toCatchup = await this.plugin.db.liveDocuments.where("needs_catchup").equals(1 /* Yes */).toArray();
          this.enqueueCatchupHandlers(toCatchup);
          this.plugin.db.collectionSettings.update(this.id, {
            last_sync: /* @__PURE__ */ new Date()
          });
          this.migrateLiveDocuments();
        } catch (e) {
          this.log("catchup failed");
        }
      }, "afterSync")
    };
    this.doc = await this.plugin.docs.getOrCreateAndLoad(
      this.id,
      {
        kind: "collection"
      },
      lifecycle
    );
    this.pushPresence = debounce_default(
      this.doc.channel.pushPresence,
      COLLECTION_PRESENCE_DEBOUNCE_MS
    );
    this.log("loaded doc %s", this.doc.id);
    this.ymap = this.doc.ydoc.getMap(YMAP_KEY);
    this.ymap.observe(this.observer);
    this.files = this.doc.ydoc.getMap(FILES_KEY);
    this.files.observe(this.filesObserver);
    this.pending = this.doc.ydoc.getMap(PENDING_KEY);
    this.trash = this.doc.ydoc.getMap(TRASH_KEY);
    this.plugin.collections.reportSize(this.id, this.size);
    for (const key of this.ymap.keys()) {
      const id2 = this.ymap.get(key);
      const path = this.addPathPrefix(key);
      if (id2 && this.plugin.app.vault.getAbstractFileByPath(path) == null) {
        await this.ensurePath(path);
        try {
          await this.plugin.app.vault.create(path, "");
        } catch (error) {
          this.log(`error creating file at path "${path}"`, error);
        }
        await this.plugin.liveDocuments.create([
          {
            path,
            id: id2,
            collectionId: this.id,
            priority: "background"
          }
        ]);
      }
    }
    const orphanedPendingDocuments = /* @__PURE__ */ new Map();
    for (const liveDocument of await this.plugin.db.pendingLiveDocuments.where({ collection_id: this.id }).toArray()) {
      orphanedPendingDocuments.set(liveDocument.id, liveDocument);
    }
    for (const id2 of this.pending.keys()) {
      const path = this.pending.get(id2);
      if (path) {
        orphanedPendingDocuments.delete(id2);
        const prefixedPath = this.addPathPrefix(path);
        if (this.plugin.app.vault.getAbstractFileByPath(prefixedPath)) {
          await this.plugin.liveDocuments.create([
            {
              path: prefixedPath,
              id: id2,
              collectionId: this.id,
              priority: "background"
            }
          ]);
        }
      }
    }
    this.plugin.db.pendingLiveDocuments.bulkDelete([
      ...orphanedPendingDocuments.keys()
    ]);
    for (const path of this.files.keys()) {
      const prefixedPath = this.addPathPrefix(path);
      if (!this.plugin.app.vault.getAbstractFileByPath(prefixedPath)) {
        this.download(path);
      }
    }
    this.plugin.registerEvent(
      this.plugin.app.vault.on("create", this.handleVaultCreate, this)
    );
    this.plugin.registerEvent(
      this.plugin.app.vault.on("rename", this.handleVaultRename, this)
    );
    this.plugin.registerEvent(
      this.plugin.app.vault.on("delete", this.handleVaultDelete, this)
    );
    this.plugin.registerEvent(
      this.plugin.app.vault.on("modify", this.handleVaultModify, this)
    );
    this.plugin.registerEvent(
      this.plugin.app.workspace.on(
        "active-leaf-change",
        this.activeLeafChange,
        this
      )
    );
    this.presenceListener = this.plugin.docs.on(
      `presence:${this.id}`,
      this.onPresenceSync
    );
    this.loaded = true;
    this.plugin.collections.trigger(collectionHandlerReadyEvent(this.id));
    this.processOldestOperation();
    this.plugin.register(() => {
      if (this.fileOpTimeout) {
        clearTimeout(this.fileOpTimeout);
      }
      this.fileOpTimeout = null;
    });
  }
  close() {
    var _a9;
    if (this.closing) return;
    this.closing = true;
    this.log(`closing handler at ${this.path}`);
    (_a9 = this.pushPresence) == null ? void 0 : _a9.cancel();
    this.plugin.app.vault.off("create", this.handleVaultCreate);
    this.plugin.app.vault.off("rename", this.handleVaultRename);
    this.plugin.app.vault.off("delete", this.handleVaultDelete);
    this.plugin.app.workspace.off("active-leaf-change", this.activeLeafChange);
    this.addPendingAdditions.flush();
    this.onPresenceSync.cancel();
    if (this.presenceListener) this.plugin.docs.offref(this.presenceListener);
    this.ymap.unobserve(this.observer);
    this.plugin.docs.unload(this.doc);
    window.clearTimeout(this.deletionTimeoutId);
  }
  get size() {
    return this.ymap.size + this.files.size;
  }
  async requireHandlerForFile(file) {
    if (!isLiveDocument(file)) {
      return null;
    }
    if (!this.loaded) {
      const ref = await new Promise(
        (resolve) => this.plugin.collections.on(
          collectionHandlerReadyEvent(this.id),
          resolve
        )
      );
      this.plugin.collections.offref(ref);
    }
    const membership = await this.membershipByPath(file);
    this.log("membership", membership);
    if (membership == null ? void 0 : membership.liveDocumentId) {
      return this.plugin.liveDocuments.require(
        membership.liveDocumentId,
        this.id,
        file.path
      );
    }
    return null;
  }
  enqueueCatchupHandlers(liveDocuments) {
    if (liveDocuments.length === 0) return;
    this.log(
      "enqueueing catchup handlers for %d live documents",
      liveDocuments.length
    );
    liveDocuments.forEach((liveDocument) => {
      this.plugin.liveDocuments.catchup(
        liveDocument.id,
        liveDocument.path,
        this.id
      );
    });
  }
  bucketEventChanges(evt, filter2 = () => true) {
    const changes = [...evt.changes.keys.entries()];
    const created = [];
    const moved = [];
    const updated = [];
    const deleted = [];
    let change;
    while (change = changes.pop()) {
      const [path, { action, oldValue }] = change;
      if (!filter2(change)) continue;
      if (action === "update") {
        updated.push(change);
        continue;
      }
      const pathValue = stringIDFor(oldValue != null ? oldValue : evt.target.get(path));
      if (!pathValue) continue;
      const matchingMoveAction = action === "add" ? "delete" : "add";
      const matchIdx = changes.findIndex(
        ([mp, { action: ma, oldValue: mv }]) => {
          return ma === matchingMoveAction && stringIDFor(mv != null ? mv : evt.target.get(mp)) === pathValue;
        }
      );
      if (matchIdx >= 0) {
        const [match] = changes.splice(matchIdx, 1);
        moved.push({
          from: action === "delete" ? change : match,
          to: action === "delete" ? match : change
        });
        continue;
      }
      if (action === "add") {
        created.push(change);
      } else if (action === "delete") {
        deleted.push(change);
      }
    }
    return {
      created,
      moved,
      updated,
      deleted
    };
  }
  async observer(evt, txn) {
    this.plugin.collections.reportSize(this.id, this.size);
    if (txn.origin === this) return;
    const { created, moved, deleted } = this.bucketEventChanges(evt);
    this.log(
      "%d additions, %d deletes, and %d renames",
      created.length,
      deleted.length,
      moved.length
    );
    for (const {
      from: [fromPath],
      to: [toPath]
    } of moved) {
      this.log('rename "%s" -> "%s"', fromPath, toPath);
      const liveDocumentId = this.ymap.get(toPath);
      if (!liveDocumentId) continue;
      const oldPath = this.addPathPrefix(fromPath);
      const curr = this.plugin.app.vault.getAbstractFileByPath(oldPath);
      const dest = this.addPathPrefix(toPath);
      await this.plugin.db.liveDocuments.update(liveDocumentId, {
        path: dest,
        title: getTitle(toPath)
      });
      if (curr) {
        await this.ensurePath(dest);
        await this.plugin.app.vault.rename(curr, dest);
      }
    }
    for (const [path] of created) {
      const id2 = this.ymap.get(path);
      if (!id2) continue;
      const dest = this.addPathPrefix(path);
      await this.plugin.liveDocuments.create([
        {
          path: dest,
          id: id2,
          collectionId: this.id,
          priority: "background"
        }
      ]);
      await this.ensurePath(dest);
      if (!this.plugin.app.vault.getAbstractFileByPath(dest)) {
        try {
          await this.plugin.app.vault.create(dest, "");
        } catch (e) {
          const alreadyExists = e instanceof Error && e.message === "File already exists.";
          if (!alreadyExists) {
            this.log(`Error creating file at ${dest}: ${e}`);
          }
        }
      }
    }
    for (const [path, { oldValue: liveDocumentId }] of deleted) {
      const file = this.plugin.app.vault.getAbstractFileByPath(
        this.addPathPrefix(path)
      );
      if (file) this.plugin.app.vault.delete(file);
      await this.plugin.liveDocuments.delete(liveDocumentId);
    }
  }
  async handleVaultCreate(file) {
    this.log("handleVaultCreate", file);
    if (!this.addableFile(file)) return;
    if (this.controlledModifies.has(file.path)) return;
    if (!isLiveDocument(file)) {
      return this.handleFileInCollectionCreated(file);
    }
    this.pendingAdditions.push(file);
    this.addPendingAdditions();
  }
  _addPendingAdditions() {
    const toAdd = [...this.pendingAdditions];
    this.pendingAdditions = [];
    this.addLiveDocuments(toAdd);
  }
  /**
   * Adds files in bulk to the collection.
   * Files corresponding to YJS-backed documents are added as documents.
   * All other files are added as last-write-wins files.
   */
  async addFiles(files) {
    const documentFiles = [];
    for (const file of files) {
      if (isLiveDocument(file)) {
        documentFiles.push(file);
      } else {
        this.fileOpQueue.create(this.removePathPrefix(file.path));
      }
    }
    if (documentFiles.length > 0) {
      this.addLiveDocuments(documentFiles);
    }
  }
  /**
   * addLiveDocuments adds live document(s) to the collection,
   * ensuring that they don't enter the base ymap until
   * they've been created on the server by storing them in a
   * dedicated pending ymap.
   * @param files The files to add to the collection.
   */
  async addLiveDocuments(files) {
    const toAdd = files.filter((f) => this.addableFile(f) && isLiveDocument(f)).map((f) => ({
      id: v4_default(),
      path: f.path,
      collection_id: this.id
    }));
    await this.plugin.db.pendingLiveDocuments.bulkPut(toAdd);
    this.doc.ydoc.transact(() => {
      toAdd.forEach(({ id: id2, path }) => {
        this.pending.set(id2, this.removePathPrefix(path));
      });
    }, this);
    this.plugin.liveDocuments.create(
      toAdd.map(({ id: id2, path, collection_id }) => ({
        id: id2,
        path,
        collectionId: collection_id,
        priority: "background"
      }))
    );
  }
  async membershipByPath(pathOrFile) {
    if (!this.inCollection(pathOrFile)) return null;
    const prefixedPath = getPath(pathOrFile);
    const keyPath = this.removePathPrefix(prefixedPath);
    const r = { keyPath, prefixedPath };
    const memberId = this.ymap.get(keyPath);
    if (memberId) return { ...r, liveDocumentId: memberId, state: "member" };
    for (const [id2, pendingPath] of this.pending.entries()) {
      if (pendingPath === keyPath) {
        const pendingLiveDocument = await this.plugin.db.pendingLiveDocuments.get(id2);
        if ((pendingLiveDocument == null ? void 0 : pendingLiveDocument.path) === prefixedPath) {
          return { ...r, liveDocumentId: id2, state: "pending" };
        }
      }
    }
    return null;
  }
  membershipById(id2) {
    for (const [memberId, keyPath] of this.ymap.entries()) {
      if (memberId === id2) {
        return {
          liveDocumentId: id2,
          keyPath,
          prefixedPath: this.addPathPrefix(keyPath),
          state: "member"
        };
      }
    }
    const pendingPath = this.pending.get(id2);
    if (pendingPath) {
      return {
        liveDocumentId: id2,
        keyPath: pendingPath,
        prefixedPath: this.addPathPrefix(pendingPath),
        state: "pending"
      };
    }
    return null;
  }
  // A synchronous getter for member-only live documents.
  liveDocumentIdForMemberPath(pathOrFile) {
    var _a9;
    const path = this.removePathPrefix(getPath(pathOrFile));
    return (_a9 = this.ymap.get(path)) != null ? _a9 : null;
  }
  async handleVaultRename(file, oldPath) {
    if (file instanceof import_obsidian9.TFolder && oldPath === this.path) {
      this.log("renaming mount folder!");
      this.previousMountPaths.push(this.path);
      this.path = file.path;
      this.plugin.externalProviders.ignorePath(this.path);
      this.plugin.db.collectionSettings.update(this.id, {
        mount_path: this.path
      });
      return;
    }
    if (!this.inCollection(oldPath) && this.inCollection(file))
      return this.handleVaultCreate(file);
    if (this.inCollection(oldPath) && !this.inCollection(file))
      return this.handleVaultDelete({ path: oldPath });
    if (!this.inCollection(file) && !this.inCollection(oldPath)) return;
    if (!isLiveDocument(file)) {
      return this.handleFileInCollectionRenamed(file, oldPath);
    }
    const fromPath = this.removePathPrefix(oldPath);
    const toPath = this.removePathPrefix(file.path);
    const existingLiveDocumentId = this.ymap.get(toPath);
    if (existingLiveDocumentId) {
      this.log("upstream rename of %s", toPath);
      await this.plugin.db.liveDocuments.update(existingLiveDocumentId, {
        path: file.path,
        title: getTitle(file.path)
      });
      return;
    }
    this.log("rename %s (in %s)", fromPath, this.path);
    const membership = await this.membershipByPath(oldPath);
    if (!membership) return;
    const { liveDocumentId } = membership;
    if (membership.state === "pending") {
      await this.plugin.db.pendingLiveDocuments.update(liveDocumentId, {
        path: file.path
      });
    }
    await this.plugin.db.liveDocuments.update(liveDocumentId, {
      path: file.path,
      title: getTitle(file.path)
    });
    if (membership.state === "pending") {
      this.doc.ydoc.transact(() => {
        this.pending.set(liveDocumentId, toPath);
      }, this);
    } else {
      this.doc.ydoc.transact(() => {
        this.ymap.set(toPath, liveDocumentId);
        this.ymap.delete(fromPath);
      }, this);
    }
    this.log(
      'moved from "%s" to "%s"',
      this.removePathPrefix(oldPath),
      this.removePathPrefix(file.path)
    );
  }
  async handleVaultDelete(file) {
    if (!this.inCollection(file)) return;
    if (this.deletionTimeoutId > 0) {
      window.clearTimeout(this.deletionTimeoutId);
    }
    this.deletions.add(file.path);
    this.deletionTimeoutId = window.setTimeout(
      this.processDeletions.bind(this),
      DELETIONS_BUFFER_MS
    );
  }
  async processDeletions() {
    this.log("processing %d deletions", this.deletions.size);
    const deletedCollection = this.deletions.has(this.path);
    this.deletions.delete(this.path);
    const grouped = groupBy_default([...this.deletions.values()], (path) => {
      if (isLiveDocument(path)) return "document";
      return "file";
    });
    const documentPaths = grouped["document"] || [];
    const filePaths = grouped["file"] || [];
    this.deletionTimeoutId = -1;
    this.deletions.clear();
    if (deletedCollection) {
      this.close();
      await this.plugin.collections.unmount(this.id);
      return;
    }
    const deletedLiveDocumentIDs = [];
    const deletedMemberPaths = [];
    const deletedPendingIds = [];
    for (const path of filePaths) {
      this.handleFileInCollectionDeleted(path);
    }
    for (const path of documentPaths) {
      const membership = await this.membershipByPath(path);
      if ((membership == null ? void 0 : membership.state) === "member") {
        deletedMemberPaths.push(membership.keyPath);
        deletedLiveDocumentIDs.push(membership.liveDocumentId);
      } else if ((membership == null ? void 0 : membership.state) === "pending") {
        const localDocument = await this.plugin.db.liveDocuments.get(
          membership.liveDocumentId
        );
        if ((localDocument == null ? void 0 : localDocument.path) === membership.keyPath) {
          deletedPendingIds.push(membership.liveDocumentId);
        }
      }
      if (membership) {
        await this.plugin.liveDocuments.delete(membership.liveDocumentId);
      }
    }
    this.doc.ydoc.transact(() => {
      for (const keyPath of deletedMemberPaths) {
        this.ymap.delete(keyPath);
      }
      for (const pendingId of deletedPendingIds) {
        this.pending.delete(pendingId);
      }
      deletedLiveDocumentIDs.forEach(
        (id2) => this.trash.set(id2, (/* @__PURE__ */ new Date()).toISOString())
      );
    }, this);
  }
  async controlModify(path, fn) {
    try {
      this.controlledModifies.add(path);
      return await fn();
    } finally {
      this.controlledModifies.delete(path);
    }
  }
  handleVaultModify(file) {
    const path = getPath(file);
    if (!(file instanceof import_obsidian9.TFile)) return;
    if (!this.inCollection(file)) return;
    if (this.controlledModifies.has(path)) return;
    if (!isLiveDocument(file)) {
      return this.handleFileInCollectionModified(file);
    }
    const keyPath = this.removePathPrefix(path);
    const liveDocumentId = this.ymap.get(keyPath);
    if (liveDocumentId) {
      const handler = this.plugin.liveDocuments.getHandler(liveDocumentId);
      if (handler == null ? void 0 : handler.yDocAcquired) return;
    }
    this.handlePossibleModify(file);
  }
  async handlePossibleModify(file) {
    const path = getPath(file);
    const membership = await this.membershipByPath(path);
    if (!membership) return;
    const testHandler = this.plugin.liveDocuments.getHandler(
      membership.liveDocumentId
    );
    if (testHandler == null ? void 0 : testHandler.yDocAcquired) return;
    let handler = this.plugin.liveDocuments.require(
      membership.liveDocumentId,
      this.id,
      path
    );
    if (!handler) {
      const awaitingId = membership.liveDocumentId;
      handler = await Promise.race([
        new Promise(
          (resolve) => setTimeout(() => resolve(null), EXTERNAL_EDIT_TIMEOUT_MS)
        ),
        new Promise((resolve) => {
          const sub = this.plugin.liveDocuments.handlerChanges.subscribe({
            next: /* @__PURE__ */ __name(async ({
              id: liveDocumentID,
              path: _path,
              deleted
            }) => {
              if (liveDocumentID !== awaitingId || deleted) return;
              const handler2 = this.plugin.liveDocuments.require(
                liveDocumentID,
                this.id,
                path
              );
              sub.unsubscribe();
              resolve(handler2);
            }, "next")
          });
        })
      ]);
    }
    if (!handler) {
      this.log(`Could not load a handler for ${path} to handle modifiy`);
      return;
    }
    handler.acceptExternalWrite(file);
  }
  activeLeafChange(leaf) {
    var _a9, _b2;
    if (!this.pushPresence) return;
    const documents = [];
    this.plugin.app.workspace.getLeavesOfType("markdown").forEach((innerLeaf) => {
      const state = innerLeaf.view.getState();
      if (isPathOrFile(state.file) && this.inCollection(state.file)) {
        const id2 = this.liveDocumentIdForMemberPath(state.file);
        if (!id2) return;
        documents.push({
          id: id2,
          active: leaf === innerLeaf
        });
      }
    });
    const meta = {
      user_name: (_b2 = (_a9 = this.plugin.account.get()) == null ? void 0 : _a9.name) != null ? _b2 : null,
      notes: documents
    };
    if (!isEqual_default(meta, this.lastPresenceMeta)) {
      this.pushPresence(meta);
      this.lastPresenceMeta = meta;
    }
  }
  presenceMetas() {
    return this.doc.channel.listPresences(
      "user_id"
    );
  }
  handlePresenceSync(id2) {
    var _a9, _b2;
    if (id2 !== this.id) return;
    const me = this.plugin.socket.origin;
    const activeNoteIDs = this.presenceMetas().filter((p) => p.origin !== me).flatMap((p) => {
      var _a10, _b3;
      return (_b3 = (_a10 = p.notes) == null ? void 0 : _a10.filter((n) => n.active).map((n) => n.id)) != null ? _b3 : [];
    });
    for (const id3 of activeNoteIDs) {
      if ((_a9 = this.activePresenceNoteIDs) == null ? void 0 : _a9.includes(id3)) continue;
      this.plugin.liveDocuments.maybeRequireForID(id3, this.id);
    }
    for (const id3 of (_b2 = this.activePresenceNoteIDs) != null ? _b2 : []) {
      if (activeNoteIDs.includes(id3)) continue;
      this.plugin.liveDocuments.downgrade(id3, "concurrent");
    }
    this.activePresenceNoteIDs = activeNoteIDs;
  }
  addableFile(file) {
    return this.inCollection(file) && file instanceof import_obsidian9.TFile && !this.liveDocumentIdForMemberPath(file);
  }
  // This (and removePathPrefix) is special-cased to handle when the collection mount path
  // has been renamed. In that case, both the current and previous mount paths are considered.
  // The current mount path is given priority.
  // If this function references a previous mount path that path is rescheduled for forgetting.
  inCollection(pathOrFile) {
    for (const mountPath of [this.path, ...this.previousMountPaths]) {
      if (!pathContains(mountPath, pathOrFile)) continue;
      if (mountPath !== this.path) {
        this.touchPreviousMountPath(mountPath);
      }
      return true;
    }
    return false;
  }
  addPathPrefix(path) {
    if (this.path === "/") return path;
    return `${this.path}/${path}`;
  }
  // This (and inCollection) is special-cased to handle when the collection mount path
  // has been renamed. In that case, the first mount path that contains `path` is removed.
  // The current mount path is given priority.
  // If this function references a previous mount path that path is rescheduled for forgetting.
  removePathPrefix(path) {
    if (this.path === "/") return path;
    for (const mountPath of [this.path, ...this.previousMountPaths]) {
      if (mountPath === "" || !pathContains(mountPath, path)) continue;
      if (mountPath !== this.path) {
        this.touchPreviousMountPath(mountPath);
      }
      const replacing = `${mountPath}/`;
      if (path.startsWith(replacing)) {
        return path.replace(replacing, "");
      }
      return path;
    }
    return path;
  }
  isFile(pathOrFile) {
    if (pathOrFile instanceof import_obsidian9.TFolder) return false;
    if (pathOrFile instanceof import_obsidian9.TFile) return true;
    const path = typeof pathOrFile === "string" ? pathOrFile : pathOrFile.path;
    return /\.[^/]+$/i.test(path);
  }
  dirname(path) {
    const parts = path.split("/");
    return (this.isFile(parts[parts.length - 1]) ? parts.slice(0, -1) : parts).join("/");
  }
  async ensurePath(path) {
    const parts = this.dirname(path).split("/");
    const acc = [];
    for (const part of parts) {
      const folderPath = (0, import_obsidian9.normalizePath)([...acc, part].join("/"));
      if (!this.plugin.app.vault.getFolderByPath(folderPath)) {
        try {
          await this.plugin.app.vault.createFolder(folderPath);
        } catch (error) {
          this.log(`error creating intermediate folder "${folderPath}"`, error);
        }
      }
      acc.push(part);
    }
  }
  touchPreviousMountPath(mountPath) {
    let timeout = this.previousMountPathTouches.get(mountPath);
    window.clearTimeout(timeout);
    timeout = window.setTimeout(() => {
      this.log("forgetting previous mount path %s", mountPath);
      this.previousMountPaths = this.previousMountPaths.filter(
        (p) => p !== mountPath
      );
      this.previousMountPathTouches.delete(mountPath);
    }, MOUNT_RENAMES_BUFFER_MS);
    this.previousMountPathTouches.set(mountPath, timeout);
  }
  // FILES
  // Hooks called when non-CRDT-backed files are changed in a collection.
  async filesObserver(evt, txn) {
    this.plugin.collections.reportSize(this.id, this.size);
    if (txn.origin === this) return;
    const filter2 = /* @__PURE__ */ __name(([path, _]) => !isLiveDocument(path), "filter");
    const { created, moved, updated, deleted } = this.bucketEventChanges(
      evt,
      filter2
    );
    this.log(
      "[files] %d creates, %d updates, %d deletes, and %d moves",
      created.length,
      updated.length,
      deleted.length,
      moved.length
    );
    for (const {
      from: [fromPath],
      to: [toPath]
    } of moved) {
      this.log('[files] move "%s" -> "%s"', fromPath, toPath);
      const etag = this.files.get(toPath);
      if (!etag) continue;
      const oldPath = this.addPathPrefix(fromPath);
      const curr = this.plugin.app.vault.getAbstractFileByPath(oldPath);
      const dest = this.addPathPrefix(toPath);
      if (curr) {
        await this.ensurePath(dest);
        await this.plugin.app.vault.rename(curr, dest);
      }
    }
    const downloadChanges = created.concat(updated);
    for (const [path] of downloadChanges) {
      const etag = this.files.get(path);
      if (!etag) continue;
      const etagRecord = await this.getETag(path);
      if (!etagRecord || etagRecord.etag !== etag) {
        this.download(path);
      }
    }
    for (const [path] of deleted) {
      const prefixedPath = this.addPathPrefix(path);
      const file = this.plugin.app.vault.getAbstractFileByPath(prefixedPath);
      if (file) {
        this.plugin.app.vault.delete(file);
      }
      this.deleteETag(path);
    }
  }
  async processOldestOperation() {
    if (this.fileOpTimeout) return;
    const api = this.plugin.api.client;
    const online = this.plugin.networkStatus.online;
    if (api && online && this.plugin.socket.isConnected) {
      const ops = await this.plugin.db.fileOps.orderBy("timestamp").filter((op) => op.collection_id === this.id).limit(1).toArray();
      for (const op of ops) {
        let success = false;
        try {
          switch (op.type) {
            case "create" /* CREATE */:
            case "update" /* UPDATE */:
              await this.upload(op.path);
              break;
            case "move" /* MOVE */:
              const result = await this.remoteMoveFile(op.fromPath, op.path);
              if (result === "use-fallback") {
                await this.upload(op.path);
                await this.remoteDeleteFile(op.fromPath);
              }
              break;
            case "delete" /* DELETE */:
              await this.remoteDeleteFile(op.path);
              break;
          }
          success = true;
        } catch (e) {
          this.log(`error processing file operation at ${op.path}:`, e);
        }
        if (success) {
          this.fileOpDelay = DEFAULT_FILE_OP_DELAY_MS;
          await this.plugin.db.fileOps.delete([op.collection_id, op.path]);
        } else {
          this.fileOpDelay = Math.min(
            this.fileOpDelay * 2,
            MAX_FILE_OP_DELAY_MS
          );
        }
      }
    }
    this.fileOpTimeout = setTimeout(() => {
      if (this.fileOpTimeout) {
        this.fileOpTimeout = null;
      }
      this.processOldestOperation();
    }, this.fileOpDelay);
  }
  async handleFileInCollectionCreated(file) {
    const stat = await this.plugin.app.vault.adapter.stat(file.path);
    if (!stat) return;
    if (stat.size >= BINARY_FILE_SIZE_LIMIT_BYTES) {
      new import_obsidian9.Notice(intl.sync.fileSizeNotice({ path: file.path }));
      return;
    }
    return this.fileOpQueue.create(this.removePathPrefix(file.path));
  }
  handleFileInCollectionModified(file) {
    return this.fileOpQueue.update(this.removePathPrefix(file.path));
  }
  async handleFileInCollectionRenamed(file, oldPath) {
    if (file instanceof import_obsidian9.TFolder) return;
    const fromPath = this.removePathPrefix(oldPath);
    const toPath = this.removePathPrefix(file.path);
    await this.fileOpQueue.move(fromPath, toPath);
    return this.moveETag(fromPath, toPath);
  }
  async handleFileInCollectionDeleted(path) {
    const localPath = this.removePathPrefix(path);
    await this.fileOpQueue.delete(localPath);
    return this.deleteETag(localPath);
  }
  async upload(path) {
    var _a9, _b2, _c;
    const fullPath = this.addPathPrefix(path);
    const file = this.plugin.app.vault.getFileByPath(fullPath);
    if (!file) return;
    const stat = await this.plugin.app.vault.adapter.stat(file.path);
    if (!stat) return;
    if (stat.size >= BINARY_FILE_SIZE_LIMIT_BYTES) {
      new import_obsidian9.Notice(intl.sync.fileSizeNotice({ path: file.path }));
      return;
    }
    const buffer = await this.plugin.app.vault.readBinary(file);
    const fileType = await fileTypeFromBuffer(buffer);
    const api = this.plugin.api.client;
    if (!api) {
      throw new Error("No api client available");
    }
    if (stat.size <= MULTI_PART_THRESHOLD_BYTES) {
      this.log(`uploading file at ${fullPath} (single-part)\u2026`);
      const urlResp = await api.get(`collections/${this.id}/files/upload`, {
        params: {
          file_path: path
        }
      });
      const { url } = urlResp.data;
      const resp = await axios_default.put(url, buffer, {
        headers: {
          "Content-Type": (_a9 = fileType == null ? void 0 : fileType.mime) != null ? _a9 : "application/octet-stream"
          // If we want to send this header we need to include it in the signed URL.
          // "x-amz-checksum-sha1": sha1,
        }
      });
      const etag = resp.headers["etag"].replace(/"/g, "");
      await this.putETag(path, etag);
      this.log(`successfully uploaded ${path} (${etag})`);
    } else {
      this.log(`uploading file at ${fullPath} (multi-part)\u2026`);
      const contentType = (_b2 = fileType == null ? void 0 : fileType.mime) != null ? _b2 : "application/octet-stream";
      const {
        data: { upload_id: uploadId }
      } = await api.post(`collections/${this.id}/files/multi-part/initiate`, {
        file_path: path,
        content_type: contentType
      });
      this.log(`multi-part upload ID: ${uploadId}`);
      const parts = [];
      let offset = 0;
      let partNumber = 1;
      while (offset < buffer.byteLength) {
        this.log(`uploading part ${partNumber} for upload ID ${uploadId}`);
        const chunkSize = Math.min(
          MULTI_PART_CHUNK_SIZE_BYTES,
          buffer.byteLength - offset
        );
        const chunk = buffer.slice(offset, offset + chunkSize);
        const {
          data: { url }
        } = await api.get(`collections/${this.id}/files/upload`, {
          params: {
            file_path: path,
            upload_id: uploadId,
            part_number: partNumber
          }
        });
        const resp2 = await axios_default.put(url, chunk, {
          headers: { "Content-Type": contentType }
        });
        this.log(`uploaded part ${partNumber} for upload ID ${uploadId}`);
        const etag2 = (_c = resp2.headers.etag) == null ? void 0 : _c.replace(/"/g, "");
        if (!etag2) {
          throw new Error(`No ETag returned for part ${partNumber}`);
        }
        parts.push([partNumber, etag2]);
        partNumber++;
        offset += chunkSize;
      }
      this.log(`completing multi-part upload (${uploadId})`);
      const resp = await api.post(
        `collections/${this.id}/files/multi-part/complete`,
        {
          upload_id: uploadId,
          file_path: path,
          parts
        }
      );
      const etag = resp.data.etag.replace(/"/g, "");
      this.log(`multi-part upload complete (${uploadId}), etag: ${etag}`);
      this.putETag(path, etag);
    }
  }
  // Unlike the other file operation functions, we don't want to throw on failure here.
  // Download isn't called in the course of executing a FileOperation but instead when
  // files become available in the ymap.
  // We can silently fail and retry the next time the collection loads.
  async download(path) {
    const api = this.plugin.api.client;
    if (!api) return;
    const fullPath = this.addPathPrefix(path);
    this.log(`downloading file at ${fullPath}\u2026`);
    const urlResp = await api.get(`collections/${this.id}/files/download`, {
      params: {
        file_path: path
      }
    });
    const { url } = urlResp.data;
    const downloadResp = await axios_default.get(url, {
      responseType: "arraybuffer"
    });
    const data = downloadResp.data;
    this.controlModify(fullPath, async () => {
      try {
        const file = this.plugin.app.vault.getAbstractFileByPath(fullPath);
        if (file instanceof import_obsidian9.TFolder) {
          this.log(
            `Attempting to download a file at a path matching an existing folder; skipping.`
          );
          return;
        }
        if (file && file instanceof import_obsidian9.TFile) {
          await this.plugin.app.vault.modifyBinary(file, data);
        } else {
          await this.ensurePath(fullPath);
          await this.plugin.app.vault.createBinary(fullPath, data);
        }
        const etag = (0, import_js_md5.md5)(data);
        await this.putETag(path, etag);
        this.log(`Successfully downloaded file to ${fullPath}`);
      } catch (e) {
        this.log(`Error downloading ${fullPath}`, e);
      }
    });
  }
  async remoteMoveFile(from3, to) {
    const api = this.plugin.api.client;
    if (!api) {
      throw new Error("No api client available");
    }
    try {
      const resp = await api.post(`collections/${this.id}/files/move`, {
        from_file_path: from3,
        to_file_path: to
      });
      if (resp.status === 204) return "success";
      throw new Error("Received non-20x status from move");
    } catch (e) {
      if (e.status === 409 && e.response.data["use_fallback_behavior"])
        return "use-fallback";
      throw e;
    }
  }
  async remoteDeleteFile(path) {
    const api = this.plugin.api.client;
    if (!api) {
      throw new Error("No api client available");
    }
    const resp = await api.delete(`collections/${this.id}/files`, {
      params: {
        file_path: path
      }
    });
    if (resp.status !== 204) {
      throw new Error("Received non-204 status from delete");
    }
  }
  async getETag(path) {
    const etag = await this.plugin.db.etags.get([this.id, path]);
    return etag != null ? etag : null;
  }
  async putETag(path, etag) {
    return this.plugin.db.etags.put({
      collection_id: this.id,
      path,
      etag
    });
  }
  async deleteETag(path) {
    return this.plugin.db.etags.delete([this.id, path]);
  }
  async moveETag(fromPath, toPath) {
    const record = await this.getETag(fromPath);
    if (!record) return;
    await this.deleteETag(fromPath);
    this.putETag(toPath, record.etag);
  }
  // ## Document Migrations
  async migrateLiveDocuments() {
    const pathsToMigrate = [];
    for (const path of this.files.keys()) {
      const prefixedPath = this.addPathPrefix(path);
      if (isLiveDocument(prefixedPath)) {
        pathsToMigrate.push(prefixedPath);
      }
    }
    if (pathsToMigrate.length === 0) return;
    this.log(
      `Found ${pathsToMigrate.length} paths to migrate from files to docs`,
      pathsToMigrate
    );
    const files = pathsToMigrate.map((p) => this.plugin.app.vault.getAbstractFileByPath(p)).filter((p) => p != null);
    await this.addLiveDocuments(files);
    pathsToMigrate.forEach((p) => this.handleFileInCollectionDeleted(p));
  }
};
__name(_CollectionHandler, "CollectionHandler");
var CollectionHandler = _CollectionHandler;

// src/services/collections/CollectionsService.ts
var import_debug12 = __toESM(require_browser2());
var import_obsidian10 = require("obsidian");
var TABLE4 = "id,team_id";
var SETTINGS_TABLE = "collection_id,mount_path";
var log8 = (0, import_debug12.default)("screen.garden:collections");
var _CollectionsService = class _CollectionsService extends Service {
  constructor(plugin) {
    super(plugin);
    this.collectionSettings = [];
    this.handlers = /* @__PURE__ */ new Map();
    this.collectionSize = new Subject();
    this.destroy = new Subject();
    this.collectionsSettingsObservable = liveQuery(
      () => this.db.collectionSettings.toArray()
    );
    this.availableCollectionsObservable = liveQuery(
      () => this.db.collections.toArray()
    );
    this.apiSubscription = this.plugin.api.observable.subscribe({
      next: /* @__PURE__ */ __name(async (api) => {
        if (api == null) return;
        this.getAndStoreCollections(api);
      }, "next")
    });
    this.collectionSettingsSubscription = this.collectionsSettingsObservable.subscribe({
      next: /* @__PURE__ */ __name(async (collectionSettings) => {
        const removed = Array.from(this.handlers.keys()).filter(
          (id2) => !collectionSettings.some(
            ({ collection_id }) => collection_id === id2
          )
        );
        for (const id2 of removed) {
          this.deleteHandler(id2);
        }
        for (const { collection_id, mount_path } of collectionSettings.filter(
          ({ collection_id: collection_id2 }) => !this.handlers.get(collection_id2)
        )) {
          const collection = await this.db.collections.get(collection_id);
          if (!collection)
            return log8(
              "fatal error: could not find collection for mount point"
            );
          const handler = new CollectionHandler(
            this.plugin,
            collection_id,
            mount_path
          );
          this.setHandler(collection_id, handler);
        }
        this.collectionSettings = collectionSettings;
      }, "next")
    });
    this.collectionSizes = this.collectionSize.pipe(
      scan((acc, next) => ({ ...acc, ...next }), {}),
      takeUntil(this.destroy),
      shareReplay(1)
    );
  }
  async onunload() {
    for (const handler of this.handlers.values()) {
      this.deleteHandler(handler);
    }
    this.apiSubscription.unsubscribe();
    this.collectionSettingsSubscription.unsubscribe();
    this.destroy.next();
    this.destroy.complete();
  }
  /// API
  async getAndStoreCollections(api) {
    const resp = await api.get("/collections");
    const { data: collections } = resp.data;
    log8("fetched available collections %o", collections);
    this.db.collections.bulkPut(collections);
  }
  /// HANDLERS
  setHandler(collectionId, handler) {
    this.handlers.set(collectionId, handler);
  }
  deleteHandler(idOrHandler) {
    const handler = idOrHandler instanceof CollectionHandler ? idOrHandler : this.handlers.get(idOrHandler);
    if (handler) {
      handler.close();
      this.handlers.delete(handler.id);
    } else if (typeof idOrHandler === "string") {
      this.handlers.delete(idOrHandler);
    }
  }
  async requireHandlerForFile(file) {
    const collectionSettings = this.collectionSettings.find(
      ({ mount_path }) => pathContains(mount_path, file)
    );
    if (collectionSettings == null) {
      return null;
    }
    const handler = this.handlers.get(collectionSettings.collection_id);
    if (handler == null) {
      log8("no handler for file %s", file.path);
      return null;
    }
    return handler.requireHandlerForFile(file);
  }
  /**
   * Gets a collection handler if it exists. Does not mount one if it does not exist.
   * Only call this in situations where you are sure the collection exists and is mounted,
   * e.g. within child NoteHandlers.
   */
  getHandler(collectionId) {
    var _a9;
    return (_a9 = this.handlers.get(collectionId)) != null ? _a9 : null;
  }
  async mount(collectionId, mountPath) {
    const collection = await this.db.collections.get(collectionId);
    if (!collection) {
      log8("no collection with id: %s", collectionId);
      return false;
    }
    const existingSettings = await this.db.collectionSettings.toArray();
    if (existingSettings.some(
      ({ mount_path: path }) => pathContains(path, mountPath) || pathContains(mountPath, path)
    )) {
      new import_obsidian10.Notice(intl.mountModal.noNestingNotice());
      return false;
    }
    const collectionSettings = {
      collection_id: collectionId,
      mount_path: mountPath,
      last_sync: /* @__PURE__ */ new Date()
    };
    await this.db.collectionSettings.put(collectionSettings);
    const folder = this.plugin.app.vault.getFolderByPath(mountPath);
    if (folder) {
      const filesToAdd = [];
      import_obsidian10.Vault.recurseChildren(folder, (abstractFile) => {
        if (abstractFile instanceof import_obsidian10.TFile) {
          filesToAdd.push(abstractFile);
        }
      });
      if (filesToAdd.length > 0) {
        let handler = this.handlers.get(collectionId);
        if (!handler || !handler.loaded) {
          const ref = await new Promise(
            (resolve) => this.on(collectionHandlerReadyEvent(collectionId), resolve)
          );
          this.offref(ref);
          handler = this.handlers.get(collectionId);
        }
        if (!handler) {
          log8(
            `unexpected undefined handler reported as ready: ${collectionId}`
          );
          return false;
        }
        handler.addFiles(filesToAdd);
      }
    }
    return true;
  }
  async unmount(collectionId) {
    const liveDocumentKeys = await this.db.liveDocuments.where({
      collection_id: collectionId
    }).primaryKeys();
    await this.db.liveDocuments.bulkDelete(liveDocumentKeys);
    await Promise.all(liveDocumentKeys.map((k) => this.plugin.docs.delete(k)));
    await this.db.collectionSettings.delete(collectionId);
    await this.plugin.docs.delete(collectionId);
  }
  /**
   * Creates a collection and inserts it into LocalStorage.
   * Requires a valid API client and connection to the server;
   * attempts while offline will fail.
   * @param name
   * @param team
   * @param privacy
   */
  async create(name, team, privacy) {
    var _a9;
    const resp = await ((_a9 = this.plugin.api.client) == null ? void 0 : _a9.post(
      "/collections",
      {
        collection: {
          name,
          private: privacy.isPrivate
        },
        team_id: team.id,
        user_ids: privacy.users.map((u) => u.id),
        group_ids: privacy.groups.map((g) => g.id)
      }
    ));
    if (!resp) return null;
    const { data: collection } = resp.data;
    this.db.collections.put(collection);
    return collection;
  }
  collectionAtMountPath(path) {
    var _a9;
    return (_a9 = this.collectionSettings.find((s) => s.mount_path === path)) != null ? _a9 : null;
  }
  collectionContaining(pathOrFile) {
    var _a9;
    const p = getPath(pathOrFile);
    return (_a9 = this.collectionSettings.find((s) => pathContains(s.mount_path, p))) != null ? _a9 : null;
  }
  inMountedCollection(pathOrFile) {
    return !!this.collectionContaining(pathOrFile);
  }
  /**
   * A fast, potentially stale snapshot of collection settings.
   *
   * Use this for things that can tolerate delay but are updated frequently.
   */
  get fastCollectionSettings() {
    return this.collectionSettings;
  }
  async dataForFile(pathOrFile) {
    const cs = this.collectionContaining(pathOrFile);
    if (!cs) {
      return null;
    }
    const collection = await this.db.collections.get(cs.collection_id);
    if (!collection) {
      return null;
    }
    const team = await this.db.teams.get(collection.team_id);
    if (!team) {
      return null;
    }
    const path = getPath(pathOrFile);
    const liveDocument = await this.db.liveDocuments.where({ path }).first();
    if (!liveDocument) {
      return null;
    }
    return {
      team,
      collection,
      liveDocument
    };
  }
  presenceForCollection(id2) {
    var _a9, _b2;
    return (_b2 = (_a9 = this.handlers.get(id2)) == null ? void 0 : _a9.presenceMetas()) != null ? _b2 : null;
  }
  reportSize(id2, size2) {
    this.collectionSize.next({ [id2]: size2 });
  }
  addPathPrefixForCollection(id2, path) {
    const collection = this.collectionSettings.find(
      (s) => s.collection_id === id2
    );
    if (!collection) return null;
    return `${collection.mount_path}/${getPath(path)}`;
  }
};
__name(_CollectionsService, "CollectionsService");
var CollectionsService = _CollectionsService;

// src/services/teams/index.ts
init_process_shim();

// src/services/teams/TeamsService.ts
init_process_shim();
var import_debug13 = __toESM(require_browser2());
var TABLE5 = "id,plan";
var DEFAULT_COLLECTION_PRIVACY = {
  isPrivate: false,
  users: [],
  groups: []
};
var log9 = (0, import_debug13.default)("screen.garden:teams");
var _TeamsService = class _TeamsService extends Service {
  constructor(plugin) {
    super(plugin);
    this._teams = null;
    this.subscription = this.plugin.api.observable.subscribe({
      next: /* @__PURE__ */ __name(async (api) => {
        if (api == null) return;
        this.getTeams(api);
      }, "next")
    });
  }
  async onunload() {
    this.subscription.unsubscribe();
  }
  get() {
    return this._teams;
  }
  async loadTeams() {
    const api = this.plugin.api.client;
    if (!api) return;
    this.getTeams(api);
  }
  async getTeams(api) {
    const {
      data: { data: teams }
    } = await api.get("/teams");
    this._teams = teams;
    log9("teams %o", teams);
    await this.db.teams.bulkPut(teams);
  }
  async searchUsers(query, team) {
    var _a9;
    const resp = await ((_a9 = this.plugin.api.client) == null ? void 0 : _a9.get(
      `teams/${team.id}/users`,
      {
        params: {
          q: query
        }
      }
    ));
    if (!resp) return null;
    const { data: users } = resp.data;
    return users;
  }
  async searchGroups(query, team) {
    var _a9;
    const resp = await ((_a9 = this.plugin.api.client) == null ? void 0 : _a9.get(
      `teams/${team.id}/groups`,
      {
        params: {
          q: query
        }
      }
    ));
    if (!resp) return null;
    const { data: groups } = resp.data;
    return groups;
  }
};
__name(_TeamsService, "TeamsService");
var TeamsService = _TeamsService;

// src/services/docs/index.ts
init_process_shim();

// src/services/docs/DocsService.ts
init_process_shim();

// src/services/docs/DocChannel.ts
init_process_shim();

// src/services/docs/UpdateController.ts
init_process_shim();
var _UpdateController = class _UpdateController {
  constructor(conf) {
    this.conf = conf;
    this.mergedOutgoing = null;
    this.restId = null;
    var _a9;
    const wait = (_a9 = this.conf.sendBufferWait) != null ? _a9 : 0;
    if (wait <= 0) return;
    this.dispatchOutgoing = throttle_default2(
      () => {
        if (!this.mergedOutgoing) return;
        const merged = this.mergedOutgoing;
        this.mergedOutgoing = null;
        this.mark();
        this.conf.sendOutgoing(merged);
      },
      wait,
      { trailing: true, leading: false }
    );
  }
  /**
   * Send a ydoc update from this client to the server. May be merged with others and batched.
   * @param update The update to send.
   */
  send(update) {
    if (!this.dispatchOutgoing) {
      this.mark();
      this.conf.sendOutgoing(update);
      return;
    }
    this.mergedOutgoing = this.mergedOutgoing ? mergeUpdates([this.mergedOutgoing, update]) : update;
    this.dispatchOutgoing();
  }
  /**
   * Receive a ydoc update from the server to the client. Passed through to the writeIncoming
   * constructor param.
   * @param update
   */
  receive(update) {
    this.conf.writeIncoming(update);
  }
  /**
   * Send all pending outgoing updates and stop monitoring for rest.
   */
  flush() {
    if (this.restId) window.clearTimeout(this.restId);
    this.restId = null;
    if (!this.dispatchOutgoing) return;
    this.dispatchOutgoing.flush();
  }
  mark() {
    if (!this.conf.onRest || !this.conf.restWait || this.conf.restWait <= 0)
      return;
    if (this.restId) window.clearTimeout(this.restId);
    this.restId = window.setTimeout(() => {
      this.restId = null;
      if (this.conf.onRest) this.conf.onRest();
    }, this.conf.restWait);
  }
};
__name(_UpdateController, "UpdateController");
var UpdateController = _UpdateController;

// src/services/docs/DocChannel.ts
var import_debug14 = __toESM(require_browser2());
var import_obsidian11 = require("obsidian");
var BUFFER_INTERVAL = 500;
var REST_TIMEOUT = 3e4;
var _DocChannel = class _DocChannel {
  constructor(plugin, doc2, context2, lifecycle) {
    this.plugin = plugin;
    this.doc = doc2;
    this.context = context2;
    this.lifecycle = lifecycle;
    this.channel = null;
    this.presence = null;
    this._pendingPresenceUpdate = null;
    this.handleChannelJoin = /* @__PURE__ */ __name((reply) => {
      var _a9, _b2;
      if (this.channel == null) return;
      this.log("connected");
      this.doc.ydoc.on("update", this.handleYDocUpdate);
      this.channel.on("update", this.handleChannelUpdate);
      (_b2 = (_a9 = this.lifecycle).onJoin) == null ? void 0 : _b2.call(_a9, this, reply);
      this.sync();
    }, "handleChannelJoin");
    this.handleChannelRejected = /* @__PURE__ */ __name((msg) => {
      this.log("rejected: %o", msg);
      if (msg.reason === "unauthorized" && this.plugin.account.get()) {
        this.plugin.account.flagNeedsReauth();
      }
    }, "handleChannelRejected");
    // ydoc -> channel updates
    this.handleYDocUpdate = /* @__PURE__ */ __name((update, origin2) => {
      var _a9;
      if (origin2 == this) return;
      (_a9 = this.updates) == null ? void 0 : _a9.send(update);
    }, "handleYDocUpdate");
    this.pushUpdate = /* @__PURE__ */ __name((update) => {
      if (this.channel == null) return;
      this.log("sending update, %d bytes", update.byteLength);
      this.channel.push("update", update.buffer);
    }, "pushUpdate");
    // channel -> ydoc updates
    this.handleChannelUpdate = /* @__PURE__ */ __name((update) => {
      var _a9, _b2, _c;
      this.log("received update, %d bytes", update.byteLength);
      (_a9 = this.updates) == null ? void 0 : _a9.receive(update);
      (_c = (_b2 = this.lifecycle).onUpdate) == null ? void 0 : _c.call(_b2, this);
    }, "handleChannelUpdate");
    this.applyUpdate = /* @__PURE__ */ __name((update) => {
      const decoded = update instanceof Uint8Array ? update : new Uint8Array(update);
      applyUpdate(this.doc.ydoc, decoded, this);
    }, "applyUpdate");
    // sync
    this.sync = /* @__PURE__ */ __name(() => {
      if (this.channel == null) return;
      this.log("syncing");
      const sv = encodeStateVector(this.doc.ydoc).buffer;
      this.channel.push("sync", sv).receive("ok", ({ diff_update, state_vector }) => {
        var _a9, _b2, _c;
        this.log("sync received diff and sv");
        const sv2 = new Uint8Array((0, import_obsidian11.base64ToArrayBuffer)(state_vector));
        const diff = new Uint8Array((0, import_obsidian11.base64ToArrayBuffer)(diff_update));
        this.log("received sync update, %d bytes", diff.byteLength);
        this.applyUpdate(diff);
        const update = encodeStateAsUpdate(this.doc.ydoc, sv2);
        this.log("sending sync update, %d bytes", update.byteLength);
        (_a9 = this.channel) == null ? void 0 : _a9.push("update", update.buffer);
        this.log("synced");
        (_c = (_b2 = this.lifecycle).afterSync) == null ? void 0 : _c.call(_b2, this);
      }).receive("error", () => {
        this.log("sync failed");
      });
    }, "sync");
    // presence
    this.pushPresence = /* @__PURE__ */ __name((update) => {
      if (this.channel) {
        this.channel.push("update-presence", update);
      } else {
        this._pendingPresenceUpdate = update;
      }
    }, "pushPresence");
    this.listPresences = /* @__PURE__ */ __name((keyName) => {
      var _a9, _b2;
      return (_b2 = (_a9 = this.presence) == null ? void 0 : _a9.list((k, v) => v.metas.map((m) => ({ [keyName]: k, ...m }))).flat()) != null ? _b2 : [];
    }, "listPresences");
    this.log = (0, import_debug14.default)(`screen.garden:doc:${doc2.id}:${context2.kind}`);
    this.log("init");
    this.updates = new UpdateController({
      sendOutgoing: this.pushUpdate.bind(this),
      sendBufferWait: BUFFER_INTERVAL,
      writeIncoming: this.applyUpdate.bind(this),
      onRest: /* @__PURE__ */ __name(() => {
        this.sync();
      }, "onRest"),
      restWait: REST_TIMEOUT
    });
    this.socketSubscription = this.plugin.socket.observable.subscribe(
      (socket) => {
        if (socket) {
          this.connect(socket);
        } else {
          this.disconnect();
        }
      }
    );
    if (this.plugin.socket.socket) this.connect(this.plugin.socket.socket);
  }
  connect(socket) {
    this.disconnect();
    this.log("connecting");
    const channel = socket.channel(`doc:${this.doc.id}`, this.context);
    channel.join().receive("ok", this.handleChannelJoin).receive("error", this.handleChannelRejected);
    this.channel = channel;
    this.presence = new Presence(this.channel);
    this.presence.onSync(() => {
      if (!this.presence) return;
      this.plugin.docs.trigger(`presence:${this.doc.id}`, this.doc.id);
    });
    if (this._pendingPresenceUpdate) {
      this.pushPresence(this._pendingPresenceUpdate);
      this._pendingPresenceUpdate = null;
    }
  }
  disconnect() {
    var _a9;
    if (this.channel == null) return;
    this.log("disconnecting");
    this.doc.ydoc.off("update", this.handleYDocUpdate);
    (_a9 = this.updates) == null ? void 0 : _a9.flush();
    this.channel.leave();
    this.channel = null;
    if (this.presence) {
      this.presence.onSync = function() {
      };
    }
    this.presence = null;
  }
  unload() {
    this.disconnect();
    this.socketSubscription.unsubscribe();
    this.updates = null;
    this.lifecycle = {};
  }
  push(event, payload) {
    return new Promise((resolve, reject) => {
      if (this.channel == null) {
        reject();
        return;
      }
      this.channel.push(event, payload).receive("ok", (res) => {
        resolve(res);
      }).receive("error", () => {
        this.log(`${event} push failed`);
        reject();
      });
    });
  }
};
__name(_DocChannel, "DocChannel");
var DocChannel = _DocChannel;

// src/services/docs/DocsService.ts
var import_debug15 = __toESM(require_browser2());

// node_modules/y-indexeddb/src/y-indexeddb.js
init_process_shim();

// node_modules/lib0/indexeddb.js
init_process_shim();
var rtop = /* @__PURE__ */ __name((request) => create4((resolve, reject) => {
  request.onerror = (event) => reject(new Error(event.target.error));
  request.onsuccess = (event) => resolve(event.target.result);
}), "rtop");
var openDB = /* @__PURE__ */ __name((name, initDB) => create4((resolve, reject) => {
  const request = indexedDB.open(name);
  request.onupgradeneeded = (event) => initDB(event.target.result);
  request.onerror = (event) => reject(create3(event.target.error));
  request.onsuccess = (event) => {
    const db = event.target.result;
    db.onversionchange = () => {
      db.close();
    };
    resolve(db);
  };
}), "openDB");
var deleteDB = /* @__PURE__ */ __name((name) => rtop(indexedDB.deleteDatabase(name)), "deleteDB");
var createStores = /* @__PURE__ */ __name((db, definitions) => definitions.forEach(
  (d2) => (
    // @ts-ignore
    db.createObjectStore.apply(db, d2)
  )
), "createStores");
var transact2 = /* @__PURE__ */ __name((db, stores, access = "readwrite") => {
  const transaction = db.transaction(stores, access);
  return stores.map((store) => getStore(transaction, store));
}, "transact");
var count = /* @__PURE__ */ __name((store, range) => rtop(store.count(range)), "count");
var get2 = /* @__PURE__ */ __name((store, key) => rtop(store.get(key)), "get");
var del = /* @__PURE__ */ __name((store, key) => rtop(store.delete(key)), "del");
var put = /* @__PURE__ */ __name((store, item, key) => rtop(store.put(item, key)), "put");
var addAutoKey = /* @__PURE__ */ __name((store, item) => rtop(store.add(item)), "addAutoKey");
var getAll = /* @__PURE__ */ __name((store, range, limit) => rtop(store.getAll(range, limit)), "getAll");
var queryFirst = /* @__PURE__ */ __name((store, query, direction) => {
  let first = null;
  return iterateKeys(store, query, (key) => {
    first = key;
    return false;
  }, direction).then(() => first);
}, "queryFirst");
var getLastKey = /* @__PURE__ */ __name((store, range = null) => queryFirst(store, range, "prev"), "getLastKey");
var iterateOnRequest = /* @__PURE__ */ __name((request, f) => create4((resolve, reject) => {
  request.onerror = reject;
  request.onsuccess = async (event) => {
    const cursor = event.target.result;
    if (cursor === null || await f(cursor) === false) {
      return resolve();
    }
    cursor.continue();
  };
}), "iterateOnRequest");
var iterateKeys = /* @__PURE__ */ __name((store, keyrange, f, direction = "next") => iterateOnRequest(store.openKeyCursor(keyrange, direction), (cursor) => f(cursor.key)), "iterateKeys");
var getStore = /* @__PURE__ */ __name((t, store) => t.objectStore(store), "getStore");
var createIDBKeyRangeUpperBound = /* @__PURE__ */ __name((upper, upperOpen) => IDBKeyRange.upperBound(upper, upperOpen), "createIDBKeyRangeUpperBound");
var createIDBKeyRangeLowerBound = /* @__PURE__ */ __name((lower, lowerOpen) => IDBKeyRange.lowerBound(lower, lowerOpen), "createIDBKeyRangeLowerBound");

// node_modules/y-indexeddb/src/y-indexeddb.js
var customStoreName = "custom";
var updatesStoreName = "updates";
var PREFERRED_TRIM_SIZE = 500;
var fetchUpdates = /* @__PURE__ */ __name((idbPersistence, beforeApplyUpdatesCallback = () => {
}, afterApplyUpdatesCallback = () => {
}) => {
  const [updatesStore] = transact2(
    /** @type {IDBDatabase} */
    idbPersistence.db,
    [updatesStoreName]
  );
  return getAll(updatesStore, createIDBKeyRangeLowerBound(idbPersistence._dbref, false)).then((updates) => {
    if (!idbPersistence._destroyed) {
      beforeApplyUpdatesCallback(updatesStore);
      transact(idbPersistence.doc, () => {
        updates.forEach((val) => applyUpdate(idbPersistence.doc, val));
      }, idbPersistence, false);
      afterApplyUpdatesCallback(updatesStore);
    }
  }).then(() => getLastKey(updatesStore).then((lastKey) => {
    idbPersistence._dbref = lastKey + 1;
  })).then(() => count(updatesStore).then((cnt) => {
    idbPersistence._dbsize = cnt;
  })).then(() => updatesStore);
}, "fetchUpdates");
var storeState = /* @__PURE__ */ __name((idbPersistence, forceStore = true) => fetchUpdates(idbPersistence).then((updatesStore) => {
  if (forceStore || idbPersistence._dbsize >= PREFERRED_TRIM_SIZE) {
    addAutoKey(updatesStore, encodeStateAsUpdate(idbPersistence.doc)).then(() => del(updatesStore, createIDBKeyRangeUpperBound(idbPersistence._dbref, true))).then(() => count(updatesStore).then((cnt) => {
      idbPersistence._dbsize = cnt;
    }));
  }
}), "storeState");
var clearDocument = /* @__PURE__ */ __name((name) => deleteDB(name), "clearDocument");
var _IndexeddbPersistence = class _IndexeddbPersistence extends Observable4 {
  /**
   * @param {string} name
   * @param {Y.Doc} doc
   */
  constructor(name, doc2) {
    super();
    this.doc = doc2;
    this.name = name;
    this._dbref = 0;
    this._dbsize = 0;
    this._destroyed = false;
    this.db = null;
    this.synced = false;
    this._db = openDB(
      name,
      (db) => createStores(db, [
        ["updates", { autoIncrement: true }],
        ["custom"]
      ])
    );
    this.whenSynced = create4((resolve) => this.on("synced", () => resolve(this)));
    this._db.then((db) => {
      this.db = db;
      const beforeApplyUpdatesCallback = /* @__PURE__ */ __name((updatesStore) => addAutoKey(updatesStore, encodeStateAsUpdate(doc2)), "beforeApplyUpdatesCallback");
      const afterApplyUpdatesCallback = /* @__PURE__ */ __name(() => {
        if (this._destroyed) return this;
        this.synced = true;
        this.emit("synced", [this]);
      }, "afterApplyUpdatesCallback");
      fetchUpdates(this, beforeApplyUpdatesCallback, afterApplyUpdatesCallback);
    });
    this._storeTimeout = 1e3;
    this._storeTimeoutId = null;
    this._storeUpdate = (update, origin2) => {
      if (this.db && origin2 !== this) {
        const [updatesStore] = transact2(
          /** @type {IDBDatabase} */
          this.db,
          [updatesStoreName]
        );
        addAutoKey(updatesStore, update);
        if (++this._dbsize >= PREFERRED_TRIM_SIZE) {
          if (this._storeTimeoutId !== null) {
            clearTimeout(this._storeTimeoutId);
          }
          this._storeTimeoutId = setTimeout(() => {
            storeState(this, false);
            this._storeTimeoutId = null;
          }, this._storeTimeout);
        }
      }
    };
    doc2.on("update", this._storeUpdate);
    this.destroy = this.destroy.bind(this);
    doc2.on("destroy", this.destroy);
  }
  destroy() {
    if (this._storeTimeoutId) {
      clearTimeout(this._storeTimeoutId);
    }
    this.doc.off("update", this._storeUpdate);
    this.doc.off("destroy", this.destroy);
    this._destroyed = true;
    return this._db.then((db) => {
      db.close();
    });
  }
  /**
   * Destroys this instance and removes all data from indexeddb.
   *
   * @return {Promise<void>}
   */
  clearData() {
    return this.destroy().then(() => {
      deleteDB(this.name);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @return {Promise<String | number | ArrayBuffer | Date | any>}
   */
  get(key) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName], "readonly");
      return get2(custom, key);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @param {String | number | ArrayBuffer | Date} value
   * @return {Promise<String | number | ArrayBuffer | Date>}
   */
  set(key, value) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName]);
      return put(custom, value, key);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @return {Promise<undefined>}
   */
  del(key) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName]);
      return del(custom, key);
    });
  }
};
__name(_IndexeddbPersistence, "IndexeddbPersistence");
var IndexeddbPersistence = _IndexeddbPersistence;

// src/services/docs/DocsService.ts
var TABLE6 = "id";
var log10 = (0, import_debug15.default)("screen.garden:docs");
var _DocsService = class _DocsService extends Service {
  constructor(plugin) {
    super(plugin);
  }
  async create(id2 = v4_default()) {
    const doc2 = { id: id2 };
    const doc_id = await this.db.docs.put(doc2);
    log10("inserted new doc: %s", doc_id);
    return doc2;
  }
  async get(id2) {
    const doc2 = await this.db.docs.get(id2);
    return doc2 != null ? doc2 : null;
  }
  async getOrCreateAndLoad(id2, context2, lifecycle) {
    var _a9;
    const doc2 = (_a9 = await this.get(id2)) != null ? _a9 : await this.create(id2);
    return this.load(doc2, context2, lifecycle);
  }
  docName(id2) {
    return `screen.garden:doc:${this.plugin.appId}:${id2}`;
  }
  persistedDoc(docId, ydoc = new Doc()) {
    return new IndexeddbPersistence(this.docName(docId), ydoc);
  }
  async docIsPersisted(docId) {
    const name = this.docName(docId);
    return (await indexedDB.databases()).some((d2) => d2.name === name);
  }
  load(doc2, context2, lifecycle) {
    log10(`loading ${doc2.id}`);
    const provider = this.persistedDoc(doc2.id);
    return new Promise((resolve) => {
      provider.on("synced", () => {
        const loadedDoc = { ...doc2, ydoc: provider.doc, provider };
        const channel = new DocChannel(
          this.plugin,
          loadedDoc,
          context2,
          lifecycle
        );
        resolve({ ...loadedDoc, channel });
      });
    });
  }
  unload(doc2) {
    if ("channel" in doc2) {
      doc2.channel.disconnect();
      doc2.channel.unload();
    }
  }
  async delete(docOrId) {
    const id2 = typeof docOrId === "string" ? docOrId : docOrId.id;
    return Promise.all([
      clearDocument(this.docName(id2)),
      this.db.docs.delete(id2)
    ]);
  }
};
__name(_DocsService, "DocsService");
var DocsService = _DocsService;

// src/services/socket/index.ts
init_process_shim();

// src/services/socket/SocketService.ts
init_process_shim();
var import_debug16 = __toESM(require_browser2());
var import_obsidian12 = require("obsidian");
var log11 = (0, import_debug16.default)("screen.garden:socket");
var _SocketService = class _SocketService extends Service {
  constructor(plugin) {
    super(plugin);
    this.connected = new Subject();
    this.updateRequired = new Subject();
    this.isConnected = false;
    this.observable = new Subject();
    this.tokenSubscription = combineLatest([
      this.plugin.settings.tokenObservable,
      this.plugin.api.observable
    ]).subscribe({
      next: /* @__PURE__ */ __name(([token, api]) => {
        if (token && api) {
          this.connect(token, api);
        } else {
          this.disconnect();
        }
      }, "next")
    });
    this.plugin.addCommand({
      id: "connect",
      name: intl.socket.connectCommand(),
      checkCallback: /* @__PURE__ */ __name((checking) => {
        var _a9, _b2;
        if (checking && ((_a9 = this.plugin.settings.config) == null ? void 0 : _a9.token)) {
          return this.socket === null;
        }
        log11("Going online");
        if (((_b2 = this.plugin.settings.config) == null ? void 0 : _b2.token) && this.plugin.api.client) {
          this.connect(
            this.plugin.settings.config.token,
            this.plugin.api.client
          );
        }
      }, "checkCallback")
    });
    this.plugin.addCommand({
      id: "disconnect",
      name: intl.socket.disconnectCommand(),
      checkCallback: /* @__PURE__ */ __name((checking) => {
        if (checking) {
          return this.socket !== null;
        }
        log11("Going offline");
        this.disconnect();
      }, "checkCallback")
    });
  }
  async connect(token, api) {
    try {
      const resp = await api.post("/client", {
        client_version: this.plugin.manifest.version
      });
      if (resp.status == 200) {
        this.updateRequired.next(false);
        this.connectToSocket(token);
      }
    } catch (error) {
      if (error.status == 409) {
        log11(intl.socket.clientUpdateRequired());
        new import_obsidian12.Notice(intl.socket.clientUpdateRequired());
        this.updateRequired.next(true);
      } else {
        log11(error.message);
      }
    }
  }
  connectToSocket(token) {
    this.disconnect();
    this.origin = v4_default();
    const socket = new Socket(`${BASE_WS_URL}/socket`, {
      params: {
        token,
        client: this.plugin.manifest.id,
        client_version: this.plugin.manifest.version,
        origin: this.origin
      }
    });
    socket.onOpen(() => {
      log11("opened");
      this.connected.next(true);
      this.isConnected = true;
    });
    socket.onClose(() => {
      log11("closed");
      this.connected.next(false);
      this.isConnected = false;
    });
    socket.onError((e) => log11("error: %o", e));
    socket.connect();
    this.socket = socket;
    this.next();
  }
  disconnect() {
    if (this.socket == null) return;
    this.origin = null;
    this.socket.disconnect();
    this.socket = null;
    this.next();
  }
  next() {
    this.observable.next(this.socket);
  }
  async onunload() {
    this.tokenSubscription.unsubscribe();
    this.disconnect();
  }
};
__name(_SocketService, "SocketService");
var SocketService = _SocketService;

// src/services/views/index.ts
init_process_shim();

// src/services/views/ViewsService.ts
init_process_shim();

// src/services/views/file-explorer/FileExplorerDecorator.ts
init_process_shim();

// src/services/views/file-explorer/FileExplorerDecoration.tsx
init_process_shim();

// src/services/views/context/index.ts
init_process_shim();

// node_modules/dexie-react-hooks/dist/dexie-react-hooks.mjs
init_process_shim();
var import_react5 = __toESM(require_react(), 1);
function useObservable2(observableFactory, arg2, arg3) {
  var deps;
  var defaultResult;
  if (typeof observableFactory === "function") {
    deps = arg2 || [];
    defaultResult = arg3;
  } else {
    deps = [];
    defaultResult = arg2;
  }
  var monitor = import_react5.default.useRef({
    hasResult: false,
    result: defaultResult,
    error: null
  });
  var _a9 = import_react5.default.useReducer(function(x) {
    return x + 1;
  }, 0);
  _a9[0];
  var triggerUpdate = _a9[1];
  var observable2 = import_react5.default.useMemo(function() {
    var observable3 = typeof observableFactory === "function" ? observableFactory() : observableFactory;
    if (!observable3 || typeof observable3.subscribe !== "function") {
      if (observableFactory === observable3) {
        throw new TypeError("Given argument to useObservable() was neither a valid observable nor a function.");
      } else {
        throw new TypeError("Observable factory given to useObservable() did not return a valid observable.");
      }
    }
    if (!monitor.current.hasResult && typeof window !== "undefined") {
      if (typeof observable3.hasValue !== "function" || observable3.hasValue()) {
        if (typeof observable3.getValue === "function") {
          monitor.current.result = observable3.getValue();
          monitor.current.hasResult = true;
        } else {
          var subscription = observable3.subscribe(function(val) {
            monitor.current.result = val;
            monitor.current.hasResult = true;
          });
          if (typeof subscription === "function") {
            subscription();
          } else {
            subscription.unsubscribe();
          }
        }
      }
    }
    return observable3;
  }, deps);
  import_react5.default.useDebugValue(monitor.current.result);
  import_react5.default.useEffect(function() {
    var subscription = observable2.subscribe(function(val) {
      var current = monitor.current;
      if (current.error !== null || current.result !== val) {
        current.error = null;
        current.result = val;
        current.hasResult = true;
        triggerUpdate();
      }
    }, function(err2) {
      var current = monitor.current;
      if (current.error !== err2) {
        current.error = err2;
        triggerUpdate();
      }
    });
    return typeof subscription === "function" ? subscription : subscription.unsubscribe.bind(subscription);
  }, deps);
  if (monitor.current.error)
    throw monitor.current.error;
  return monitor.current.result;
}
__name(useObservable2, "useObservable");
function useLiveQuery(querier, deps, defaultResult) {
  return useObservable2(function() {
    return liveQuery(querier);
  }, deps || [], defaultResult);
}
__name(useLiveQuery, "useLiveQuery");

// src/services/views/file-explorer/FileExplorerDecoration.tsx
var import_react6 = __toESM(require_react());
var import_client2 = __toESM(require_client());
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var _FileExplorerDecoration = class _FileExplorerDecoration {
  constructor(plugin, container, collectionID) {
    this.container = container;
    this.collectionID = collectionID;
    this.root = null;
    this.el = document.createElement("div");
    this.el.classList.add("sg-mounted-collection-decoration");
    container.appendChild(this.el);
    const innerContainer = document.createElement("div");
    this.el.appendChild(innerContainer);
    this.root = (0, import_client2.createRoot)(innerContainer);
    this.root.render(
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(DefaultProviders, { app: plugin.app, plugin, children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Contents, { collectionID }) })
    );
  }
  unload() {
    var _a9;
    (_a9 = this.root) == null ? void 0 : _a9.unmount();
    this.el.remove();
  }
};
__name(_FileExplorerDecoration, "FileExplorerDecoration");
var FileExplorerDecoration = _FileExplorerDecoration;
var Contents = /* @__PURE__ */ __name(({ collectionID }) => {
  var _a9, _b2;
  const plugin = usePlugin();
  const collection = useLiveQuery(
    () => plugin.db.collections.get(collectionID),
    [plugin]
  );
  const teams = (_a9 = useLiveQuery(() => plugin.teams.get(), [plugin])) != null ? _a9 : [];
  const pendingCount = (_b2 = useLiveQuery(
    () => plugin.db.pendingLiveDocuments.where("collection_id").equals(collectionID).count(),
    [plugin, collectionID]
  )) != null ? _b2 : 0;
  const memberCount = useObservable(
    plugin.collections.collectionSizes.pipe(
      map((sizes) => {
        var _a10;
        return (_a10 = sizes[collectionID]) != null ? _a10 : 0;
      })
    ),
    0,
    [plugin, collectionID]
  );
  const pct = memberCount === 0 ? 100 : Math.floor(100 * memberCount / (pendingCount + memberCount));
  const label = (0, import_react6.useMemo)(() => {
    if (!collection) return;
    const team = teams.find((t) => t.id === collection.team_id);
    if (team && teams.length > 1) {
      return intl.fileExplorer.withTeam({
        team: team.name,
        collection: collection.name,
        pending: `${pendingCount}`
      });
    }
    return intl.fileExplorer.withoutTeam({
      collection: collection.name,
      pending: `${pendingCount}`
    });
  }, [collection, teams, collectionID, pendingCount]);
  (0, import_react6.useEffect)(() => {
    if (!collection) return;
    const tooltipEls = document.querySelectorAll(".tooltip");
    tooltipEls.forEach((el) => {
      if (label && el instanceof HTMLElement && el.innerText.contains(`${collection.name}
`)) {
        el.innerText = label;
      }
    });
  }, [collection, label]);
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "sg-collection-decoration-contents", "aria-label": label, children: /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("svg", { width: "12", height: "12", viewBox: "0 0 120 120", children: [
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      "circle",
      {
        cx: "60",
        cy: "60",
        r: "30",
        fill: "none",
        stroke: "var(--text-muted)",
        strokeWidth: "60",
        transform: "rotate(-90 60 60)"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      "circle",
      {
        strokeDasharray: "100",
        strokeDashoffset: 100 - pct,
        cx: "60",
        cy: "60",
        r: "30",
        fill: "none",
        stroke: "#20B03F",
        strokeWidth: "60",
        pathLength: "100",
        transform: "rotate(-90 60 60)"
      }
    )
  ] }) });
}, "Contents");

// src/services/views/file-explorer/FileExplorerDecorator.ts
var _FileExplorerDecorator = class _FileExplorerDecorator {
  constructor(plugin) {
    this.plugin = plugin;
    this.decorations = /* @__PURE__ */ new Map();
    this.plugin.app.workspace.onLayoutReady(() => {
      this.update(
        this.plugin.collections.fastCollectionSettings,
        this.plugin.settings.config
      );
    });
    this.plugin.registerEvent(
      plugin.app.workspace.on("layout-change", () => {
        this.update(
          this.plugin.collections.fastCollectionSettings,
          this.plugin.settings.config
        );
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.vault.on("rename", (file, oldPath) => {
        const decoration = this.decorations.get(oldPath);
        if (decoration) {
          this.decorations.delete(oldPath);
          this.decorations.set(file.path, decoration);
        }
      })
    );
    this.plugin.settings.subscribe((settings) => {
      this.update(this.plugin.collections.fastCollectionSettings, settings);
    });
    this.subscription = this.plugin.collections.collectionsSettingsObservable.subscribe({
      next: /* @__PURE__ */ __name((settings) => {
        this.update(settings, this.plugin.settings.config);
      }, "next")
    });
  }
  onunload() {
    this.subscription.unsubscribe();
  }
  update(collections, settings) {
    uniqBy_default(
      this.plugin.app.workspace.getLeavesOfType("file-explorer"),
      "view"
    ).forEach((leaf) => this.decorate(leaf, collections, settings));
  }
  decorate(leaf, collections, settings) {
    var _a9, _b2;
    const showLines = (_a9 = settings == null ? void 0 : settings.showFolderLines) != null ? _a9 : true;
    const showIcons = (_b2 = settings == null ? void 0 : settings.showFolderIcons) != null ? _b2 : true;
    const fileItems = leaf.view && typeof leaf.view === "object" ? leaf.view.fileItems : null;
    const items = fileItems !== null && typeof fileItems === "object" ? fileItems : {};
    collections.filter(({ mount_path }) => mount_path in items).forEach(({ mount_path, collection_id }) => {
      const item = items[mount_path];
      if (!item) return;
      const el = item.el;
      const selfEl = item.selfEl;
      const decoration = this.decorations.get(mount_path);
      el.classList.add("sg-mounted-collection");
      el.dataset.sgCollectionId = collection_id;
      if (showLines) {
        el.classList.add("sg-collection-highlighted");
      } else {
        el.classList.remove("sg-collection-highlighted");
      }
      if (decoration && decoration.container === selfEl) {
        if (!showIcons) {
          this.remove(mount_path);
        }
        return;
      }
      const decorationEl = selfEl.querySelector(
        ".sg-mounted-collection-decoration"
      );
      if (decorationEl) {
        if (!showIcons) {
          decorationEl.remove();
          const d2 = this.decorations.get(mount_path);
          d2 == null ? void 0 : d2.unload();
          this.decorations.delete(mount_path);
        }
        return;
      }
      if (!showIcons) return;
      const newDecoration = new FileExplorerDecoration(
        this.plugin,
        selfEl,
        collection_id
      );
      this.decorations.set(mount_path, newDecoration);
    });
    const handledPaths = new Set(collections.map((c) => c.mount_path));
    this.decorations.forEach((decoration, mount_path) => {
      if (handledPaths.has(mount_path)) return;
      this.remove(mount_path);
      const el = leaf.view.containerEl.querySelector(
        `.sg-mounted-collection[data-sg-collection-id="${decoration.collectionID}"]`
      );
      if (el && el instanceof HTMLElement) {
        el.classList.remove("sg-mounted-collection");
        el.classList.remove("sg-collection-highlighted");
        delete el.dataset.sgCollectionId;
      }
    });
  }
  remove(path) {
    const decoration = this.decorations.get(path);
    if (!decoration) return;
    decoration.unload();
    this.decorations.delete(path);
  }
};
__name(_FileExplorerDecorator, "FileExplorerDecorator");
var FileExplorerDecorator = _FileExplorerDecorator;

// src/services/views/home/index.ts
init_process_shim();

// src/services/views/home/HomeView.tsx
init_process_shim();

// src/services/views/mount-collection/index.ts
init_process_shim();

// src/services/views/mount-collection/MountCollectionModal.tsx
init_process_shim();

// src/services/views/FolderSuggest.ts
init_process_shim();
var import_obsidian13 = require("obsidian");
var _FolderSuggest = class _FolderSuggest extends import_obsidian13.FuzzySuggestModal {
  constructor(app, onChoose, filter2 = () => true, placeholder = "") {
    super(app);
    this.onChoose = onChoose;
    this.filter = filter2;
    this.setPlaceholder(placeholder);
    this.setInstructions([
      {
        command: "\u2191\u2193",
        purpose: intl.folderSuggest.upDownInstruction()
      },
      {
        command: "\u21B5",
        purpose: intl.folderSuggest.enterInstruction()
      },
      {
        command: "esc",
        purpose: intl.folderSuggest.escInstruction()
      }
    ]);
  }
  getItems() {
    return this.app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian13.TFolder && this.filter(f)).map((f) => f.path);
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item, evt) {
    const folder = this.app.vault.getFolderByPath(item);
    this.onChoose(folder);
  }
};
__name(_FolderSuggest, "FolderSuggest");
var FolderSuggest = _FolderSuggest;

// src/services/views/Icon.tsx
init_process_shim();
var import_classnames = __toESM(require_classnames());
var import_obsidian14 = require("obsidian");
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var Icon = /* @__PURE__ */ __name(({
  name,
  size: size2 = "var(--icon-xs)",
  className,
  ...rest
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
    "span",
    {
      ref: (el) => el && (0, import_obsidian14.setIcon)(el, name),
      className: (0, import_classnames.default)(
        "sg-icon inline-flex items-center justify-center",
        className
      ),
      style: {
        width: size2,
        height: size2
      },
      ...rest
    },
    name
  );
}, "Icon");

// src/services/views/LoadingIndicator.tsx
init_process_shim();
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var LoadingIndicator = /* @__PURE__ */ __name(() => /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "text-white", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Icon, { name: "loader-2", className: "animate-spin", size: "var(--icon-s)" }) }), "LoadingIndicator");

// src/services/views/Modal.tsx
init_process_shim();
var import_obsidian15 = require("obsidian");
var import_client3 = __toESM(require_client());
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var _Modal = class _Modal extends import_obsidian15.Modal {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
    this.root = null;
  }
  createRoot(children) {
    this.root = (0, import_client3.createRoot)(this.contentEl);
    this.root.render(
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(DefaultProviders, { app: this.app, plugin: this.plugin, children })
    );
  }
  async onClose() {
    var _a9, _b2;
    (_a9 = this.root) == null ? void 0 : _a9.unmount();
    (_b2 = this.contentEl) == null ? void 0 : _b2.empty();
  }
};
__name(_Modal, "Modal");
var Modal = _Modal;

// src/services/views/mount-collection/BoxOption.tsx
init_process_shim();
var import_classnames2 = __toESM(require_classnames());
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var BoxOption = /* @__PURE__ */ __name(({
  title,
  icon,
  description,
  selected,
  enabled = true,
  onClick
}) => /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(
  "div",
  {
    onClick: enabled ? onClick : void 0,
    className: (0, import_classnames2.default)(
      "flex flex-row items-center rounded-md border-solid border border-accent hover:border-accent-1 p-1",
      { "bg-accent text-on-accent": selected },
      { "cursor-pointer": !selected },
      { "border-muted hover:border-muted text-muted": !enabled }
    ),
    children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Icon, { name: icon, size: "var(--icon-xl)", className: "ml-3 mr-4" }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "flex flex-col", children: [
        /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("h3", { className: "py-1 m-0", children: title }),
        /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("p", { className: "py-1 m-0", children: description })
      ] })
    ]
  }
), "BoxOption");

// src/services/views/mount-collection/CollectionPrivacy.tsx
init_process_shim();
var import_classnames3 = __toESM(require_classnames());
var import_react7 = __toESM(require_react());
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var CollectionPrivacy = /* @__PURE__ */ __name(({
  privacy,
  team,
  didUpdate
}) => {
  const plugin = usePlugin();
  const { isPrivate, users, groups } = privacy;
  const justMe = isPrivate && users.length === 0 && groups.length === 0;
  const initialSelection = (() => {
    if (!isPrivate) {
      return "team";
    } else if (isPrivate && !justMe) {
      return "people";
    } else {
      return "me";
    }
  })();
  const [selection, setSelection] = (0, import_react7.useState)(
    initialSelection
  );
  const [searchUsers, setSearchUsers] = (0, import_react7.useState)([]);
  const [searchGroups, setSearchGroups] = (0, import_react7.useState)([]);
  const [query, setQuery] = (0, import_react7.useState)("");
  const [debouncedQuery, setDebouncedQuery] = (0, import_react7.useState)(query);
  (0, import_react7.useEffect)(() => {
    const handler = setTimeout(() => {
      setDebouncedQuery(query);
    }, 200);
    return () => {
      clearTimeout(handler);
    };
  }, [query]);
  (0, import_react7.useEffect)(() => {
    if (debouncedQuery && debouncedQuery.length > 1) {
      plugin.teams.searchUsers(debouncedQuery, team).then(
        (results) => {
          var _a9;
          return setSearchUsers(
            (_a9 = results == null ? void 0 : results.filter((u) => {
              var _a10;
              return u.id !== ((_a10 = plugin.account.get()) == null ? void 0 : _a10.id);
            })) != null ? _a9 : []
          );
        }
      );
      plugin.teams.searchGroups(debouncedQuery, team).then((results) => setSearchGroups(results != null ? results : []));
    } else {
      setSearchUsers([]);
      setSearchGroups([]);
    }
  }, [plugin, debouncedQuery, team, setSearchUsers, setSearchGroups]);
  const toggleUser = (0, import_react7.useCallback)(
    (u) => {
      if (privacy.users.find((usr) => usr.id === u.id)) {
        setSearchUsers([u, ...searchUsers]);
        didUpdate({
          ...privacy,
          users: privacy.users.filter((usr) => usr.id !== u.id)
        });
      } else {
        setSearchUsers(searchUsers.filter((su) => su.id !== u.id));
        didUpdate({ ...privacy, users: [u, ...privacy.users] });
      }
    },
    [privacy, searchUsers, setSearchUsers]
  );
  const toggleGroup = (0, import_react7.useCallback)(
    (g) => {
      if (privacy.groups.find((grp) => grp.id === g.id)) {
        setSearchGroups([g, ...searchGroups]);
        didUpdate({
          ...privacy,
          groups: privacy.groups.filter((grp) => grp.id !== g.id)
        });
      } else {
        setSearchGroups(searchGroups.filter((su) => su.id !== g.id));
        didUpdate({ ...privacy, groups: [g, ...privacy.groups] });
      }
    },
    [privacy, searchGroups, setSearchGroups]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex flex-col gap-y-2", children: [
    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
      BoxOption,
      {
        title: intl.mountModal.privacy.team.title(),
        icon: "shield-check",
        description: intl.mountModal.privacy.team.description({
          team: team.name
        }),
        selected: selection === "team",
        onClick: () => {
          setSelection("team");
          didUpdate({ isPrivate: false, users: [], groups: [] });
        }
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
      BoxOption,
      {
        title: intl.mountModal.privacy.people.title(),
        icon: "users",
        description: intl.mountModal.privacy.people.description(),
        selected: selection === "people",
        onClick: () => {
          setSelection("people");
          didUpdate({ isPrivate: true, users: [], groups: [] });
        }
      }
    ),
    selection === "people" && /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex flex-col gap-2", children: [
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
        "input",
        {
          autoFocus: true,
          type: "search",
          "aria-expanded": "false",
          "aria-controls": "options",
          placeholder: intl.mountModal.privacy.searchPlaceholder(),
          className: "w-full",
          onChange: (e) => setQuery(e.target.value)
        }
      ),
      (users.length > 0 || groups.length > 0) && /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex flex-col gap-2", children: [
        groups.map((u) => /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
          CollectionGroup,
          {
            group: u,
            actionTitle: intl.mountModal.privacy.remove(),
            onAction: toggleGroup,
            selected: true
          },
          `selected-${u.id}`
        )),
        users.map((u) => /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
          CollectionUser,
          {
            user: u,
            isYou: false,
            actionTitle: intl.mountModal.privacy.remove(),
            onAction: toggleUser,
            selected: true
          },
          `selected-${u.id}`
        )),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "border border-solid border-base-30 w-full h-px" })
      ] }),
      searchGroups.map((g) => /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
        CollectionGroup,
        {
          group: g,
          actionTitle: intl.mountModal.privacy.add(),
          onAction: toggleGroup
        },
        `result-${g.id}`
      )),
      searchUsers.map((u) => /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
        CollectionUser,
        {
          user: u,
          isYou: false,
          actionTitle: intl.mountModal.privacy.add(),
          onAction: toggleUser
        },
        `result-${u.id}`
      ))
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
      BoxOption,
      {
        title: intl.mountModal.privacy.me.title(),
        icon: "users",
        description: intl.mountModal.privacy.me.description(),
        selected: selection === "me",
        onClick: () => {
          setSelection("me");
          didUpdate({ isPrivate: true, users: [], groups: [] });
        }
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("p", { className: "text-muted m-0", children: [
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { children: intl.mountModal.privacy.warning1() }),
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { className: "italic", children: intl.mountModal.privacy.see() }),
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { children: intl.mountModal.privacy.warning2() })
    ] })
  ] });
}, "CollectionPrivacy");
var CollectionUser = /* @__PURE__ */ __name(({
  user,
  isYou,
  actionTitle,
  onAction,
  selected = false
}) => {
  var _a9;
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
    MembershipResult,
    {
      name: (_a9 = user.name) != null ? _a9 : user.email,
      description: isYou ? intl.mountModal.privacy.you() : user.name ? user.email : intl.mountModal.privacy.member(),
      icon: "user",
      actionTitle,
      onAction: () => onAction(user),
      selected,
      danger: selected
    }
  );
}, "CollectionUser");
var CollectionGroup = /* @__PURE__ */ __name(({
  group,
  actionTitle,
  onAction,
  selected = false
}) => /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
  MembershipResult,
  {
    name: group.name,
    description: group.description,
    icon: "users",
    actionTitle,
    onAction: () => onAction(group),
    selected,
    danger: selected
  }
), "CollectionGroup");
var MembershipResult = /* @__PURE__ */ __name(({
  name,
  description,
  icon,
  actionTitle,
  onAction,
  selected = false,
  danger = false
}) => /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex flex-row items-center justify-between rounded-lg border border-solid border-base-30 p-1 hover:bg-base-10", children: [
  /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex flex-row items-center", children: [
    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
      Icon,
      {
        name: selected ? "check" : icon,
        size: "var(--icon-s)",
        className: (0, import_classnames3.default)("mx-2", {
          "text-brand": selected,
          "text-muted": !selected
        })
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "flex flex-col gap-1", children: [
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "font-bold m-0", children: name }),
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "text-muted m-0", children: description })
    ] })
  ] }),
  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
    "button",
    {
      className: (0, import_classnames3.default)(
        "mr-2 cursor-pointer",
        danger ? "mod-warning" : "mod-cta"
      ),
      onClick: onAction,
      children: actionTitle
    }
  )
] }), "MembershipResult");

// src/services/views/mount-collection/MountCollectionModal.tsx
var import_debug17 = __toESM(require_browser2());
var import_obsidian16 = require("obsidian");
var import_react8 = __toESM(require_react());
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var log12 = (0, import_debug17.default)("screen.garden:views:mount-modal");
async function showMountCollectionModal(plugin, where = null) {
  const existingCollections = await plugin.db.collections.toArray();
  new MountCollectionModal(plugin, existingCollections, where).open();
}
__name(showMountCollectionModal, "showMountCollectionModal");
var _MountCollectionModal = class _MountCollectionModal extends Modal {
  constructor(plugin, defaultCollections, where) {
    super(plugin);
    this.defaultCollections = defaultCollections;
    this.where = where;
  }
  onOpen() {
    this.setTitle(intl.mountModal.title());
    this.createRoot(
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        ModalContents,
        {
          defaultCollections: this.defaultCollections,
          where: this.where,
          close: () => this.close()
        }
      )
    );
  }
};
__name(_MountCollectionModal, "MountCollectionModal");
var MountCollectionModal = _MountCollectionModal;
function isNew(c) {
  if (!c) return false;
  return c.new;
}
__name(isNew, "isNew");
var ModalContents = /* @__PURE__ */ __name(({
  defaultCollections,
  where,
  close
}) => {
  var _a9, _b2;
  const plugin = usePlugin();
  const teams = plugin.teams.get();
  const whereHasKids = where !== null && ((_b2 = (_a9 = plugin.app.vault.getFolderByPath(where)) == null ? void 0 : _a9.children.length) != null ? _b2 : 0) > 0;
  const collections = useLiveQuery(
    () => plugin.db.collections.toArray(),
    [],
    defaultCollections
  );
  (0, import_react8.useEffect)(() => {
    if (!plugin.api.client) return;
    plugin.teams.loadTeams();
    plugin.collections.getAndStoreCollections(plugin.api.client);
  }, [plugin.api.client]);
  const [team, setTeam] = (0, import_react8.useState)(
    (teams == null ? void 0 : teams.length) === 1 ? teams[0] : null
  );
  const [target, setTarget] = (0, import_react8.useState)(null);
  const [privacy, setPrivacy] = (0, import_react8.useState)(null);
  const [loading, setLoading] = (0, import_react8.useState)(false);
  const [state, setState] = (0, import_react8.useState)(
    team ? "target" : "team"
  );
  const doMount = (0, import_react8.useCallback)(
    async (folder) => {
      if (!team || !target || !target.name || isNew(target) && !privacy)
        return;
      setLoading(true);
      log12("doing mount", team, target, folder);
      let collection;
      try {
        if (isNew(target)) {
          if (!privacy) {
            new import_obsidian16.Notice(intl.mountModal.noPrivacyNotice());
            close();
            return;
          }
          log12("new collection, creating");
          collection = await plugin.collections.create(
            target.name,
            team,
            privacy
          );
          if (!collection) {
            new import_obsidian16.Notice(intl.mountModal.createErrorNotice());
            return;
          }
        } else {
          collection = target;
        }
        if (await plugin.collections.mount(collection.id, folder.path)) {
          new import_obsidian16.Notice(intl.mountModal.successNotice());
          close();
        }
      } finally {
        setLoading(false);
      }
    },
    [close, plugin, team, privacy, target, loading]
  );
  const chooseTeam = (0, import_react8.useCallback)(
    (team2) => {
      setTeam(team2);
      setState("target");
    },
    [setTeam, setState]
  );
  const chooseTarget = (0, import_react8.useCallback)(
    (target2) => {
      setTarget(target2);
      setState(isNew(target2) ? "privacy" : "where");
    },
    [setTarget, setState]
  );
  const choosePrivacy = (0, import_react8.useCallback)(
    (privacy2) => {
      setPrivacy(privacy2);
      setState("where");
    },
    [setPrivacy, setState]
  );
  if (teams === null) return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("p", { children: intl.mountModal.loadTeamsError() });
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
      StateSummary,
      {
        team,
        target,
        privacy,
        canEditTarget: collections.length > 0,
        onEditTeam: () => setState("team"),
        onEditPrivacy: () => setState("privacy"),
        onEditTarget: () => setState("target")
      }
    ),
    state === "team" ? /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(TeamStep, { teams, chooseTeam }) : team && state === "target" ? /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
      TargetStep,
      {
        allowExisting: !whereHasKids,
        collections,
        team,
        chooseTarget
      }
    ) : team && state === "privacy" ? /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
      PrivacyStep,
      {
        team,
        privacy,
        choosePrivacy
      }
    ) : /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
      WhereStep,
      {
        initialValue: where,
        target,
        onCreate: doMount,
        loading
      }
    )
  ] });
}, "ModalContents");
var StateSummary = /* @__PURE__ */ __name(({
  team,
  target,
  privacy,
  canEditTarget,
  onEditTeam,
  onEditTarget,
  onEditPrivacy
}) => {
  const InlineTarget = /* @__PURE__ */ __name(({
    target: target2,
    editable,
    onClick
  }) => {
    if (editable)
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("a", { className: "font-bold", onClick, children: target2 == null ? void 0 : target2.name });
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { className: "font-bold", children: target2 == null ? void 0 : target2.name });
  }, "InlineTarget");
  if (!team) return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("p", { children: intl.mountModal.s.team() });
  if (!target)
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("p", { children: [
      intl.mountModal.s.target1(),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("a", { onClick: onEditTeam, children: team.name }),
      intl.mountModal.s.target2()
    ] });
  if (isNew(target)) {
    if (!privacy) {
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("p", { children: [
        intl.mountModal.s.summary.creating(),
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
          InlineTarget,
          {
            target,
            editable: canEditTarget,
            onClick: onEditTarget
          }
        ),
        intl.mountModal.s.summary.new({ affix: "" }),
        intl.mountModal.s.summary.collection(),
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("a", { onClick: onEditTeam, children: team.name }),
        intl.mountModal.s.summary.privacyQuestion()
      ] });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("p", { children: [
      intl.mountModal.s.summary.creating(),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        InlineTarget,
        {
          target,
          editable: canEditTarget,
          onClick: onEditTarget
        }
      ),
      intl.mountModal.s.summary.new({ affix: " " }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("a", { onClick: onEditPrivacy, children: privacy.isPrivate ? intl.mountModal.s.summary.private() : intl.mountModal.s.summary.team() }),
      intl.mountModal.s.summary.collection(),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("a", { onClick: onEditTeam, children: team.name }),
      intl.mountModal.s.summary.whereQuestion()
    ] });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("p", { children: [
    intl.mountModal.s.existing1(),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
      InlineTarget,
      {
        target,
        editable: canEditTarget,
        onClick: onEditTarget
      }
    ),
    intl.mountModal.s.existing2(),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("a", { onClick: onEditTeam, children: team.name }),
    intl.mountModal.s.existing3()
  ] });
}, "StateSummary");
var TeamStep = /* @__PURE__ */ __name(({
  teams,
  chooseTeam
}) => /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("ul", { children: teams.map((t) => /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("li", { className: "text-muted", children: [
  /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("a", { onClick: () => chooseTeam(t), children: t.name }),
  " (",
  t.short_id,
  ")"
] }, t.id)) }), "TeamStep");
var TargetStep = /* @__PURE__ */ __name(({
  allowExisting,
  collections,
  team,
  chooseTarget
}) => {
  var _a9, _b2;
  const plugin = usePlugin();
  const availableCollections = useLiveQuery(
    async () => {
      const settings = await plugin.db.collectionSettings.toArray();
      const mountedIDs = settings.map((s) => s.collection_id);
      const c = collections.filter((c2) => !mountedIDs.contains(c2.id) && c2.team_id === team.id).sort((a, b) => a.name.localeCompare(b.name));
      return c;
    },
    [collections],
    collections
  );
  const [showCollections, setShowCollections] = (0, import_react8.useState)(false);
  const [target, setTarget] = (0, import_react8.useState)(null);
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex flex-col gap-y-2 mb-2", children: [
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        BoxOption,
        {
          title: intl.mountModal.t.newTitle(),
          icon: "plus",
          description: intl.mountModal.t.newDesc(),
          selected: isNew(target),
          onClick: () => {
            setTarget({ new: true, name: null });
            setShowCollections(false);
          }
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        BoxOption,
        {
          title: intl.mountModal.t.existingTitle(),
          icon: "cable",
          description: intl.mountModal.t.existingDesc(),
          selected: showCollections,
          enabled: allowExisting && collections.length > 0,
          onClick: () => {
            setTarget(null);
            setShowCollections(true);
          }
        }
      )
    ] }),
    !allowExisting && !isNew(target) && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("p", { className: "text-muted italic", children: intl.mountModal.s.noExistingWarning() }),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex flex-row justify-between items-center gap-x-2 max-w-full", children: [
      showCollections ? /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(
        "select",
        {
          onChange: (e) => {
            var _a10;
            return setTarget(
              (_a10 = availableCollections.find((c) => c.id === e.target.value)) != null ? _a10 : null
            );
          },
          defaultValue: "default",
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("option", { disabled: true, value: "default", children: intl.mountModal.t.chooseDefault() }),
            availableCollections.map((c) => /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("option", { value: c.id, children: c.name }, c.id))
          ]
        }
      ) : isNew(target) ? /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        "input",
        {
          autoFocus: true,
          className: "w-full",
          type: "text",
          value: isNew(target) ? (_a9 = target.name) != null ? _a9 : "" : "",
          onChange: (e) => setTarget({ new: true, name: e.target.value }),
          placeholder: "Collection Name"
        }
      ) : /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", {}),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        "button",
        {
          className: "mod-cta",
          disabled: !target || isNew(target) && ((_b2 = target.name) != null ? _b2 : "").length === 0,
          onClick: () => chooseTarget(target),
          children: intl.mountModal.nextButton()
        }
      )
    ] })
  ] });
}, "TargetStep");
var PrivacyStep = /* @__PURE__ */ __name(({
  team,
  privacy,
  choosePrivacy
}) => {
  const [localPrivacy, setLocalPrivacy] = (0, import_react8.useState)(
    privacy != null ? privacy : DEFAULT_COLLECTION_PRIVACY
  );
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
      CollectionPrivacy,
      {
        team,
        privacy: localPrivacy,
        didUpdate: setLocalPrivacy
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "flex flex-row justify-end items-center w-full mt-2", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { className: "mod-cta", onClick: () => choosePrivacy(localPrivacy), children: intl.mountModal.nextButton() }) })
  ] });
}, "PrivacyStep");
var WhereStep = /* @__PURE__ */ __name(({
  initialValue,
  target,
  onCreate,
  loading
}) => {
  var _a9, _b2;
  const plugin = usePlugin();
  const f = initialValue ? plugin.app.vault.getFolderByPath(initialValue) : null;
  const [which, setWhich] = (0, import_react8.useState)(
    (f == null ? void 0 : f.isRoot()) ? "vault" : f ? "folder" : null
  );
  const [where, setWhere] = (0, import_react8.useState)(
    (f == null ? void 0 : f.isRoot()) ? "vault" : f
  );
  const vaultHasKids = ((_b2 = (_a9 = plugin.app.vault.getFolderByPath("/")) == null ? void 0 : _a9.children.length) != null ? _b2 : 0) > 0;
  const vaultDisabled = vaultHasKids && !isNew(target);
  const onClickFolder = (0, import_react8.useCallback)(() => {
    const filter2 = /* @__PURE__ */ __name((folder) => {
      return !plugin.collections.inMountedCollection(folder) && (isNew(target) || folder.children.length === 0);
    }, "filter");
    const onChooseFolder = /* @__PURE__ */ __name((folder) => {
      if (folder) {
        if (folder.isRoot()) {
          setWhich("vault");
          setWhere("vault");
        } else {
          setWhich("folder");
          setWhere(folder);
        }
      }
    }, "onChooseFolder");
    const f2 = new FolderSuggest(
      plugin.app,
      onChooseFolder,
      filter2,
      isNew(target) ? intl.mountModal.w.folderSuggestNewPlaceholder() : intl.mountModal.w.folderSuggestExistingPlaceholder()
    );
    f2.open();
  }, [plugin]);
  const providersForWhere = /* @__PURE__ */ __name((w) => {
    if (!w) return null;
    if (w === "vault") {
      return plugin.externalProviders.enabledProviders();
    }
    return plugin.externalProviders.enabledProvidersForPath(w.path);
  }, "providersForWhere");
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex flex-col gap-2 mb-2", children: [
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        BoxOption,
        {
          title: intl.mountModal.w.folderTitle(),
          icon: "folder",
          description: intl.mountModal.w.folderDesc(),
          selected: which === "folder",
          onClick: onClickFolder
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        BoxOption,
        {
          title: intl.mountModal.w.vaultTitle(),
          icon: "vault",
          description: intl.mountModal.w.vaultDesc(),
          selected: which === "vault",
          onClick: () => {
            setWhich("vault");
            setWhere("vault");
          },
          enabled: !vaultDisabled
        }
      )
    ] }),
    vaultDisabled && !where && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("p", { className: "text-muted italic", children: intl.mountModal.w.vaultNotAvailableWarning() }),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex flex-row justify-between items-center gap-x-2", children: [
      where instanceof import_obsidian16.TFolder ? /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("p", { children: [
        intl.mountModal.w.folderPrefix(),
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { className: "text-accent-2", children: where.path })
      ] }) : /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", {}),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
        "button",
        {
          className: "mod-cta",
          disabled: !where || loading,
          onClick: () => {
            const folder = where instanceof import_obsidian16.TFolder ? where : plugin.app.vault.getAbstractFileByPath("/");
            onCreate(folder);
          },
          children: loading ? /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(LoadingIndicator, {}) : isNew(target) ? intl.mountModal.createButton() : intl.mountModal.connectButton()
        }
      )
    ] }),
    providersForWhere(where) && /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex flex-row items-center", children: [
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "w-6", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Icon, { name: "info", className: "text-warning mr-2 mt-1" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("p", { className: "text-sm text-muted", children: intl.mountModal.w.externalProviderInfo({
        providers: providersForWhere(where)
      }) })
    ] })
  ] });
}, "WhereStep");

// src/services/views/home/ReauthControls.tsx
init_process_shim();
var import_react9 = __toESM(require_react());
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var ReauthControls = /* @__PURE__ */ __name(() => {
  const plugin = usePlugin();
  const [url, setURL] = (0, import_react9.useState)(null);
  const login = (0, import_react9.useCallback)(() => {
    plugin.account.startAuth("login", (url2) => {
      setURL(url2);
    });
  }, [plugin]);
  return /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(import_jsx_runtime10.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("p", { className: "text-red-600 text-lg", children: intl.home.reauthExplanation() }),
    /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { className: "flex flex-row", children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("button", { onClick: login, children: intl.settingsTab.loginButton() }) }),
    url && /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("p", { children: [
      intl.settingsTab.loginDetails1(),
      " ",
      /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("a", { href: url, target: "_blank", children: intl.settingsTab.loginDetails2() })
    ] })
  ] });
}, "ReauthControls");

// src/services/views/home/overview/Overview.tsx
init_process_shim();
var import_react10 = __toESM(require_react());

// src/util/hues.ts
init_process_shim();
var TOTAL_HUES = 256;
var toHue = /* @__PURE__ */ __name((id2) => {
  return Number(
    BigInt(`0x${id2.replace(/[^0-9a-f]/gi, "")}`) % BigInt(TOTAL_HUES)
  );
}, "toHue");

// src/services/views/home/overview/Overview.tsx
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var Overview = /* @__PURE__ */ __name(() => {
  const plugin = usePlugin();
  const collectionsWithPaths = useLiveQuery(async () => {
    const settings = await plugin.db.collectionSettings.toArray();
    const withPathsOrNull = await Promise.all(
      settings.map(async (s) => {
        const c = await plugin.db.collections.get(s.collection_id);
        if (!c) return null;
        const team = await plugin.db.teams.get(c.team_id);
        return {
          id: c.id,
          name: c.name,
          path: s.mount_path,
          short_id: c.short_id,
          team_short_id: team == null ? void 0 : team.short_id
        };
      })
    );
    return withPathsOrNull.filter((v) => v !== null);
  }, [plugin]);
  const rootCollection = (0, import_react10.useMemo)(() => {
    var _a9;
    return (_a9 = collectionsWithPaths == null ? void 0 : collectionsWithPaths.find((c) => (c == null ? void 0 : c.path) === "/")) != null ? _a9 : null;
  }, [collectionsWithPaths]);
  const needsReauth = useObservable(
    from(plugin.settings.observable).pipe(
      map((settings) => {
        var _a9;
        return (_a9 = settings == null ? void 0 : settings.needsReauth) != null ? _a9 : false;
      })
    ),
    false,
    [plugin]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { children: [
    needsReauth && /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(ReauthControls, {}),
    /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { className: "flex flex-row flex-wrap items-center gap-1 mr-2", children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("h4", { className: "small-caps m-1 pb-1", children: intl.home.collectionsHeader() }) }),
    collectionsWithPaths && /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-2 mb-4", children: collectionsWithPaths.map(
      // TypeScript makes me do this. It's probably fixed in a newer version.
      // Will update ts later and remove this comment.
      (c) => c && /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
        CollectionCard,
        {
          id: c.id,
          name: c.name,
          path: c.path,
          short_id: c.short_id,
          team_short_id: c.team_short_id
        },
        c.id
      )
    ) }),
    rootCollection ? /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("p", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("span", { children: intl.home.hasRootVault({ collection_name: rootCollection.name }) }),
      "\xA0",
      /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("a", { href: "https://screen.garden/faq#full-vault-sync", children: intl.home.hasRootVaultLearnMore() })
    ] }) : /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
      "button",
      {
        className: "mod-cta",
        onClick: () => showMountCollectionModal(plugin),
        children: intl.home.addCollection()
      }
    )
  ] });
}, "Overview");
function usePresence(docId, getMetas) {
  const [metas, setMetas] = (0, import_react10.useState)(null);
  const plugin = usePlugin();
  (0, import_react10.useEffect)(() => {
    const callback = /* @__PURE__ */ __name((id2) => {
      if (id2 !== docId) return;
      setMetas(getMetas());
    }, "callback");
    const listener = plugin.docs.on(`presence:${docId}`, callback);
    return () => plugin.docs.offref(listener);
  }, [docId]);
  return metas;
}
__name(usePresence, "usePresence");
var CollectionCard = /* @__PURE__ */ __name(({
  id: id2,
  name,
  path,
  short_id,
  team_short_id
}) => {
  const plugin = usePlugin();
  const onClick = /* @__PURE__ */ __name(async () => {
    var _a9;
    const leaf = plugin.app.workspace.getLeavesOfType("file-explorer").first();
    if (!leaf) return;
    await plugin.app.workspace.revealLeaf(leaf);
    const file = plugin.app.vault.getFolderByPath(path);
    (_a9 = plugin.app.internalPlugins.getEnabledPluginById("file-explorer")) == null ? void 0 : _a9.revealInFolder(file);
  }, "onClick");
  const presences = usePresence(
    id2,
    () => plugin.collections.presenceForCollection(id2)
  );
  const sortedPresences = (0, import_react10.useMemo)(() => {
    const byNote = presences == null ? void 0 : presences.filter((p) => {
      var _a9;
      return p.user_id !== ((_a9 = plugin.account.get()) == null ? void 0 : _a9.id);
    }).reduce((acc, p) => {
      var _a9, _b2;
      for (const note of (_a9 = p.notes) != null ? _a9 : []) {
        const noteUsers = (_b2 = acc[note.id]) != null ? _b2 : [];
        noteUsers.push({
          user_id: p.user_id,
          user_name: p.user_name,
          active: note.active
        });
        acc[note.id] = noteUsers;
      }
      return acc;
    }, {});
    return sortBy_default(
      Object.entries(byNote != null ? byNote : {}).map(([id3, users]) => ({
        id: id3,
        users: [...users].sort((a, b) => {
          if (a.active) return -1;
          if (b.active) return 1;
          return a.user_id < b.user_id ? -1 : 1;
        })
      })),
      ["id"]
    );
  }, [plugin, presences]);
  return /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { className: "group flex flex-col border border-solid border-base-40 hover:border-accent rounded p-2", children: [
    /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)(
      "div",
      {
        className: "flex flex-row items-center justify-between ",
        onClick,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { className: "flex flex-col", children: [
            /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("h5", { className: "p-0 m-0 mb-1", children: name }),
            /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("p", { className: "text-muted text-sm m-0 p-0", children: path === "/" ? intl.home.collectionCard.vault() : `/${path}` })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { className: "flex flex-col gap-2 items-center justify-center", children: [
            /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
                Icon,
                {
                  name: "folder-closed",
                  size: "var(--icon-l)",
                  className: "block group-hover:hidden"
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
                Icon,
                {
                  name: "folder-open",
                  size: "var(--icon-l)",
                  className: "hidden group-hover:block group-hover:text-accent mb-1"
                }
              )
            ] }),
            team_short_id && /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
              "a",
              {
                href: `${BASE_HTTP_URL}/t/${team_short_id}/c/${short_id}/edit`,
                className: "text-normal cursor-pointer rounded-full w-6 h-6 hover:bg-accent hover:text-on-accent flex items-center justify-center",
                "aria-label": intl.home.collectionCard.editLabel({ name }),
                children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Icon, { name: "cog", size: "var(--icon-l)" })
              }
            )
          ] })
        ]
      }
    ),
    sortedPresences && sortedPresences.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { className: "flex flex-col gap-1", children: [
      /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { className: "h-px w-full bg-base-40 my-1" }),
      /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("h6", { className: "font-extrabold text-xs text-muted uppercase my-0", children: intl.home.collectionCard.activeCollaborators() }),
      sortedPresences.map((p) => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(ActiveNote, { id: p.id, users: p.users }, p.id))
    ] })
  ] });
}, "CollectionCard");
var ActiveNote = /* @__PURE__ */ __name(({ id: id2, users }) => {
  const plugin = usePlugin();
  const note = useLiveQuery(() => plugin.db.liveDocuments.get(id2), [id2]);
  const openNote = (0, import_react10.useCallback)(() => {
    if (!note) return;
    plugin.app.workspace.openLinkText(note.path, "/", true);
  }, [plugin, note]);
  return (note == null ? void 0 : note.path) ? /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)(
    "div",
    {
      className: "flex flex-row gap-2 items-center hover:bg-base-10 rounded-sm",
      onClick: openNote,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(FaceStack, { users }),
        /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("span", { className: "font-bold", children: getTitle(note.path) })
      ]
    }
  ) : /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", {});
}, "ActiveNote");
var FaceStack = /* @__PURE__ */ __name(({ users }) => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { className: "flex flex-row mr-3", children: users.slice(0, 10).map((user, i) => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Face, { z: 10 - i, user }, i)) }), "FaceStack");
var Face = /* @__PURE__ */ __name(({ z, user }) => {
  var _a9;
  const hue = toHue(user.user_id);
  const bg = user.active ? `hsl(${hue}, 50%, 50%)` : `hsl(${hue}, 10%, 30%)`;
  const name = (_a9 = user.user_name) != null ? _a9 : intl.home.collectionCard.anonymous();
  return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
    "div",
    {
      className: "rounded-full h-6 w-6 overflow-clip mr-[-0.75rem] border border-solid border-base-80 text-base-80 flex items-center justify-center",
      style: { zIndex: z, backgroundColor: bg },
      "aria-label": user.active ? intl.home.collectionCard.editing({ name }) : intl.home.collectionCard.viewing({ name }),
      children: user.user_name ? initialize(user.user_name) : /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Icon, { name: "user", className: "w-3 h-3" })
    }
  );
}, "Face");
function initialize(name) {
  return name.split(" ").map((n) => n[0].toUpperCase()).join("");
}
__name(initialize, "initialize");

// src/services/views/home/HomeView.tsx
var import_obsidian17 = require("obsidian");
var import_react11 = __toESM(require_react());
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
var _HomeView = class _HomeView extends View {
  static LeafIn(workspace) {
    return workspace.getLeaf(true);
  }
  getDisplayText() {
    return "screen.garden";
  }
  getIcon() {
    return "leaf";
  }
  async onOpen() {
    this.createRoot(/* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Home, {}));
  }
};
__name(_HomeView, "HomeView");
_HomeView.ViewType = /* @__PURE__ */ __name(() => "screengarden:views:home" /* Home */, "ViewType");
var HomeView = _HomeView;
var Home = /* @__PURE__ */ __name(() => {
  const plugin = usePlugin();
  const account = useObservable(plugin.account.observable, void 0, [plugin]);
  const updateRequired = useObservable(plugin.socket.updateRequired, false, [
    plugin
  ]);
  const newVersionReleaseNotes = useObservable(
    plugin.settings.updateAvailableObservable,
    null,
    [plugin]
  );
  const collectionSettings = useObservable(
    plugin.collections.collectionsSettingsObservable,
    [],
    [plugin]
  );
  const onboarded = collectionSettings.length > 0;
  const view = (0, import_react11.useMemo)(() => {
    if (!account) return "login";
    if (!onboarded) return "onboarding";
    return "overview";
  }, [account, onboarded]);
  const openSettings = (0, import_react11.useCallback)(async () => {
    const setting = plugin.app.setting;
    await setting.open();
    await setting.openTabById("community-plugins");
  }, [plugin]);
  return /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { className: "mx-auto max-w-[var(--file-line-width)]", children: [
    /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("h1", { children: [
      "screen",
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("span", { className: "text-brand", children: "." }),
      "garden"
    ] }),
    updateRequired ? /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("p", { className: "text-warning", children: [
      intl.home.updateRequired.pre(),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("a", { onClick: openSettings, children: intl.home.updateRequired.link() }),
      intl.home.updateRequired.post()
    ] }) : newVersionReleaseNotes ? /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(NewVersionAvailable, { releaseNotes: newVersionReleaseNotes }) : /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(import_jsx_runtime12.Fragment, {}),
    view === "login" && /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(LogIn, {}),
    view === "onboarding" && /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Onboarding, {}),
    view === "overview" && /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Overview, {})
  ] });
}, "Home");
var LogIn = /* @__PURE__ */ __name(() => {
  const plugin = usePlugin();
  const [url, setURL] = (0, import_react11.useState)(null);
  const login = (0, import_react11.useCallback)(() => {
    plugin.account.startAuth("login", (url2) => {
      setURL(url2);
    });
  }, [plugin]);
  const register = (0, import_react11.useCallback)(() => {
    plugin.account.startAuth("register", (url2) => {
      setURL(url2);
    });
  }, [plugin]);
  return /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)(import_jsx_runtime12.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("p", { children: intl.settingsTab.accountSettingsDesc() }),
    /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { className: "flex flex-row gap-2", children: [
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("button", { className: "mod-cta", onClick: register, children: intl.settingsTab.createAccountButton() }),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("button", { onClick: login, children: intl.settingsTab.loginButton() })
    ] }),
    url && /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("p", { children: [
      intl.settingsTab.loginDetails1(),
      " ",
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("a", { href: url, target: "_blank", children: intl.settingsTab.loginDetails2() })
    ] })
  ] });
}, "LogIn");
var Onboarding = /* @__PURE__ */ __name(() => {
  var _a9;
  const plugin = usePlugin();
  const collections = useObservable(
    plugin.collections.availableCollectionsObservable,
    [],
    [plugin]
  );
  const teams = (_a9 = plugin.teams.get()) != null ? _a9 : [];
  const needsReauth = useObservable(
    from(plugin.settings.observable).pipe(
      map((settings) => {
        var _a10;
        return (_a10 = settings == null ? void 0 : settings.needsReauth) != null ? _a10 : false;
      })
    ),
    false,
    [plugin]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)(import_jsx_runtime12.Fragment, { children: [
    needsReauth && /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(ReauthControls, {}),
    /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("p", { children: [
      intl.home.welcome(),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("span", { className: "live-cursors-example", children: intl.home.welcomeCursors() })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("p", { children: [
      intl.home.startPrefix(),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("span", { className: "font-bold", children: intl.home.collection() }),
      intl.home.startSuffix()
    ] }),
    collections.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("div", { className: "border-l-8 border-solid border-accent rounded p-1 mb-4", children: /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("p", { children: [
      intl.home.collectionsAvailable1({ teams, collections }),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("span", { className: "font-bold", children: intl.home.addCollection() }),
      intl.home.collectionsAvailable2()
    ] }) }),
    /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
      "button",
      {
        className: "mod-cta",
        onClick: () => showMountCollectionModal(plugin),
        children: intl.home.addCollection()
      }
    )
  ] });
}, "Onboarding");
var NewVersionAvailable = /* @__PURE__ */ __name(({ releaseNotes }) => {
  const plugin = usePlugin();
  const openSettings = (0, import_react11.useCallback)(async () => {
    const setting = plugin.app.setting;
    await setting.open();
    await setting.openTabById("community-plugins");
  }, [plugin]);
  const markdownEl = (0, import_react11.useRef)(null);
  (0, import_react11.useEffect)(() => {
    if (markdownEl.current) {
      const component = new import_obsidian17.Component();
      import_obsidian17.MarkdownRenderer.render(
        plugin.app,
        releaseNotes,
        markdownEl.current,
        "sg_release_notes.md",
        component
      );
      return () => {
        if (markdownEl.current) {
          markdownEl.current.innerHTML = "";
        }
        component.unload();
      };
    }
  }, [plugin.app, releaseNotes, markdownEl]);
  return /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("p", { className: "text-muted", children: [
      intl.home.newVersionAvailable.pre(),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("a", { onClick: openSettings, children: intl.home.newVersionAvailable.link() })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("details", { className: "border-accent border-solid border rounded-md p-2", children: [
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("summary", { className: "text-accent hover:underline cursor-pointer", children: intl.home.newVersionAvailable.summary() }),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("p", { ref: markdownEl })
    ] })
  ] });
}, "NewVersionAvailable");

// src/services/views/note/ActionDecoration.tsx
init_process_shim();

// src/services/editor/utils.ts
init_process_shim();
function absolutePositionFromCursor(ytext, cursor) {
  const ydoc = ytext.doc;
  const anchor = createAbsolutePositionFromRelativePosition(
    cursor.anchor,
    ydoc
  );
  const head = createAbsolutePositionFromRelativePosition(cursor.head, ydoc);
  if (!anchor || !head || anchor.type !== ytext || head.type !== ytext)
    return null;
  const start = min(anchor.index, head.index);
  const end = max(anchor.index, head.index);
  return { start, end, anchor, head };
}
__name(absolutePositionFromCursor, "absolutePositionFromCursor");

// src/services/views/note/NoteViewDecoration.ts
init_process_shim();
var _NoteViewDecoration = class _NoteViewDecoration {
  constructor(plugin, view, path) {
    this.plugin = plugin;
    this.path = path;
  }
};
__name(_NoteViewDecoration, "NoteViewDecoration");
var NoteViewDecoration = _NoteViewDecoration;

// src/services/views/note/ActionDecoration.tsx
var import_classnames4 = __toESM(require_classnames());
var import_obsidian18 = require("obsidian");
var import_client4 = __toESM(require_client());

// src/services/liveDocuments/index.ts
init_process_shim();

// src/services/views/note/ActionDecoration.tsx
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
var _ActionDecoration = class _ActionDecoration extends NoteViewDecoration {
  constructor(plugin, view, path) {
    var _a9, _b2;
    super(plugin, view, path);
    this.root = null;
    this.note = null;
    this.collection = null;
    this.team = null;
    const container = view.containerEl.querySelector(".view-actions");
    this.el = document.createElement("button");
    container.prepend(this.el);
    this.el.classList.add("clickable-icon", "view-action", "sg-view-action");
    this.el.ariaLabel = "";
    this.el.dataset.tooltipPosition = "bottom";
    this.el.onclick = () => this.showMenu();
    this.root = (0, import_client4.createRoot)(this.el);
    this.root.render(
      /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(DefaultProviders, { app: plugin.app, plugin, children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(CircleIndicator, {}) })
    );
    this.noteAtPathObservable = liveQuery(
      () => this.plugin.db.liveDocuments.where({ path }).first()
    );
    this.noteAtPathSubscription = this.noteAtPathObservable.subscribe({
      next: /* @__PURE__ */ __name(() => {
        this.loadFileData(this.path);
      }, "next")
    });
    this.loadFileData(this.path);
    this.connectedSubscription = this.plugin.socket.connected.subscribe({
      next: this.setAriaLabel.bind(this)
    });
    this.setAriaLabel((_b2 = (_a9 = this.plugin.socket.socket) == null ? void 0 : _a9.isConnected()) != null ? _b2 : false);
  }
  unload() {
    var _a9;
    this.noteAtPathSubscription.unsubscribe();
    this.connectedSubscription.unsubscribe();
    (_a9 = this.root) == null ? void 0 : _a9.unmount();
    this.el.remove();
  }
  async loadFileData(path) {
    const data = await this.plugin.collections.dataForFile(path);
    if (!data) {
      this.el.ariaLabel = "";
      return;
    }
    this.team = data.team;
    this.collection = data.collection;
    this.note = data.liveDocument;
  }
  setAriaLabel(connected) {
    if (connected) {
      this.el.ariaLabel = intl.viewAction.connected();
    } else {
      this.el.ariaLabel = intl.viewAction.disconnected();
    }
  }
  showMenu() {
    var _a9;
    const file = this.plugin.app.vault.getAbstractFileByPath(this.path);
    if (!file || !this.note || !this.collection || !this.team) return;
    const note = this.note;
    const collection = this.collection;
    const team = this.team;
    const me = (_a9 = this.plugin.account.get()) == null ? void 0 : _a9.id;
    const collaborators = this.plugin.liveDocuments.listPresences(note.id).filter((presence) => presence.userID !== me).filter((presence) => !!presence.name);
    const menu = new import_obsidian18.Menu();
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle("screen.garden");
      item.setIsLabel(true);
    });
    menu.addSeparator();
    menu.addItem((item) => {
      var _a10;
      item.setTitle(
        intl.viewAction.menu.collection({ collection: (_a10 = this.collection) == null ? void 0 : _a10.name })
      );
      item.setIsLabel(true);
    });
    menu.addItem((item) => {
      var _a10;
      item.setTitle(intl.viewAction.menu.team({ team: (_a10 = this.team) == null ? void 0 : _a10.name }));
      item.setIsLabel(true);
    });
    menu.addSeparator();
    if (collaborators.length > 0) {
      menu.addItem((item) => {
        item.setTitle(
          intl.viewAction.menu.collaboratorCount({
            count: collaborators.length
          })
        );
        const submenu = item.setSubmenu();
        submenu.addItem((item2) => {
          item2.setTitle(intl.viewAction.menu.collaboratorLabel());
          item2.setIsLabel(true);
        });
        collaborators.forEach((collaborator) => {
          submenu.addItem((item2) => {
            item2.setTitle(collaborator.name);
            item2.onClick(() => {
              const { cursor } = collaborator;
              if (!cursor || !cursor.anchor || !cursor.head) return;
              const handler = this.plugin.liveDocuments.getHandlerOfType(
                NoteHandler,
                note.id
              );
              const ytext = handler == null ? void 0 : handler.borrowYText();
              if (!ytext) return;
              const absPos = absolutePositionFromCursor(ytext, cursor);
              if (!absPos) return;
              const { start } = absPos;
              this.moveCursorTo(start);
            });
          });
        });
      });
      menu.addSeparator();
    }
    menu.addItem((item) => {
      item.setTitle(intl.viewAction.menu.web());
      item.setIcon("globe");
      item.onClick(() => {
        window.open(noteURL(team, collection, note), "_blank");
      });
    });
    menu.addItem((item) => {
      item.setTitle(intl.viewAction.menu.copyURL());
      item.setIcon("clipboard-copy");
      item.onClick(() => copyNoteURLToClipboard(team, collection, note));
    });
    const { x, y, width, height } = this.el.getBoundingClientRect();
    menu.showAtPosition({ x: x + Math.floor(width / 2), y: y + height + 4 });
  }
  moveCursorTo(ch) {
    this.plugin.app.workspace.getLeavesOfType("markdown").find((l) => {
      var _a9;
      if (l.view instanceof import_obsidian18.MarkdownView && ((_a9 = l.view.file) == null ? void 0 : _a9.path) === this.path) {
        l.view.editor.setCursor(ch);
      }
    });
  }
};
__name(_ActionDecoration, "ActionDecoration");
var ActionDecoration = _ActionDecoration;
var CircleIndicator = /* @__PURE__ */ __name(() => {
  var _a9, _b2;
  const plugin = usePlugin();
  const isConnected = useObservable(
    plugin.socket.connected,
    (_b2 = (_a9 = plugin.socket.socket) == null ? void 0 : _a9.isConnected()) != null ? _b2 : false,
    [plugin]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("div", { className: "flex flex-row items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
    "div",
    {
      className: (0, import_classnames4.default)("rounded-full w-3 h-3", {
        "bg-brand": isConnected,
        "bg-slate-500": !isConnected
      })
    }
  ) });
}, "CircleIndicator");

// src/services/views/note/NoteViewDecorator.ts
init_process_shim();
var _NoteViewDecorator = class _NoteViewDecorator {
  // private log: ReturnType<typeof debug>;
  constructor(plugin, makeDecoration, name, containerSelector, elSelector, viewType = "markdown") {
    this.plugin = plugin;
    this.makeDecoration = makeDecoration;
    this.containerSelector = containerSelector;
    this.elSelector = elSelector;
    this.viewType = viewType;
    this.decorations = /* @__PURE__ */ new WeakMap();
  }
  onload() {
    this.plugin.registerEvent(
      this.plugin.app.workspace.on(
        "active-leaf-change",
        this.onActiveLeafChange,
        this
      )
    );
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("layout-change", this.onLayoutChange, this)
    );
    this.subscription = combineLatest([
      this.plugin.collections.collectionsSettingsObservable,
      this.plugin.account.observable
    ]).subscribe({
      next: /* @__PURE__ */ __name(() => {
        setTimeout(() => this.onChange("all"), 0);
      }, "next")
    });
  }
  onunload() {
    this.subscription.unsubscribe();
  }
  onActiveLeafChange(leaf) {
    if (!leaf) return;
    this.onChange(leaf);
  }
  onLayoutChange() {
    this.onChange("all");
  }
  onChange(leafOrAll) {
    if (leafOrAll === "all") {
      this.plugin.app.workspace.getLeavesOfType(this.viewType).forEach((leaf) => {
        this.upsertInto(leaf.view);
      });
    } else {
      this.upsertInto(leafOrAll.view);
    }
  }
  upsertInto(view) {
    var _a9;
    const container = view.containerEl.querySelector(this.containerSelector);
    const existing = (_a9 = container == null ? void 0 : container.querySelector(this.elSelector)) != null ? _a9 : null;
    const state = view.getState();
    if (!("file" in state)) {
      if (existing) {
        this.remove(view, existing);
      }
      return;
    }
    const file = state.file;
    const isLoggedOut = !this.plugin.account.get();
    const inCollection = this.plugin.collections.inMountedCollection(file);
    const decoration = this.decorations.get(view);
    if (!inCollection || isLoggedOut) {
      this.remove(view, existing);
      return;
    }
    if (decoration && decoration.path === file) {
      return;
    }
    this.remove(view, existing);
    existing == null ? void 0 : existing.remove();
    if (!container || !(container instanceof HTMLElement)) {
      return;
    }
    const newDecoration = this.makeDecoration(this.plugin, view, file);
    this.decorations.set(view, newDecoration);
  }
  remove(view, el) {
    const decoration = this.decorations.get(view);
    if (!decoration) return;
    decoration.unload();
    this.decorations.delete(view);
    el == null ? void 0 : el.remove();
  }
};
__name(_NoteViewDecorator, "NoteViewDecorator");
var NoteViewDecorator = _NoteViewDecorator;

// src/services/views/passwords/index.ts
init_process_shim();

// src/services/views/passwords/AddPasswordModal.tsx
init_process_shim();
var import_obsidian19 = require("obsidian");
var import_react12 = __toESM(require_react());
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var _AddPasswordModal = class _AddPasswordModal extends Modal {
  constructor(plugin, noteName, noteId, collectionId, afterAdd) {
    super(plugin);
    this.noteName = noteName;
    this.noteId = noteId;
    this.collectionId = collectionId;
    this.afterAdd = afterAdd;
  }
  onOpen() {
    this.setTitle(intl.addPasswordModal.title({ name: this.noteName }));
    this.createRoot(
      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
        ModalContents2,
        {
          noteId: this.noteId,
          collectionId: this.collectionId,
          close: () => this.close(),
          afterAdd: this.afterAdd
        }
      )
    );
  }
};
__name(_AddPasswordModal, "AddPasswordModal");
var AddPasswordModal = _AddPasswordModal;
var ModalContents2 = /* @__PURE__ */ __name(({
  noteId,
  collectionId,
  close,
  afterAdd
}) => {
  const plugin = usePlugin();
  const [label, setLabel] = (0, import_react12.useState)("");
  const [password, setPassword] = (0, import_react12.useState)("");
  const [valid, validationMessage] = (0, import_react12.useMemo)(() => {
    if (label === "" || password === "") return [false, ""];
    if (password.length < 8 || password.length > 72)
      return [false, intl.addPasswordModal.lengthValidation()];
    return [true, ""];
  }, [password, confirm]);
  const addPassword = (0, import_react12.useCallback)(async () => {
    const pw = await plugin.liveDocuments.createNotePassword(
      noteId,
      collectionId,
      label,
      password
    );
    if (pw) {
      await afterAdd();
      close();
    } else {
      new import_obsidian19.Notice(intl.addPasswordModal.errorNotice());
    }
  }, [noteId, collectionId, plugin, label, password]);
  return /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("p", { className: "m-0 p-0", children: intl.addPasswordModal.lengthInfo() }),
    /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("form", { className: "flex flex-col gap-1 mt-2", children: [
      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("label", { htmlFor: "note-password-label", className: "text-muted", children: intl.addPasswordModal.label() }),
      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
        "input",
        {
          id: "note-password-label",
          type: "text",
          name: "label",
          placeholder: intl.addPasswordModal.labelPlaceholder(),
          value: label,
          onChange: (e) => setLabel(e.target.value),
          required: true,
          autoFocus: true
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("label", { htmlFor: "note-password", className: "text-muted", children: intl.addPasswordModal.password() }),
      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
        "input",
        {
          id: "note-password",
          type: "password",
          name: "confirm",
          value: password,
          onChange: (e) => setPassword(e.target.value),
          required: true
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: "flex flex-row justify-between items-center mt-2", children: [
        /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("span", { className: "text-warning", children: validationMessage }),
        /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
          "button",
          {
            type: "button",
            className: "mod-cta",
            disabled: !valid,
            onClick: addPassword,
            children: intl.addPasswordModal.addPassword()
          }
        )
      ] })
    ] })
  ] });
}, "ModalContents");

// src/services/views/status/StatusBarItem.tsx
init_process_shim();
var import_react13 = __toESM(require_react());
var import_client5 = __toESM(require_client());
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
var _StatusBarItem = class _StatusBarItem {
  constructor(plugin) {
    this.root = null;
    this.statusEl = plugin.addStatusBarItem();
    this.statusEl.ariaLabel = "";
    this.statusEl.dataset.tooltipPosition = "top";
    this.statusEl.classList.add("mod-clickable");
    this.statusEl.onclick = async (e) => {
      e.preventDefault();
      const updateAvailable = await firstValueFrom(
        plugin.settings.updateAvailableObservable
      );
      if (updateAvailable) {
        const setting = plugin.app.setting;
        await setting.open();
        await setting.openTabById("community-plugins");
      } else {
        plugin.views.revealView("screengarden:views:home" /* Home */);
      }
    };
    this.root = (0, import_client5.createRoot)(this.statusEl);
    this.root.render(
      /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(DefaultProviders, { app: plugin.app, plugin, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Contents2, { setTooltip: (tt) => this.statusEl.ariaLabel = tt }) })
    );
  }
  remove() {
    var _a9;
    (_a9 = this.root) == null ? void 0 : _a9.unmount();
    this.statusEl.remove();
  }
};
__name(_StatusBarItem, "StatusBarItem");
var StatusBarItem = _StatusBarItem;
var Contents2 = /* @__PURE__ */ __name(({
  setTooltip
}) => {
  var _a9, _b2;
  const plugin = usePlugin();
  const isConnected = useObservable(
    plugin.socket.connected,
    (_b2 = (_a9 = plugin.socket.socket) == null ? void 0 : _a9.isConnected()) != null ? _b2 : false,
    [plugin]
  );
  const hasPoolContention = useObservable(
    plugin.liveDocuments.poolStats.pipe(
      map((pool) => pool.open.required >= pool.size)
    ),
    false,
    [plugin]
  );
  const needsReauth = useObservable(
    from(plugin.settings.observable).pipe(
      map((settings) => {
        var _a10;
        return (_a10 = settings == null ? void 0 : settings.needsReauth) != null ? _a10 : false;
      })
    ),
    false,
    [plugin]
  );
  const newVersionAvailable = useObservable(
    plugin.settings.updateAvailableObservable,
    null,
    [plugin]
  );
  const [icon, tooltip] = (0, import_react13.useMemo)(() => {
    if (needsReauth) return ["cloud-off", intl.statusBarItem.needsReauth()];
    if (!isConnected) return ["cloud-off", intl.statusBarItem.disconnected()];
    if (hasPoolContention)
      return ["leaf", intl.statusBarItem.connectedWithContention()];
    if (newVersionAvailable !== null)
      return ["circle-arrow-up", intl.statusBarItem.newVersionAvailable()];
    return ["leaf", intl.statusBarItem.connected()];
  }, [isConnected, hasPoolContention, needsReauth, newVersionAvailable]);
  (0, import_react13.useEffect)(() => {
    setTooltip(tooltip);
  }, [tooltip]);
  return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("div", { className: "flex flex-row items-center", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
    Icon,
    {
      className: needsReauth ? "text-red-600" : isConnected ? "text-brand" : "text-slate-500",
      name: icon
    }
  ) });
}, "Contents");

// src/services/views/unmount-collection/index.ts
init_process_shim();

// src/services/views/unmount-collection/UnmountCollectionModal.tsx
init_process_shim();
var import_obsidian20 = require("obsidian");
var import_react14 = __toESM(require_react());
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
async function showUnmountCollectionModal(plugin, path) {
  const c = plugin.collections.collectionContaining(path);
  if (!c) return;
  new UnmountCollectionModal(plugin, path, c.collection_id).open();
}
__name(showUnmountCollectionModal, "showUnmountCollectionModal");
var _UnmountCollectionModal = class _UnmountCollectionModal extends Modal {
  constructor(plugin, path, collectionId) {
    super(plugin);
    this.path = path;
    this.collectionId = collectionId;
  }
  onOpen() {
    this.setTitle(intl.unmountModal.title({ path: this.path }));
    this.createRoot(
      /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
        ModalContents3,
        {
          path: this.path,
          collectionId: this.collectionId,
          close: () => this.close()
        }
      )
    );
  }
};
__name(_UnmountCollectionModal, "UnmountCollectionModal");
var UnmountCollectionModal = _UnmountCollectionModal;
var ModalContents3 = /* @__PURE__ */ __name(({
  path,
  collectionId,
  close
}) => {
  const plugin = usePlugin();
  const unmount = (0, import_react14.useCallback)(async () => {
    await plugin.collections.unmount(collectionId);
    new import_obsidian20.Notice(intl.unmountModal.successNotice({ path }));
    close();
  }, [close, plugin, path, collectionId]);
  return /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("div", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("p", { children: intl.unmountModal.explanation() }),
    /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("p", { children: intl.unmountModal.explanation2() }),
    /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("div", { className: "flex flex-row justify-between items-center gap-x-2", children: [
      /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("button", { onClick: close, children: intl.unmountModal.cancel() }),
      /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("button", { className: "mod-cta", onClick: unmount, children: intl.unmountModal.remove() })
    ] })
  ] });
}, "ModalContents");

// src/services/views/ViewsService.ts
var import_debug18 = __toESM(require_browser2());
var import_obsidian21 = require("obsidian");
var log13 = (0, import_debug18.default)("screen.garden:views");
var VIEWS = [HomeView];
var _ViewsService = class _ViewsService extends Service {
  constructor(plugin) {
    super(plugin);
    document.documentElement.style.setProperty("--sg-brand", "#20B03F");
    document.documentElement.style.setProperty("--sg-brand-dark", "#19812F");
    this.statusBarItem = new StatusBarItem(plugin);
    this.viewActions = new NoteViewDecorator(
      plugin,
      (plugin2, view, path) => new ActionDecoration(plugin2, view, path),
      "view-actions",
      ".view-actions",
      ".sg-view-action"
    );
    this.fileExplorer = new FileExplorerDecorator(plugin);
    this.plugin.addRibbonIcon("leaf", "screen.garden", () => {
      this.revealView("screengarden:views:home" /* Home */);
    });
    this.plugin.addCommand({
      id: "show-home-view",
      name: intl.home.commandName(),
      callback: /* @__PURE__ */ __name(() => {
        log13("revealing home view");
        this.revealView("screengarden:views:home" /* Home */);
      }, "callback")
    });
    this.addCurrentLiveDocumentCommand(
      "copy-current-note-url",
      intl.note.copyCurrentURLCommand(),
      copyNoteURLToClipboard
    );
    this.addCurrentLiveDocumentCommand(
      "make-current-note-public",
      intl.note.makeCurrentNotePublicCommand.title(),
      async (_team, collection, note) => {
        const url = await this.plugin.liveDocuments.setAccessLevel(
          note.id,
          collection.id,
          "public"
        );
        if (url) {
          navigator.clipboard.writeText(url);
          new import_obsidian21.Notice(
            intl.note.makeCurrentNotePublicCommand.success({
              name: note.title
            })
          );
        } else {
          new import_obsidian21.Notice(intl.note.accessError());
        }
      }
    );
    this.addCurrentLiveDocumentCommand(
      "make-current-note-password",
      intl.note.makeCurrentNotePasswordCommand.title(),
      async (_team, collection, note) => {
        const passwords = await this.plugin.liveDocuments.getNotePasswords(
          note.id,
          collection.id
        );
        if (!passwords) {
          new import_obsidian21.Notice(intl.note.makeCurrentNotePasswordCommand.noLoadError());
          return;
        }
        const setAccessLevelAndCopy = /* @__PURE__ */ __name(async () => {
          const url = await this.plugin.liveDocuments.setAccessLevel(
            note.id,
            collection.id,
            "password"
          );
          if (url) {
            navigator.clipboard.writeText(url);
            new import_obsidian21.Notice(
              intl.note.makeCurrentNotePasswordCommand.success({
                name: note.title
              })
            );
          } else {
            new import_obsidian21.Notice(intl.note.accessError());
          }
        }, "setAccessLevelAndCopy");
        if (passwords.length === 0) {
          new AddPasswordModal(
            this.plugin,
            note.title,
            note.id,
            collection.id,
            setAccessLevelAndCopy
          ).open();
        } else {
          setAccessLevelAndCopy();
        }
      }
    );
    this.registerEvent(
      this.plugin.app.workspace.on(
        "file-menu",
        (menu, folder) => {
          if (!(folder instanceof import_obsidian21.TFolder)) return;
          if (this.plugin.collections.collectionAtMountPath(folder.path)) {
            menu.addItem((item) => {
              item.setTitle(intl.unmountModal.contextMenuItem()).setIcon("leaf").onClick(async () => {
                showUnmountCollectionModal(this.plugin, folder.path);
              });
            });
          } else if (!this.plugin.collections.inMountedCollection(folder)) {
            menu.addItem((item) => {
              item.setTitle(intl.mountModal.contextMenuItem()).setIcon("leaf").onClick(async () => {
                showMountCollectionModal(this.plugin, folder.path);
              });
            });
          }
        }
      )
    );
    this.settingsSubscription = from(this.plugin.settings.observable).pipe(
      map((s) => {
        var _a9;
        return (_a9 = s == null ? void 0 : s.showStatusIcon) != null ? _a9 : false;
      }),
      distinctUntilChanged()
    ).subscribe((show) => {
      var _a9;
      if (show) {
        if (!this.statusBarItem) {
          this.statusBarItem = new StatusBarItem(plugin);
        }
      } else {
        (_a9 = this.statusBarItem) == null ? void 0 : _a9.remove();
        this.statusBarItem = null;
      }
    });
  }
  async onload() {
    VIEWS.forEach(
      (v) => this.plugin.registerView(
        v.ViewType(),
        (leaf) => new v(this.plugin, leaf)
      )
    );
    this.viewActions.onload();
  }
  async onunload() {
    var _a9;
    this.settingsSubscription.unsubscribe();
    (_a9 = this.statusBarItem) == null ? void 0 : _a9.remove();
    this.viewActions.onunload();
    this.fileExplorer.onunload();
  }
  leafFor(type) {
    const { workspace } = this.plugin.app;
    const t = VIEWS.find((v) => v.ViewType() === type);
    if (!t) return null;
    const leaf = t.LeafIn(workspace);
    leaf.setViewState({ type, active: true });
    return leaf;
  }
  revealView(type) {
    const { workspace } = this.plugin.app;
    const leaf = workspace.getLeavesOfType(type).first() || this.leafFor(type);
    if (leaf) workspace.revealLeaf(leaf);
  }
  addCurrentLiveDocumentCommand(id2, name, run) {
    this.plugin.addCommand({
      id: id2,
      name,
      editorCheckCallback: /* @__PURE__ */ __name((checking) => {
        const file = this.plugin.app.workspace.getActiveFile();
        if (!file) {
          return false;
        }
        if (checking) {
          return this.plugin.collections.inMountedCollection(file);
        }
        this.plugin.collections.dataForFile(file).then((data) => {
          if (!data) {
            new import_obsidian21.Notice(intl.note.commandError());
            return;
          }
          const { team, collection, liveDocument } = data;
          run(team, collection, liveDocument);
        });
      }, "editorCheckCallback")
    });
  }
};
__name(_ViewsService, "ViewsService");
var ViewsService = _ViewsService;

// src/services/editor/index.ts
init_process_shim();

// src/services/editor/EditorService.ts
init_process_shim();

// src/services/editor/screenGardenCollab/index.ts
init_process_shim();

// src/services/editor/screenGardenCollab/screenGardenRemoteSelections.ts
init_process_shim();

// src/services/editor/screenGardenCollab/screenGardenSync.ts
init_process_shim();
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var import_debug19 = __toESM(require_browser2());
var import_obsidian22 = require("obsidian");
var log14 = (0, import_debug19.default)("screen.garden:editor");
var RESET_TIMEOUT = 3e4;
var _ScreenGardenSyncConfig = class _ScreenGardenSyncConfig {
  constructor(plugin) {
    this.plugin = plugin;
  }
};
__name(_ScreenGardenSyncConfig, "ScreenGardenSyncConfig");
var ScreenGardenSyncConfig = _ScreenGardenSyncConfig;
var screenGardenSyncFacet = import_state.Facet.define({
  combine(inputs) {
    return inputs[inputs.length - 1];
  }
});
var screenGardenSyncAnnotation = import_state.Annotation.define();
var _ScreenGardenSyncPluginValue = class _ScreenGardenSyncPluginValue {
  constructor(view) {
    this.view = view;
    this.file = null;
    this.noteID = null;
    this.ytext = null;
    this.release = null;
    this.handlerSubscription = null;
    this.resetId = null;
    this.conf = view.state.facet(screenGardenSyncFacet);
    this._observer = this._observer.bind(this);
    this.conf.plugin.app.workspace.onLayoutReady(this.connect.bind(this));
  }
  destroy() {
    var _a9;
    this.disconnect();
    (_a9 = this.handlerSubscription) == null ? void 0 : _a9.unsubscribe();
  }
  async connect() {
    var _a9;
    const wrapper = (_a9 = this.view.dom.parentElement) == null ? void 0 : _a9.closest(".table-cell-wrapper");
    if (wrapper) {
      return;
    }
    this.disconnect();
    this.file = this.getFile();
    if (!this.file) return;
    const handler = await this.conf.plugin.collections.requireHandlerForFile(
      this.file
    );
    if (handler && handler instanceof NoteHandler) {
      log14("note handler found, connecting");
      this.connectNoteHandler(handler, this.file.name);
    }
    this.handlerSubscription = this.conf.plugin.liveDocuments.handlerChanges.subscribe({
      next: /* @__PURE__ */ __name(async ({ id: id2, path: _path, deleted }) => {
        var _a10;
        const file = this.getFile();
        const path = _path || ((_a10 = await this.conf.plugin.liveDocuments.get(id2)) == null ? void 0 : _a10.path);
        if (!file || (file == null ? void 0 : file.path) !== path) return;
        if (deleted) {
          log14("handler deleted");
          this.disconnect();
          return;
        }
        log14("requiring handler for %s", file.path);
        if (this.noteID && id2 !== this.noteID) {
          this.disconnect();
          this.file = file;
        }
        const handler2 = this.conf.plugin.liveDocuments.getHandlerOfType(
          NoteHandler,
          id2
        );
        if (!handler2) return;
        this.connectNoteHandler(handler2, file.name);
      }, "next")
    });
  }
  /**
   * Connect the note handler to the editor view.
   * Connecting the same handler again is a no-op.
   * @param handler The note handler to connect to the view.
   * @param name The name assigned to this note, for debug logging.
   */
  async connectNoteHandler(handler, name) {
    if (this.noteID === handler.id) return;
    this.noteID = handler.id;
    const handle = await handler.getYTextHandle();
    if (!handle) return;
    this.release = handle.release;
    this.ytext = handle.ytext;
    this.replaceWithYText();
    this.ytext.observe(this._observer);
    log14("connected path:%s to note:%s", name, this.noteID);
  }
  replaceWithYText() {
    if (!this.ytext) return;
    const insert = this.ytext.toString();
    const current = this.view.state.doc.toString();
    if (insert === current) return;
    const scroller = document.querySelector("div.cm-scroller");
    const top = scroller == null ? void 0 : scroller.scrollTop;
    const maintainSelection = this.view.state.selection.ranges.every(
      (s) => s.anchor < insert.length && s.head < insert.length
    );
    this.view.dispatch({
      changes: [
        {
          from: 0,
          to: current.length,
          insert
        }
      ],
      selection: maintainSelection ? this.view.state.selection : void 0,
      annotations: [screenGardenSyncAnnotation.of(this.conf)]
    });
    if (top) {
      requestAnimationFrame(() => {
        scroller.scrollTop = top;
      });
    }
  }
  disconnect() {
    if (this.file && this.conf.plugin.collections.inMountedCollection(this.file)) {
      log14("disconnecting %s", this.file.path);
    }
    if (this.release) {
      this.release();
      this.release = null;
    }
    if (this.resetId) window.clearTimeout(this.resetId);
    this.resetId = null;
    if (this.ytext) {
      this.ytext.unobserve(this._observer);
      this.ytext = null;
    }
    this.noteID = null;
    this.file = null;
  }
  getFile() {
    return this.view.state.field(import_obsidian22.editorInfoField).file;
  }
  update(update) {
    if (!this.ytext) return;
    if (!update.docChanged) return;
    if (update.transactions.length > 0 && update.transactions[0].annotation(screenGardenSyncAnnotation) === this.conf)
      return;
    const ytext = this.ytext;
    if (!ytext || !ytext.doc) return;
    ytext.doc.transact(() => {
      let adj = 0;
      update.changes.iterChanges((fromA, toA, _fromB, _toB, insert) => {
        const insertText2 = insert.sliceString(0, insert.length, "\n");
        if (fromA !== toA) {
          ytext.delete(fromA + adj, toA - fromA);
        }
        if (insertText2.length > 0) {
          ytext.insert(fromA + adj, insertText2);
        }
        adj += insertText2.length - (toA - fromA);
      });
    }, this.conf);
    this.mark();
  }
  _observer(event, txn) {
    if (txn.origin === this.conf) return;
    const delta = event.delta;
    const changes = [];
    let pos = 0;
    for (const d2 of delta) {
      if (d2.insert != null && typeof d2.insert === "string") {
        changes.push({ from: pos, to: pos, insert: d2.insert });
      } else if (d2.delete != null) {
        changes.push({ from: pos, to: pos + d2.delete, insert: "" });
      } else if (d2.retain != null) {
        pos += d2.retain;
      }
    }
    const txnSpec = {
      annotations: [screenGardenSyncAnnotation.of(this.conf)],
      changes
    };
    this.view.dispatch(txnSpec);
    this.mark();
  }
  mark() {
    if (this.resetId) window.clearTimeout(this.resetId);
    this.resetId = window.setTimeout(
      () => this.replaceWithYText(),
      RESET_TIMEOUT
    );
  }
};
__name(_ScreenGardenSyncPluginValue, "ScreenGardenSyncPluginValue");
var ScreenGardenSyncPluginValue = _ScreenGardenSyncPluginValue;
var screenGardenSync = import_view.ViewPlugin.fromClass(
  ScreenGardenSyncPluginValue
);

// src/services/editor/screenGardenCollab/screenGardenRemoteSelections.ts
var import_state2 = require("@codemirror/state");
var import_view2 = require("@codemirror/view");
var import_view3 = require("@codemirror/view");
var import_debug20 = __toESM(require_browser2());
var import_obsidian23 = require("obsidian");
var unconnectedLog = (0, import_debug20.default)("screen.garden:selections");
var screenGardenRemoteSelectionsTheme = import_view2.EditorView.baseTheme({
  ".cm-sgSelection": {},
  ".cm-sgLineSelection": {
    padding: 0,
    margin: "0px 2px 0px 4px"
  },
  ".cm-sgSelectionCaret": {
    position: "relative",
    borderLeft: "1px solid black",
    borderRight: "1px solid black",
    marginLeft: "-1px",
    marginRight: "-1px",
    boxSizing: "border-box",
    display: "inline"
  },
  ".cm-sgSelectionCaretDot": {
    borderRadius: "50%",
    position: "absolute",
    width: ".4em",
    height: ".4em",
    top: "-.2em",
    left: "-.2em",
    backgroundColor: "inherit",
    transition: "transform .3s ease-in-out",
    boxSizing: "border-box"
  },
  ".cm-sgSelectionCaret:hover > .cm-sgSelectionCaretDot": {
    transformOrigin: "bottom center",
    transform: "scale(0)"
  },
  ".cm-sgSelectionInfo": {
    position: "absolute",
    top: "-1.2rem",
    left: "-1px",
    fontSize: "0.9rem",
    lineHeight: "normal",
    userSelect: "none",
    color: "white",
    padding: "0.1rem 0.2rem",
    borderRadius: "2px",
    zIndex: 101,
    transition: "opacity .3s ease-in-out",
    backgroundColor: "inherit",
    opacity: 0,
    transitionDelay: "0s",
    whiteSpace: "nowrap"
  },
  ".cm-sgSelectionCaret:hover > .cm-sgSelectionInfo": {
    opacity: 1,
    transitionDelay: "0s"
  }
});
var sgRemoteSelectionsAnnotation = import_state2.Annotation.define();
var _ScreenGardenRemoteCaretWidget = class _ScreenGardenRemoteCaretWidget extends import_view2.WidgetType {
  constructor(color, name) {
    super();
    this.color = color;
    this.name = name;
  }
  toDOM() {
    return element(
      "span",
      [
        create5("class", "cm-sgSelectionCaret"),
        create5(
          "style",
          `background-color: ${this.color}; border-color: ${this.color}`
        )
      ],
      [
        text("\u2060"),
        element("div", [create5("class", "cm-sgSelectionCaretDot")]),
        text("\u2060"),
        element(
          "div",
          [create5("class", "cm-sgSelectionInfo")],
          [text(this.name)]
        ),
        text("\u2060")
      ]
    );
  }
  eq(widget) {
    return widget.color === this.color;
  }
  compare(widget) {
    return widget.color === this.color;
  }
  updateDOM() {
    return false;
  }
  get estimatedHeight() {
    return -1;
  }
  ignoreEvent() {
    return true;
  }
};
__name(_ScreenGardenRemoteCaretWidget, "ScreenGardenRemoteCaretWidget");
var ScreenGardenRemoteCaretWidget = _ScreenGardenRemoteCaretWidget;
var _ScreenGardenRemoteSelectionsPluginValue = class _ScreenGardenRemoteSelectionsPluginValue {
  constructor(view) {
    this.view = view;
    this.decorations = import_state2.RangeSet.of([]);
    this.log = unconnectedLog;
    this.noteId = null;
    this.listener = null;
    this.noteSubscription = null;
    this._path = null;
    this._anchor = null;
    this._head = null;
    this.conf = view.state.facet(screenGardenSyncFacet);
    this.handlePresenceSync = this.handlePresenceSync.bind(this);
    this.accountSubscription = this.conf.plugin.account.observable.subscribe({
      next: /* @__PURE__ */ __name((account) => {
        this.account = account != null ? account : null;
      }, "next")
    });
    this.listenIfNew();
  }
  destroy() {
    this.accountSubscription.unsubscribe();
    this.unlisten();
  }
  async listenIfNew() {
    var _a9;
    const wrapper = (_a9 = this.view.dom.parentElement) == null ? void 0 : _a9.closest(".table-cell-wrapper");
    if (wrapper) {
      return;
    }
    const file = this.view.state.field(import_obsidian23.editorInfoField).file;
    if (!file || file.path === this._path) return;
    const note = await this.conf.plugin.db.liveDocuments.where({ path: file.path }).first();
    if (!note) return;
    if (this.listener && note.id === this.noteId) return;
    this.unlisten();
    this.noteId = note.id;
    this._path = file.path;
    this.listener = this.conf.plugin.docs.on(
      `presence:${this.noteId}`,
      this.handlePresenceSync
    );
    this.conf.plugin.registerEvent(this.listener);
    this.log = (0, import_debug20.default)(`screen.garden:selections:${this.noteId}`);
    this.log(`listening to doc:${this.noteId} path:${this._path}`);
    const noteId = note.id;
    this.noteSubscription = liveQuery(
      () => this.conf.plugin.db.liveDocuments.get(noteId)
    ).subscribe({
      next: /* @__PURE__ */ __name((newNote) => {
        var _a10;
        const fileField = this.view.state.field(import_obsidian23.editorInfoField, false);
        if (!newNote || newNote.path !== ((_a10 = fileField == null ? void 0 : fileField.file) == null ? void 0 : _a10.path)) {
          this.unlisten();
          this._head = null;
          this._anchor = null;
          this.decorations = import_view3.Decoration.set([], true);
          this.view.dispatch({
            annotations: [sgRemoteSelectionsAnnotation.of([])]
          });
        }
      }, "next")
    });
    this.handlePresenceSync(this.noteId);
  }
  unlisten() {
    var _a9;
    if (this.listener) this.conf.plugin.docs.offref(this.listener);
    this.listener = null;
    this.noteId = null;
    this._path = null;
    this.log = unconnectedLog;
    (_a9 = this.noteSubscription) == null ? void 0 : _a9.unsubscribe();
    this.noteSubscription = null;
  }
  update(update) {
    var _a9, _b2, _c, _d;
    this.listenIfNew();
    if (!this.noteId) return;
    const handler = this.conf.plugin.liveDocuments.getHandlerOfType(
      NoteHandler,
      this.noteId
    );
    const ytext = handler == null ? void 0 : handler.borrowYText();
    if (!ytext) return;
    const ydoc = ytext.doc;
    const clientID = ydoc.clientID;
    const hasFocus = update.view.hasFocus && update.view.dom.ownerDocument.hasFocus();
    const sel = hasFocus ? update.state.selection.main : null;
    if (sel) {
      const anchor = createRelativePositionFromTypeIndex(ytext, sel.anchor);
      const head = createRelativePositionFromTypeIndex(ytext, sel.head);
      if (!compareRelativePositions(this._anchor, anchor) || !compareRelativePositions(this._head, head)) {
        this._anchor = anchor;
        this._head = head;
        this.conf.plugin.liveDocuments.updatePresence(this.noteId, {
          hasFocus,
          clientID,
          hue: toHue((_b2 = (_a9 = this.account) == null ? void 0 : _a9.id) != null ? _b2 : "0"),
          name: (_d = (_c = this.account) == null ? void 0 : _c.name) != null ? _d : "Collaborator",
          cursor: { head, anchor }
        });
      }
    }
    const decorations = [];
    const listed = this.conf.plugin.liveDocuments.listPresences(this.noteId);
    listed.forEach((meta) => {
      if (meta.clientID === clientID) return;
      const { cursor } = meta;
      if (!cursor || !cursor.anchor || !cursor.head) return;
      const absPos = absolutePositionFromCursor(ytext, cursor);
      if (!absPos) return;
      const { start, end, anchor, head } = absPos;
      const color = `hsl(${meta.hue}, 50%, 50%)`;
      const colorLight = `hsl(${meta.hue}, 50%, 50%, 40%)`;
      const name = meta.name;
      try {
        const startLine = update.view.state.doc.lineAt(start);
        const endLine = update.view.state.doc.lineAt(end);
        const selection = import_view3.Decoration.mark({
          attributes: { style: `background-color: ${colorLight}` },
          class: "cm-sgSelection"
        });
        if (startLine.number === endLine.number) {
          decorations.push({
            from: start,
            to: end,
            value: selection
          });
        } else {
          decorations.push({
            from: start,
            to: startLine.from + startLine.length,
            value: selection
          });
          decorations.push({
            from: endLine.from,
            to: end,
            value: selection
          });
          for (let i = startLine.number + 1; i < endLine.number; i++) {
            const linePos = update.view.state.doc.line(i).from;
            decorations.push({
              from: linePos,
              to: linePos,
              value: import_view3.Decoration.line({
                attributes: {
                  style: `background-color: ${colorLight}`,
                  class: "cm-sgLineSelection"
                }
              })
            });
          }
        }
      } catch (error) {
        this.log("Error creating presence decoration", error);
      }
      decorations.push({
        from: head.index,
        to: head.index,
        value: import_view3.Decoration.widget({
          side: head.index - anchor.index > 0 ? -1 : 1,
          block: false,
          widget: new ScreenGardenRemoteCaretWidget(color, name)
        })
      });
    });
    this.decorations = import_view3.Decoration.set(decorations, true);
  }
  handlePresenceSync(id2) {
    if (id2 !== this.noteId) return;
    this.view.dispatch({
      annotations: [sgRemoteSelectionsAnnotation.of([])]
    });
  }
};
__name(_ScreenGardenRemoteSelectionsPluginValue, "ScreenGardenRemoteSelectionsPluginValue");
var ScreenGardenRemoteSelectionsPluginValue = _ScreenGardenRemoteSelectionsPluginValue;
var screenGardenRemoteSelections = import_view2.ViewPlugin.fromClass(
  ScreenGardenRemoteSelectionsPluginValue,
  { decorations: /* @__PURE__ */ __name((v) => v.decorations, "decorations") }
);

// src/services/editor/screenGardenCollab/index.ts
var screenGardenCollab = /* @__PURE__ */ __name((plugin) => {
  const screenGardenSyncConfig = new ScreenGardenSyncConfig(plugin);
  const plugins = [
    screenGardenSyncFacet.of(screenGardenSyncConfig),
    screenGardenSync,
    screenGardenRemoteSelectionsTheme,
    screenGardenRemoteSelections
  ];
  return plugins;
}, "screenGardenCollab");

// src/services/editor/EditorService.ts
var _EditorService = class _EditorService extends Service {
  constructor() {
    super(...arguments);
    this.registerEditorExtension = /* @__PURE__ */ __name(() => {
      const extension = screenGardenCollab(this.plugin);
      this.plugin.registerEditorExtension(extension);
    }, "registerEditorExtension");
  }
  async onload() {
    this.plugin.app.workspace.onLayoutReady(this.registerEditorExtension);
  }
};
__name(_EditorService, "EditorService");
var EditorService = _EditorService;

// src/services/externalProviders/index.ts
init_process_shim();

// src/services/externalProviders/ExternalProvidersService.ts
init_process_shim();

// src/services/externalProviders/ExternalSyncProvider.ts
init_process_shim();
var _ObsidianSync = class _ObsidianSync {
  constructor(plugin) {
    this.name = "Obsidian Sync";
    try {
      this.sync = plugin.app.internalPlugins.plugins.sync;
    } catch (e) {
      this.sync = null;
    }
  }
  get enabled() {
    if (!this.sync) return false;
    return this.sync._loaded || false;
  }
  ignoringPath(path) {
    if (!this.enabled) return false;
    try {
      return this.sync.instance.ignoreFolders.contains(path);
    } catch (e) {
      return false;
    }
  }
  ignorePath(path) {
    if (!this.enabled) return;
    try {
      this.sync.instance.ignoreFolders.push(path);
    } catch (e) {
    }
  }
};
__name(_ObsidianSync, "ObsidianSync");
var ObsidianSync = _ObsidianSync;

// src/services/externalProviders/ExternalProvidersService.ts
var _ExternalProvidersService = class _ExternalProvidersService extends Service {
  constructor(plugin) {
    super(plugin);
    this.providers = [new ObsidianSync(plugin)];
  }
  enabledProviders() {
    return this.formatProviders(this.providers.filter((p) => p.enabled));
  }
  enabledProvidersForPath(path) {
    return this.formatProviders(
      this.providers.filter((p) => p.enabled && !p.ignoringPath(path))
    );
  }
  ignorePath(path) {
    this.providers.forEach((p) => {
      if (!p.enabled || p.ignoringPath(path)) return;
      p.ignorePath(path);
    });
  }
  formatProviders(providers) {
    const p = providers.map((p2) => p2.name);
    switch (p.length) {
      case 0:
        return null;
      case 1:
        return p[0];
      case 2:
        return intl.plurals.two({ val1: p[0], val2: p[1] });
      default:
        return intl.plurals.serial({
          joined: p.slice(0, -1).join(", "),
          last: p[p.length - 1]
        });
    }
  }
};
__name(_ExternalProvidersService, "ExternalProvidersService");
var ExternalProvidersService = _ExternalProvidersService;

// src/db/Database.ts
var import_debug21 = __toESM(require_browser2());
var log15 = (0, import_debug21.default)("screen.garden:db");
var _Database = class _Database extends import_wrapper_default {
  constructor(appId) {
    super(`screen.garden:${appId}`);
    log15("initializing database");
    this.version(1).stores({
      settings: TABLE,
      account: TABLE2,
      collections: TABLE4,
      collectionSettings: SETTINGS_TABLE,
      teams: TABLE5,
      docs: TABLE6,
      pendingNotes: PENDING_TABLE
    });
    this.version(2).stores({
      fileOps: OPS_TABLE,
      etags: ETAGS_TABLE
    });
    this.version(3).stores({
      // Note that these tables track all live documents but are named after notes for legacy reasons.
      notes: TABLE3
    }).upgrade((tx) => {
      return tx.table("notes").toCollection().modify((note) => {
        note.needs_catchup = 0 /* No */;
      });
    });
    this.settings = this.table("settings");
    this.account = this.table("account");
    this.collections = this.table("collections");
    this.collectionSettings = this.table("collectionSettings");
    this.teams = this.table("teams");
    this.docs = this.table("docs");
    this.liveDocuments = this.table("notes");
    this.pendingLiveDocuments = this.table("pendingNotes");
    this.fileOps = this.table("fileOps");
    this.etags = this.table("etags");
  }
  async reset() {
    log15("resetting database");
    await Promise.all([
      this.settings.clear(),
      this.account.clear(),
      this.collections.clear(),
      this.collectionSettings.clear(),
      this.teams.clear(),
      this.docs.clear(),
      this.liveDocuments.clear(),
      this.pendingLiveDocuments.clear(),
      this.fileOps.clear(),
      this.etags.clear()
    ]);
  }
};
__name(_Database, "Database");
var Database = _Database;

// src/ScreenGardenPlugin.ts
var import_debug22 = __toESM(require_browser2());
var import_obsidian24 = require("obsidian");
if (false) {
  global["__ $YJS$ __"] = false;
}
var log16 = (0, import_debug22.default)("screen.garden:plugin");
var _ScreenGardenPlugin = class _ScreenGardenPlugin extends import_obsidian24.Plugin {
  constructor() {
    super(...arguments);
    this.services = [];
  }
  async onload() {
    log16("starting plugin");
    this.appId = this.app.appId;
    this.db = new Database(this.appId);
    this.networkStatus = this.registerService(NetworkStatusService);
    this.settings = this.registerService(SettingsService);
    this.api = this.registerService(ApiService);
    this.protocols = this.registerService(ProtocolHandlerService);
    this.account = this.registerService(AccountService);
    this.docs = this.registerService(DocsService);
    this.liveDocuments = this.registerService(LiveDocumentService);
    this.collections = this.registerService(CollectionsService);
    this.teams = this.registerService(TeamsService);
    this.socket = this.registerService(SocketService);
    this.views = this.registerService(ViewsService);
    this.editor = this.registerService(EditorService);
    this.externalProviders = this.registerService(ExternalProvidersService);
    for (const service of this.services) {
      log16("loading %s", service.constructor.name);
      await service.onload();
    }
    this.app.workspace.onLayoutReady(async () => {
      for (const service of this.services) {
        await service.onLayoutReady();
      }
    });
    if (false) {
      window.sg = this;
    }
  }
  async onunload() {
    for (const service of this.services.reverse()) {
      log16("stopping %s", service.constructor.name);
      await service.onunload();
    }
  }
  registerService(ServiceImpl) {
    log16("registering %s", ServiceImpl.name);
    const service = new ServiceImpl(this);
    this.services.push(service);
    return service;
  }
};
__name(_ScreenGardenPlugin, "ScreenGardenPlugin");
var ScreenGardenPlugin = _ScreenGardenPlugin;

// src/main.ts
var main_default = ScreenGardenPlugin;
/*! Bundled license information:

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.min.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.min.js:
  (**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.min.js:
  (**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

dexie/dist/dexie.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

js-md5/src/md5.js:
  (**
   * [js-md5]{@link https://github.com/emn178/js-md5}
   *
   * @namespace md5
   * @version 0.8.3
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2023
   * @license MIT
   *)

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/

/* nosourcemap */