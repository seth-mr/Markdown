/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Learning
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/Modals/PromptModal.ts
var import_obsidian = require("obsidian");
var PromptModal = class extends import_obsidian.Modal {
  constructor(app, notes) {
    super(app);
    this.resolveFn = null;
    this.notes = notes;
    this.docs = this.notes.flatMap((obj) => {
      const { id, title, tags, path } = obj;
      return tags == null ? void 0 : tags.map((tag) => ({
        id: `${id}-${tag}`,
        value: tag,
        titlePaths: { titles: this.notes.filter((o) => {
          var _a;
          return (_a = o.tags) == null ? void 0 : _a.includes(tag);
        }).map((o) => o.title), paths: this.notes.filter((o) => {
          var _a;
          return (_a = o.tags) == null ? void 0 : _a.includes(tag);
        }).map((o) => o.path) },
        titles: this.notes.filter((o) => {
          var _a;
          return (_a = o.tags) == null ? void 0 : _a.includes(tag);
        }).map((o) => o.title),
        paths: this.notes.filter((o) => {
          var _a;
          return (_a = o.tags) == null ? void 0 : _a.includes(tag);
        }).map((o) => o.path)
      }));
    });
    this.modalEl.addClass("memorizationModal");
  }
  calculateSuggestions(input) {
    const suggestions = [];
    this.docs.forEach((doc) => {
      const value = doc.value;
      const lowerCase = value.toLowerCase().substring(1);
      const upperCase = value.toUpperCase().substring(1);
      if ((lowerCase.contains(input) || upperCase.contains(input) || value.contains(input)) && !value.contains("MemorizationPlugin") && input !== "") {
        if (!suggestions.contains(value.toString())) {
          suggestions.push({ tag: value.toString(), titles: doc.titles, paths: doc.paths });
        }
      }
    });
    return suggestions;
  }
  async open() {
    return new Promise((resolve) => {
      this.resolveFn = resolve;
      super.open();
    });
  }
  async onOpen() {
    this.docs = this.docs.filter(
      (value, index, self) => index === self.findIndex((t) => t.value === value.value)
    );
    this.titleEl.createEl("h1", { text: "Search by tag" });
    const searchInput = this.contentEl.createEl("input", { type: "text", cls: "memorizationSearchInput" });
    const suggestionsContainer = this.contentEl.createEl("div", { cls: "memorizationSuggestionsContainer" });
    searchInput.addEventListener("input", async (e) => {
      var _a, _b;
      suggestionsContainer.textContent = "";
      const query = (_b = (_a = e.target) == null ? void 0 : _a.value) != null ? _b : "";
      const suggestions = this.calculateSuggestions(query);
      if (suggestions.length > 0) {
        suggestionsContainer.style.visibility = "visible";
      } else {
        suggestionsContainer.style.visibility = "hidden";
      }
      suggestions.forEach((suggestion) => {
        const item = suggestionsContainer.createEl("div", { cls: "memorizationItemLeave" });
        item.textContent = suggestion.tag;
        item.addEventListener("mouseenter", () => {
          item.className = "memorizationItemEnter";
        });
        item.addEventListener("mouseleave", () => {
          item.className = "memorizationItemLeave";
        });
        item.addEventListener("click", async () => {
          const filteredTitles = suggestion.titles.filter((str) => !str.includes("[Memorization-Plugin]"));
          suggestion.titles = await filteredTitles;
          const mergedArray = filteredTitles.map((value, index) => {
            return { title: value, path: suggestion.paths[index] };
          });
          suggestion.titlePaths = mergedArray;
          if (this.resolveFn) {
            this.resolveFn(suggestion);
            this.resolveFn = null;
            this.close();
          }
          this.app.workspace.onLayoutReady(() => {
            this.close();
          });
        });
      });
    });
  }
};

// src/StudyNote.ts
var import_obsidian2 = require("obsidian");
var DIRECTORYPATH = "./MemorizationPlugin/";
var PATH = "MemorizationPlugin/";
var StudyNote = class {
  constructor(app, title, path) {
    this.originalTitle = title;
    this.title = this.formatNewTitle(title);
    this.path = PATH + this.title;
    this.app = app;
    this.efScore = "2.5";
    this.interval = 0;
    this.repetition = "0";
    this.dateIntervalSet = "0";
    this.quality = "0";
  }
  formatNewTitle(title) {
    const words = title.split("/");
    const modifiedWords = words.map((word) => `[Memorization-Plugin]-${word}`);
    const resultString = modifiedWords.join("/");
    return resultString;
  }
  async createStudyNote() {
    const originalFile = this.app.vault.getAbstractFileByPath(this.originalTitle);
    if (!(originalFile instanceof import_obsidian2.TFile)) {
      return;
    }
    let content = await this.app.vault.read(originalFile);
    const formattedContent = content.replace(/[\r\n]+/g, "\n>");
    const finalFormattedContent = formattedContent.replace(/#\S+/g, "");
    content = "\n#MemorizationPlugin\n>[!INFO]- \n>" + finalFormattedContent;
    content += '\n\n\n\n<form id="learning_level">    <input type="radio" id="memorize-plugin-radio-option0" name="radioOptions" value="0">    <label for="memorize-plugin-radio-option0">0 - No clue.</label>    <br>    <input type="radio" id="memorize-plugin-radio-option1" name="radioOptions" value="1">    <label for="memorize-plugin-radio-option1">1 - You have the slightest clue.</label>    <br>    <input type="radio" id="memorize-plugin-radio-option2" name="radioOptions" value="2">    <label for="memorize-plugin-radio-option2">2 - You have some recollection of this note.</label>    <br>    <input type="radio" id="memorize-plugin-radio-option3" name="radioOptions" value="3">    <label for="memorize-plugin-radio-option3">3 - You remembered this note, but it was difficult.</label>    <br>    <input type="radio" id="memorize-plugin-radio-option4" name="radioOptions" value="4">    <label for="memorize-plugin-radio-option4">4 - You semi-confidently remembered this note.</label>    <br>    <input type="radio" id="memorize-plugin-radio-option5" name="radioOptions" value="5">    <label for="option5">5 - That was easy.</label>    </form><br /><br />    <input id="memorize-plugin-button" value="Next" type="button"/><br />     <label style="font-weight: bold; font-size: 16px;" for="memorize-plugin-button">Note: To study another tag or note, you must select a tag from the Memorization plugin search bar.</label>';
    const file = this.app.vault.getAbstractFileByPath(this.path);
    if (!file) {
      const regex = /\n?---[\s\S]*?---\n?|\n?>(?=#)/g;
      const updatedStr = content.replace(regex, "");
      const frontmatter = `
---
memorize-plugin-ef:${this.efScore}
memorize-plugin-score:0
memorize-plugin-current-date:${this.dateIntervalSet}
memorize-plugin-previous-date:${this.dateIntervalSet}
memorize-plugin-repetitions:${this.repetition}
memorize-plugin-interval:${this.interval}
---
`;
      const updatedContent = frontmatter + updatedStr;
      this.content = updatedContent;
      await this.initializeNotes(updatedContent);
      const file2 = this.app.vault.getAbstractFileByPath(this.path);
      if (file2) {
        file2.name = this.title;
      }
    } else {
      this.loadFile();
    }
  }
  async initializeNotes(updatedContent) {
    const results = this.path.split("/").reduce((result, directory) => {
      if (result.length === 0) {
        result.push(directory);
      } else {
        const lastDirectory = result[result.length - 1];
        result.push(`${lastDirectory}/${directory}`);
      }
      return result;
    }, []);
    for (let path of results) {
      if (path == "MemorizationPlugin") {
        const exists = await this.app.vault.adapter.exists("MemorizationPlugin");
        if (!exists) {
          await this.app.vault.createFolder(DIRECTORYPATH);
        }
      } else if (path.contains(".md")) {
        const file = await this.app.vault.create(path, updatedContent);
        await this.app.vault.modify(file, updatedContent);
      } else {
        const exists = await this.app.vault.adapter.exists((0, import_obsidian2.normalizePath)(path));
        if (!exists) {
          await this.app.vault.createFolder(path);
        }
      }
    }
  }
  deleteNote() {
    const file = this.app.vault.getAbstractFileByPath(this.path);
    this.app.vault.delete(file);
  }
  async loadFile() {
    const scoreRegex = /memorize-plugin-score:\s*(\d+)/;
    const curDateRegex = /memorize-plugin-current-date:(.*)/;
    const efRegex = /memorize-plugin-ef:\s*(\d+)/;
    const repetitionsRegex = /memorize-plugin-repetitions:(\d+)/;
    const intervalRegex = /memorize-plugin-interval:(\d+)/;
    const originalFile = this.app.vault.getAbstractFileByPath(this.path);
    this.content = await this.app.vault.read(originalFile);
    const contents = this.content;
    const match = contents.match(scoreRegex);
    const dateMatch = contents.match(curDateRegex);
    const efMatch = contents.match(efRegex);
    const repetitionsMatch = contents.match(repetitionsRegex);
    const intervalMatch = contents.match(intervalRegex);
    this.efScore = efMatch && efMatch[1];
    this.quality = match && match[1];
    const interval = intervalMatch && intervalMatch[1];
    this.interval = parseInt(interval);
    this.repetition = repetitionsMatch && repetitionsMatch[1];
    const noteDate = dateMatch && dateMatch[1];
    this.dateIntervalSet = noteDate;
    const dateIntervalSet = new Date(noteDate);
    const today = new Date();
    const difference = today.getTime() - dateIntervalSet.getTime();
    const diffInDays = Math.floor(difference / (1e3 * 60 * 60 * 24));
    if (diffInDays < 0) {
      this.interval = diffInDays;
    }
  }
  calculateSuperMemoEF() {
    const repetitions = parseInt(this.repetition, 10);
    const quality = parseInt(this.quality, 10);
    let ef = parseFloat(this.efScore);
    ef = parseFloat(ef.toFixed(1));
    if (quality >= 3) {
      if (repetitions === 0) {
        this.interval = 1;
      } else if (repetitions === 1) {
        this.interval = 6;
      } else if (repetitions > 1) {
        const i = Math.ceil(this.interval * ef);
        this.interval = i;
      }
      this.repetition = (repetitions + 1).toString();
      this.efScore = (ef + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02))).toFixed(1);
    } else {
      this.repetition = "0";
      this.interval = 1;
    }
    if (ef < 1.3) {
      this.efScore = "1.3";
    }
  }
  updateNoteText() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (activeView) {
      const file = activeView.file;
      const abstractFile = this.app.vault.getAbstractFileByPath(this.title);
      this.calculateSuperMemoEF();
      const regex = /\n?---[\s\S]*?---\n?|\n?>(?=#)/g;
      const finalContent = this.content.replace(regex, `
---
memorize-plugin-ef:${this.efScore}
memorize-plugin-score:${this.quality}
memorize-plugin-current-date:${this.dateIntervalSet}
memorize-plugin-previous-date:${this.dateIntervalSet}
memorize-plugin-repetitions:${this.repetition}
memorize-plugin-interval:${this.interval}
---
`);
      this.content = finalContent;
      if (file) {
        this.app.vault.modify(file, finalContent);
      } else {
        this.app.vault.modify(abstractFile, finalContent);
      }
    }
  }
  setQuality(quality) {
    this.quality = quality;
    this.dateIntervalSet = new Date().toISOString();
  }
  async display(createTabs) {
    await this.app.workspace.openLinkText(this.path, this.path, createTabs, { state: { mode: "preview" } });
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (activeView) {
      const viewState = activeView.getState();
      viewState.mode = "preview";
      activeView.setState(viewState, {});
    }
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  deleteNotes: false,
  createTabs: true
};
var Learning = class extends import_obsidian3.Plugin {
  async onload() {
    console.log("loading plugin - Memorization");
    await this.loadSettings();
    this.currentLearningNoteIndex = 0;
    this.notes = [];
    this.studyNotes = [];
    this.addRibbonIcon("brain-cog", "Memorize Notes", async () => {
      await this.startStudy();
    });
    this.addCommand({
      id: "PromptModal",
      name: "Study tag",
      checkCallback: (checking) => {
        if (!checking) {
          (async () => {
            await this.startStudy();
          })();
        }
        return true;
      }
    });
    this.addSettingTab(new MemorizeSettingTab(this.app, this));
    this.registerDomEvent(document, "click", async (evt) => {
      const element = evt.composedPath()[0];
      if (element.id.contains("memorize-plugin-radio")) {
        this.currentLearningNote.setQuality(element.value);
      } else if (element.id.contains("memorize-plugin-button")) {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (activeView) {
          this.deleteOrUpdateNote();
          this.goToNextNote();
        }
      }
    });
  }
  deleteOrUpdateNote() {
    if (this.settings.deleteNotes) {
      if (this.currentLearningNote) {
        this.currentLearningNote.deleteNote();
        this.studyNotes.remove(this.currentLearningNote);
        this.currentLearningNoteIndex -= 1;
      }
    } else {
      if (this.currentLearningNote) {
        this.currentLearningNote.updateNoteText();
      }
    }
  }
  goToNextNote() {
    const nextIndex = this.currentLearningNoteIndex + 1;
    if (nextIndex < this.studyNotes.length) {
      this.currentLearningNoteIndex = nextIndex;
      this.currentLearningNote = this.studyNotes[nextIndex];
      if (this.currentLearningNote) {
        this.currentLearningNote.display(this.settings.createTabs);
      }
    } else {
      this.currentLearningNoteIndex = 0;
      this.studyNotes = this.studyNotes.sort((a, b) => a.interval - b.interval);
      this.currentLearningNote = this.studyNotes[this.currentLearningNoteIndex];
      if (this.currentLearningNote) {
        this.currentLearningNote.display(this.settings.createTabs);
      }
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async startStudy() {
    const files = this.app.vault.getMarkdownFiles();
    let notes = [];
    let i = 0;
    files.forEach((file) => {
      const cache = this.app.metadataCache.getCache(file.path);
      const tags = (0, import_obsidian3.getAllTags)(cache);
      notes.push({ id: i, tags, title: file.path, path: this.app.vault.getResourcePath(file) });
      i++;
    });
    this.notes = notes;
    this.suggestionResults = await new PromptModal(this.app, this.notes).open();
    const p = this.suggestionResults.titlePaths[0].path;
    const s = (0, import_obsidian3.normalizePath)(p);
    this.studyNotes = [];
    for (const titlePath of this.suggestionResults.titlePaths) {
      const studyNote = new StudyNote(this.app, titlePath.title, (0, import_obsidian3.normalizePath)(titlePath.path));
      await studyNote.createStudyNote();
      this.studyNotes.push(studyNote);
    }
    this.studyNotes = this.studyNotes.sort((a, b) => a.interval - b.interval);
    this.currentLearningNote = this.studyNotes[this.currentLearningNoteIndex];
    this.studyNotes[this.currentLearningNoteIndex].display(this.settings.createTabs);
  }
};
var MemorizeSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "General Settings" });
    new import_obsidian3.Setting(containerEl).setName("Delete memorization notes after creation").setDesc("Note: this will disable the spaced repetition feature.").addToggle((toggle) => toggle.setValue(this.plugin.settings.deleteNotes).onChange(async (value) => {
      this.plugin.settings.deleteNotes = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Enable creation of new tabs").setDesc("By default, when you go to the next note in the sequence, a new tab is not created. Enable this if you'd like a new tab created.").addToggle((toggle) => toggle.setValue(this.plugin.settings.createTabs).onChange(async (value) => {
      this.plugin.settings.createTabs = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "About" });
    containerEl.createEl("a", { text: "Memorization", href: "https://github.com/nwindian/Memorization-Plugin" });
  }
};


/* nosourcemap */